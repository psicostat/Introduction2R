[["index.html", "Introduction to R Corso per imparare le basi di R Presentazione Perchè R Struttura del libro Risorse Utili Psicostat Collaborazione Riconoscimenti Licenza", " Introduction to R Corso per imparare le basi di R Claudio Zandonella Callegher and Filippo Gambarota members of Psicostat 24-03-2021 Presentazione In questo libro impareremo le basi di R, uno dei migliori software per la visualizzazione e l’analisi statistica dei dati. Partiremo da zero intorducendo gli aspetti fondamentili di R e i concetti alla base di ogni linguaggio di programmazione che ti pemetteranno in seguito di approfondire e sviluppare le tue abilità in questo bellissimo mondo. Perchè R Ci sono molte ragioni per cui scegliere R rispetto ad altri programmi usati per condurre le analisi statistiche. Innanzitutto è un linguaggio di programmazione (come ad esempio Python, Java, C++, o Julia) e non semplicemente un’interfaccia punta e clicca (come ad esempio SPSS o JASP). Questo comporta si maggiori difficoltà iniziali ma ti ricompenserà in futuro poichè avari imparato ad utilizza uno strumennto molto potente. Inoltre, R è: nato per la statistica open-source ricco di pacchetti supportato da una grande community gratis Struttura del libro Il libro è suddiviso in quattro sezioni principali: Get started. Una volta installato R ed RStudio, famiglierizzeremo con l’ambiente di lavoro introducendo alcuni aspetti generali e le funzioni principali. Verranno inoltre descritte alcune buone regole per iniziare una sessione di lavoro in R. Struttura dei dati. Impareremo gli oggetti principali che R utilizza al suo interno. Variabili, vettori, matrici, dataframe e liste non avranno più segreti e capiremo come manipolarli e utlizzarli a seconda delle varie necessità. Algoritmi. Non farti spaventare da questo nome. Ne avrai spesso sentito parlarne come qualcosa di molto complicato, ma in realtà gli algoritmi sono semplicemente una serie di istruzioni che il computer segue quando deve eseguire un determinato compito. In questa sezione vedremo i principali comandi di R usati per definire degli algoritmi. Questo è il vantaggio di conoscere un linguaggio di programmazione, ci permette di creare nuovi programmi che il computer eseguirà per noi. Case study. Eseguiremo passo per passo un analisi che ci permetterà di imparare come importare i dati, codificare le variabili, manipolare e preprare i dati perle analisi, condurre delle analisi descrittive e creare dei grafici. Alla fine di questo libro probabilmente non sarete assunti da Google, ma speriamo almeno che R non vi faccia più così paura e che magari a qualcuno sia nato l’interesse di approfondire questo fantastico mondo fatto di linee di codice. Risorse Utili Segnaliamo qui per il lettore interessato del materiale online (in inglese) per approfondire le conoscenze sull’uso di R. Materiale introduttivo: R for Psychological Science di Danielle Navarro https://psyr.djnavarro.net/index.html Hands-On Programming with R di Garrett Grolemund https://rstudio-education.github.io/hopr/ Materiale intermedio: R for Data Science di Hadley Wickham e Garrett Grolemund https://r4ds.had.co.nz/ Materiale avanzato: R Packages di Hadley Wickham e Jennifer Bryan https://r-pkgs.org/ Advanced R di Hadley Wickham https://adv-r.hadley.nz/ Psicostat Questo libro è stato prodotto da Claudio Zandonella Callegher and Filippo Gambarota, membri di Psicostat. Un gruppo di ricerca interdisciplinare dell’universita di Padova che unisce la passione per la statistica e la psicologia. Se vuoi conoscere di più riguardo le nostre attività visita il nosto sito https://psicostat.dpss.psy.unipd.it/ o aggiungiti alla nostra mailing list https://lists.dpss.psy.unipd.it/postorius/lists/psicostat.lists.dpss.psy.unipd.it/. Collaborazione Se vuoi collaborare alla revione e scrittura di questo libro (ovviamente è tutto in R) visita la nostra repository di Github https://github.com/psicostat/Introduction2R. Riconoscimenti Il template di questo libro è basato su Rstudio Bookdown-demo rilasciato con licenza CC0-1.0 e rstudio4edu-book rilasciato con licenza CC BY. Nota che le illustrazioni utilizzate nelle vignette appartengono sempre a rstudio4edu-book e sono rilasciate con licenza CC BY-NC. Licenza Questo libro è rilasciato sotto la Creative Commons Attribution-ShareAlike 4.0 International Public License (CC BY-SA). Le illustrazioni utilizzate nelle vignette appartengono a rstudio4edu-book e sono rilasciate con licenza CC BY-NC. "],["intorduzione.html", "Intorduzione", " Intorduzione In questa sezione verranno prima presentate le istruzioni per installare R ed RStudio. Successivamente, svolgeremo le prime oprazioni in R e famiglierizzeremo con dei concetti di base della programmazioene quali gli oggetti e le funzioni. Introdurremmo infine altri concetti relativi alle sessioni di lavoro in R e descriveremo alcune buone regole per nell’utilizzo di R. I capitoli sono così organizzati: Capitolo 1 - Installare R e RStudio. Instruzioni passo a passo per installare R e RStudio Capitolo 2 - Interfaccia RStudio. Introduzione all’interfaccia utente di RStudio. Capitolo 3 - Primi Passi in R. Operatori matematici, operatori relazionali, operatori logici. Capitolo 4 - Due Compagni Inseparabili. Introduzione dei concetti di oggetti e funzioni in R. Capitolo 5 - Ambiente di Lavoro. Introduzione dei concetti di Envieronment, working directory e dei pacchetti di R. Capitolo 6 - Sessione di Lavoro. Descrizione di buone pratiche nelle sessioni di lavoro e gestione degli errori. "],["install.html", "Capitolo 1 Installare R e RStudio 1.1 Installare R 1.2 Installare R Studio", " Capitolo 1 Installare R e RStudio R ed R-studio sono due software distinti. R è un linguaggio di programmazione usato in particolare in ambiti quali la statistica. R-studio invece è un’interfaccia user-friendly che permette di utilizzare R. R può essere utilizzato autonomamente tuttavia è consigliato l’utilizzo attraverso R-studio. Entrambi vanno installati separatamente e la procedura varia a seconda del proprio sistema operativo (Windows, MacOS o Linux). Riportiamo le istruzioni solo per Windows e MacOS Linux (Ubuntu). Ovviamente R è disponibile per tutte le principali distribuzioni di Linux. Le istruzioni riportate per Ubuntu (la distribuzione più diffusa) sono valide anche per le distribuzioni derivate. 1.1 Installare R Accedere al sito https://www.r-project.org Selezionare la voce CRAN (Comprehensive R Archive Network) dal menù di sinistra sotto Download Selezionare il primo link https://cloud.r-project.org/ Selezionare il proprio sistema operativo 1.1.1 R Windows Selezionare la voce base Selezionare la voce Download della versione più recente di R disponibile Al termine del download, eseguire il file e seguire le istruzioni fino al termine dell’installazione 1.1.2 R MacOS Selezionare della versione più recente di R disponibile Al termine del download, eseguire il file e seguire le istruzioni fino al termine dell’installazione di R Successivamente è necessario installare anche una componente aggiuntiva XQuartz premendo il link all’interno del riquadro arancione riportato nella figura precedente Selezionare la voce Download Al termine del download, eseguire il file e seguire le istruzioni fino al termine dell’installazione 1.1.3 R Linux Nonostante la semplicità di installazione di pacchetti su Linux, R a volte potrebbe essere più complicato da installare per via delle diverse distribuzioni, repository e chiavi per riconoscere la repository come sicura. Sul CRAN vi è la guida ufficiale con tutti i comandi apt da eseguire da terminale. Seguendo questi passaggi non dovrebbero esserci problemi. Andate sul CRAN Cliccate Download R for Linux Selezionate la vostra distribuzione (Ubuntu in questo caso) Seguite le istruzioni, principalmente eseguendo i comandi da terminale suggeriti Per qualsiasi difficoltà o errore, sopratutto con il mondo Linux, una ricerca su online risolve sempre il problema. Utilizzi avanzati di R richiedono l’insallazione di una serie ulteriore software definiti R tools. Windows Seleziona la voce Rtools e segui le istruzioni per completare l’installazione. Nota che sono richieste anche delle operazioni di configurazione affinchè tutto funzioni correttamente. MacOS Seleziona la voce tools e segui le istruzioni riportate. Nota in particolare che con R 4.0 le seguenti indicazioni sono riportate. 1.2 Installare R Studio Accedere al sito https://rstudio.com Selezionare la voce DOWNLOAD IT NOW Selezionare la versione gratuita di RStudio Desktop Selezionare la versione corretta a seconda del proprio sistema operativo Al termine del download, eseguire il file e seguire le istruzioni fino al termine dell’installazione 1.2.1 R Studio in Linux In questo caso, come su Windows e MacOS l’installazione consiste nello scaricare ed eseguire il file corretto, in base alla distribuzione (ad esempio .deb per Ubuntu e derivate). Importante, nel caso di Ubuntu (ma dovrebbe valere anche per le altre distribuzioni) anche versioni successive a quella indicata (es. Ubuntu 16) sono perfettamente compatibili. "],["rstudio-gui.html", "Capitolo 2 Interfaccia RStudio", " Capitolo 2 Interfaccia RStudio In questo capitolo presenteremo l’interfaccia utente di RStudio. Molti aspetti che introdurremo brevemente qui verranno discussi nei sucessivi capitoli. Adesso ci interessa solo famigliarizzare con l’interfaccia del nostro strumento di lavoro principale ovvero RStudio. Come abbiamo visto nel Capitolo 1, R è il vero “motore computazionale” che ci permette di compiere tutte le operazioni di calcolo, analisi statistiche e magie varie. Tuttavia l’interfaccia di base di R, definita Console (vedi Figura 2.1), è per così dire démodé o meglio, solo per veri intenditori. Figure 2.1: La console di R, solo per veri intenditori In genere, per lavorare con R viene utilizzato RStudio. RStudio è un programma (IDE - Integrated Development Environment) che integra in un unica interfaccia utente (GUI - Graphical User Interface) diversi strumenti utili per la scrittura ed esecuzione di codici. L’interfaccia di RStudio è costituita da 4 pannelli principali (vedi Figura 2.2): Figure 2.2: Interfaccia utente di Rstudio con i suoi 4 pannelli L’utilizzo di R attraverso l’interfaccia di base piuttosto che RStudio, non è uno scontro tra due scuole di pensiero (o generazioni). Entrambe hanno vantaggi e svantaggi e pertanto vengono scelte a seconda delle dieverse necessità. Quando si è alla ricerca della massima ottimizzazione, l’uso dell’interfaccia di base, grazie alla sua semplicità, permette di minimizzare l’utilizzo della memoria limitandosi allo stretto e necessario. In altri casi, invece, le funzionalità e strumenti aggiuntivi di RStudio permettono una maggiore efficacia nel proprio lavoro. 1. Console: il cuore di R Qui ritroviamo la Console di R dove vengono effetivemente eseguiti tutti i tuoi codici e comandi. Nota come nell’ulitma riga della Console appaia il carattere &gt;. Questo è definito prompt è ci indica che R in attesa di nuovi comandi da eseguire. La Console di R è un’interfaccia a linea di comando. A differenza di altri programmi “punta e clicca”, in R è necessario digitare i comandi utilizzando la tastiera. Per eseguire dei comandi possiamo direttamnte scrivere nella Console le operazioni da eseguire e premere invio. R eseguirà immediatamente i nostro comando, riporterà il risultato e nella linea successiva apparirà nuovamente il prompt indicando che R è pronto ad eseguire un altro comando (vedi Figura 2.3). Figure 2.3: Esecuzione di comandi direttamente nella console Nel caso di comandi scritti su più righe, vedi l’esempio di Figura 2.4, è possibile notare come venga mostrato il simbolo + come prompt. Questo indica che R è in attesa che l’intero comando venga digitato prima che esso venga eseguito. Figure 2.4: Esecuzione di un comando su più righe Come avrai notato facendo alcune prove, i comandi digitati nella Console vengono eseguiti immediatamente ma non sono salvati. Per rieseguire un comando, possiamo navigare tra quelli precedentementemente eseguiti usando le freccie della tastiera \\(\\uparrow\\downarrow\\). Tuttavia, in caso di errori dovremmo riscrivere e rieseguire tutti i comandi. Siccome scrivere codici è un continuo “try and error”, lavorare unicamente dalla Console diventa presto caotico. Abbiamo bisogno quindi di una soluzione che ci permetta di lavrorare più comodamente sui nostri codici e di poter salvare i nostri comandi da eseguire all’occorrenza con il giusto ordine. La soluzione sono gli Scripts che introdurremo vedremo nella prossima sezione. Potrebbe accadere che per qualche errore nel digitare un comando o perchè sono richiesti lunghi tempi computazionali, la Console di R diventi non responsiva. In questo caso è necessario interrompere la scrittura o l’esecuzione di un comando. Vediamo due situazioni comuni: Continua a comparire il prompt +. Specialmente nel caso di utilizzo di parentesi e lunghi comandi, accade che una volta premuto invio R non esegua alcun comando ma resta in attesa mostrando il prompt + (vedi Figure seguente). Questo è in genere dato da un errore nella sintassi del comando (e.g., un errore nell’uso delle parentesi o delle virgole). Per riprendere la sessione è necessario premere il tasto esc della tastiera. L’apprire del prompt &gt;, indica che R è nuovamente in ascolto pronto per esequire un nuovo comando ma attento a non ripetere lo stesso errore, la sintassi dei comandi è importante (vedi Capitolo TODO). R non risponde. Alcuni calcoli potrebbero richiedere molto tempo o semplicemnte un qualche problema ha mandato in loop la tua sessione di lavoro. In questa situazione la Console di R diventa non responsiva. Nel caso fosse necessario interrompere i processi attualmente in esecuzione devi premere il pulsante STOP come indicato nella Figura seguente. R si fermerà e ritornerà in attesa di nuovi comandi (prompt &gt;). In alcuni casi estremi in cui R sembra non rispondere, usa i comandi Ctrl-C per forzare R a interrompere il processo in esecuzione. Come ultima soluzione ricorda uno dei principi base dell’informatica “spegni e riaccendi” (a volte potrebbe bastare chiudere e riaprire RStudio). 2. Source: il tuo blocco appunti In questa parte vengono mostrati i tuoi Scripts. Questi non sono altro che degli speciali documenti (con estensione “.R”) in cui sono salvati i tuoi codici e comandi che potrai eseguire quando necessario in R. Gli Scripts ti permetteranno di lavorare comodamente sui tuoi codici, scrivere i comandi, corregerli, organizzarli, aggiungere dei commenti e soprattutto salvarli. Dopo aver terminato di scrivere i comandi, posiziona il cursore sulla stessa linea del comando che desideri eseguire e premi command + invio (MacOs) o Ctrl+R (Windows). Automaticamente il comando verà copiato nella Console ed eseguito. In alternativa potrai premere il tasto Run indicato dalla freccia in Figura 2.5. Figure 2.5: Esecuzione di un comando da script premi command + invio (MacOs)/ Ctrl+R (Windows) o premi il tasto indicato dalla freccia Se hai guardato con attenzione lo script rappresentato in Figura 2.5, potresti aver notato delle righe di testo verde precedute dal simbolo #. Questo simbolo può essere utlizzato per inserire dei commenti all’interno dello script. R ignorerà qualsiasi commento ed eseguirà soltato le parti di codici. L’utilizzo dei commenti è molto importante nel caso di script complessi poichè ci permette di spiegare e documentare il codice che viene eseguito. Nel Capitolo TODO approfondiremo il loro utilizzo. Per creare un nuovo script è sufficiente premere il pulsante in alto a sinistra come mostrato in Figura e selezionare “R Script”. Unn nuovo script senza nome verrà creato. Per salvare lo script premere l’icona del floppy e indicare il nome. Ricorda di usare l’estensione “.R” per salvare gli script. 3. Environment e History: la sessione di lavoro Qui sono presentati una serie di pannelli utili per valutare informazioni inerenti alla propria sessione di lavoro. I pannelli principali sono Environment e History (gli altri pannelli presenti in Figura 2.6 riguardanno funzioni avanzate di RStudio). Environment: elenco tutti gli oggetti e variabili attualmente presenti nel’ambiente di lavoro. Approfondiremo i concetti di variabili e di ambiente di lavoro rispettivamente nel Capitolo 4 e Capitolo TODO. Figure 2.6: Environment - Elenco degli oggetti e variabili presenti nel’ambiente di lavoro History: elenco di tutti i comandi precedentemente eseguiti nella console. Nota che questo no equivale ad uno script, anzi, è semplicemente un elenco non modificabile (e quasi mai usato). 4. File, Plots, Package, Help: system management In questa parte sono raccolti una serie di pannelli utilizzatti per interfacciarsi con ulteriori risorse del sistema (e.g., file e pacchetti) o produrre output quali grafici e tabelle. Files: pannello da cui è possibile navigare tra tutti i file del proprio computer Figure 2.7: Files - permette di navigare tra i file del proprio computer Plots: pannello i cui vengono prodotti i grafici e che è possibil esportare cliccando Export. Figure 2.8: Plots - presentazione dei grafici Packages: elenco dei pacchetti di R (questo argomento verrà approfondito nel Capitolo TODO). Figure 2.9: Packages - elenco dei pacchetti di R Help: utilizzato per navigare la documentazione interna di R (questo argomento verrà approfondito nel Capitolo TODO). Figure 2.10: Help - documentazione di R RStudio permette un ampio grado di personalizzazione dell’intrafaccia grafica utilizzata. E’ possibile cambiare tema, font e disposizione dei pannelli a seconda dei tuoi gusti ed esigenze. Prova a cambiare il tema dell editor in Idle Fingers per utlizzare on background scuro che affatichi meno la vista (vedi Figura seguente). Clicca su RStudio &gt; Preferenze &gt; Appearence (MacOS) o Tools &gt; Options &gt; Appearence (Windows). "],["first-comands.html", "Capitolo 3 Primi Passi in R 3.1 Operatori Matematici 3.2 Operatori Relazionali e Logici", " Capitolo 3 Primi Passi in R Ora che abbiamo iniziato a famigliarizzare con il nostro stumento di lavoro possiamo finalmente dare fuoco alle polveri e concentraci sulla scrittura di codici! In questo capitolo muoveremo i primi passi in R. Inizieremo vedendo come utilizzare operatori matematici, relazionali e logici per compiere semplici operazioni in R. Imparare R è un lungo percorso (scoop: questo percorso non termina mai dato che R è sempre in continuo sviiluppo). Soprattutto all’inizio può sembrare eccessivamente difficile poichè è si incontrano per la prima volta molti comandi e concetti di programmazione. Tuttavia, una volta famigliarizzato con gli apetti di base, la progressione diventa sempre più veloce (inarrestabile direi!). In questo capitolo introdurremo per la prima volta molti elementi che saranno poi ripresi e approfonditi nei seguenti capitoli. Quindi non preoccuparti se non tutto ti sarà chiaro fin da subito. Imparare il tuo primo linguaggio di programmazione è difficile ma da qualche parte bisogna pure iniziare. Pronto per le tue prime linee di codice? Let’s become a useR! 3.1 Operatori Matematici R è un’ottima calcolatrice. Nella Tabella 3.1 sono elencati i principali operatori matematici e funzioni usate in R. Table 3.1: Operatori Matematici Funzione Nome Esempio x + y Addizione &gt; 5 + 3 [1] 8 x - y Sottrazione &gt; 7 - 2 [1] 5 x * y Moltiplicazione &gt; 4 * 3 [1] 12 x / y Divisione &gt; 8 / 3 [1] 2.666667 x %% y Resto della divisione &gt; 7 %% 5 [1] 2 x %/% y Divisione intera &gt; 7 %/% 5 [1] 1 x ^ y Potenza &gt; 3 ^ 3 [1] 27 abs(x) Valore assoluto &gt; abs(3-5^2) [1] 22 sign(x) Segno di un’espressione &gt; sign(-8) [1] -1 sqrt(x) Radice quadrata &gt; sqrt(25) [1] 5 log(x) Logaritmo naturale &gt; log(10) [1] 2.302585 exp(x) Esponenziale &gt; exp(1) [1] 2.718282 sin(x)cos(x)tan(x)asin(x)acos(x)atan(x) Funzioni trigonometriche &gt;sin(pi/2) [1]1 &gt;cos(pi/2) [1]6.123234e-17 factorial(x) Fattoriale &gt; factorial(6) [1] 720 choose(n, k) Coefficiente binomiale &gt; choose(5,3) [1] 10 Nota come per svolgere operazioni come la radice quadrata o il valore assoluto vengono utlizzate delle specifiche funzioni. In R le funzioni sono richiamate digitando &lt;nome-funnzione&gt;() (e.g., sqrt(25)) indicando all’interno delle parentesi tonde gli argomenti della funzione. Approfondiremo le funzioni nel Capitolo 4.2. 3.1.1 Ordine Operazioni Nello svolgere le operazioni, R segue lo stesso l’ordine usato nelle normali espressioni matematiche. Quindi l’ordine di precedenza degli operatori è: ^ (potenza) %% (resto della divisione) e %/% (divisione intera) * (moltiplicazione) e /(divisione) + (addizione) e -(sotttrazione) Nota che in presenza di funzioni (e.g., abs(), sin()), R per prima cosa sostituisca le funzioni con il loro risultato per poi procedere con l’esecuzione delle operazioni nell’ordine indicato precedentemente. L’ordine di esecuzione delle operazioni può essere controllato attraverso l’uso delle parentesi tondone (). R eseguirà tutte le operazioni incluse nelle parentesi seguendo lo stesso ordine inndicato sopra. Utilizzando più gruppi di parentesi possiamo ottenere i risultati desiderati. Nota che in R solo le parentesi tonde () sono utilizzate per gestire l’ordine con cui sono eseguite le oprazioni. Parentesi quadre [] e parentesi graffe {} sono invece speciali operatori utilizzati in R per altre ragioni come la selezione di elemente e la definizione di blocchi di codici. Argomenti che approfondiremo rispettivamente nel Capitolo TODO e Capitolo TODO. Esercizi Calcola il risultato delle seguenti operazioni utilizzando R (soluzioni): \\(\\frac{(45+21)^3+\\frac{3}{4}}{\\sqrt{32-\\frac{12}{17}}}\\) \\(\\frac{\\sqrt{7-\\pi}}{3\\ (45-34)}\\) \\(\\sqrt[3]{12-e^2}+\\ln(10\\pi)\\) \\(\\frac{\\sin(\\frac{3}{4}\\pi)^2+\\cos(\\frac{3}{2}\\pi)}{\\log_7{e^{\\frac{3}{2}}}}\\) \\(\\frac{\\sum_{n=1}^{10} n}{10}\\) Note per la risoluzione degli esercizi: In R la radice quadrata si ottine con la funzione sqrt() mentre per radici di indici diversi si utilizza la notazione esponenziale (\\(\\sqrt[3]{x}\\) è dato da x^(1/3)). Il valore di \\(\\pi\\) si ottiene con pi. Il valore di \\(e\\) si ottiene con exp(1). In R per i logaritmi si usa la funzione log(x, base=a), di base viene considerato il logaritmo naturale. 3.2 Operatori Relazionali e Logici Queste operazioni al momento potrebbero sembrare non particolrmente interessanti ma si riveleranno molto utili nei capitoli successivi ad esempio per la selezione di elementi (vedi Capitolo TODO) o la definizionne di algoritmi (vedi Capitolo TODO). 3.2.1 Operatori Relazionali In R è possibile valutare se una data relazione è vera o fasa. Ad esempio, posiamo valutare se “2 è minore di 10” o se “4 numero è un numero pari”. R valuterà le proposizioni e ci restituirà il valore TRUE se la proposizione è vera oppure FALSE se la proposizione è falsa. Nella Tabella 3.2 sono elencati gli operatori relazionali. Table 3.2: Operatori Relazionali Funzione Nome Esempio x == y Uguale &gt; 5 == 3 [1] FALSE x != y Diverso &gt; 7 != 2 [1] TRUE x &gt; y Maggiore &gt; 4 &gt; 3 [1] TRUE x &gt;= y Maggiore o uguale &gt; -2 &gt;= 3 [1] FALSE x &lt; y Minore &gt; 7 &lt; 5 [1] FALSE x &lt;= y Minore o uguale &gt; 7 &lt;= 7 [1] TRUE x %in% y inclusione &gt; 5 %in% c(3, 5, 8) [1] TRUE Attenzione che per valutare l’uguaglianza tra due valori non bisogna utilizzare = ma ==. Questo è un’errore molto comune ceh si commmette in continuazione. L’operatore = è utilizzato in R per assegnare un valore ad una variablie. Argomento che vederemo nella Sezione TODO Nota che in qualsiasi linguaggio di Programmazione, ai valori TRUE e FALSE sono associati rispettivament i valori numerici 1 e 0. Questi sono definiti valori booleani. TRUE == 1 # TRUE TRUE == 2 # FALSE TRUE == 0 # FALSE FALSE == 0 # TRUE FALSE == 1 # FALSE In R è possibile anche abbreviare TRUE e FALSE rispettivamente in T e F, sebbene sia una pratica non consigliata poichè potrebbe nonn essere chiara e creare fraintendimenti. Infatti mentre TRUE e FALSE sono parole riservate (vedi Capitolo TODO) T a F non lo sono. T == 1 # TRUE T == TRUE # TRUE F == 0 # TRUE F == FALSE # TRUE 3.2.2 Operatori Logici In R è possibile congiungere più relazioni per valutare una desiderata proposizione. Ad esempio potremmo valutare se “17 è maggiore di 10 e minore di 20”. Per unire più relazioni in un’unica proposizione che R valuterà come TRUE o FALSE, vengono utilizati gli operatori logici riportati in Tabella 3.3. Table 3.3: Operatori Logici Funzione Nome Esempio !x Negazione &gt; !TRUE [1] FALSE x &amp; y Congiunzione &gt; TRUE &amp; FALSE [1] FALSE x | y Disgiunzione Inclusiva &gt; TRUE | FALSE [1] TRUE Questi operatori sono anche definiti operatori booleani e seguono le comuni definizioni degli operatori logici. In particolare abbiamo che: Nel caso della congiunzione logica &amp;, affinchè la proposizione sia vera è necessario che entrambe le relazioni siano vere. Negli altri casi la proposizione sarà valutarta falsa (vedi Tabella 3.4). Table 3.4: Congiunzione ‘&amp;’ x y x &amp; y TRUE TRUE TRUE TRUE FALSE FALSE FALSE TRUE FALSE FALSE FALSE FALSE Nel caso della disgiunzione inclusiva logica |, affinchè la proposizione sia vera è necessario che almeno una relaziona sia vera. La proposizione sarà valutarta falsa solo quando entrambe le relazioni sono false (vedi Tabella 3.5). Table 3.5: Disgiunzione inclusiva ‘|’ x y x | y TRUE TRUE TRUE TRUE FALSE TRUE FALSE TRUE TRUE FALSE FALSE FALSE Per completezza ricordiamo che tra gli operatori logici esiste anche la disgiunzione esclusiva. La proposizione sarà valutata falsa se entrambe le relazioni sono vere oppure false. Affinchè la proposizione sia valutata vera una sola delle relazioni deve essere vera mentre l’altra deve essere falsa. In R la disgiunzione esclusiva tra due ralazioni (x e y) è indicata con la funzione xor(x, y). Tuttavia tale funzione è raramente usata. Disgiunzione esclusiva ‘xor(x, y)’ x y xor(x, y) TRUE TRUE FALSE TRUE FALSE TRUE FALSE TRUE TRUE FALSE FALSE FALSE 3.2.3 Ordine valutazione relazioni Nel valutare le veridicità delle proposizioni R esegue le operazioni nel seguente ordine: operatori matematici (e.g., ^, *, /, +, -, etc.) operatori relazionali (e.g., &lt;, &gt;, &lt;=, &gt;=, ==, !=) operatori logici (e.g., !, &amp;, |) La lista completa dell’ordine di esecuzione delle operazioni è riportata al seguente link https://stat.ethz.ch/R-manual/R-devel/library/base/html/Syntax.html. Ricordiamo che, in caso di dubbi riguardanti l’ordine di esecuzione delle operazioni, la cosa migliore è utilizzare le parentesi tonde () per disambiguare ogni possibile fraintendimento. Nota che l’operatore %in% che abbiamo precedentemente indicato tra gli operatori relazionali in realtà è un operatore speciale. In particolare, non segue le stesse regole degli altri operatori relazionlali per quanto riguarda l’ordine di esecuzione. La soluzione migliore? Usa le parentesi! Esercizi Esegui i seguenti esercizi utilizzando gli operatori relazionali e logici (soluzioni): Definisici due relazioni false e due vere che ti permettano di valutare i risultati di tutti i possibili incroci che puoi ottenere con gli operatori logici &amp; e |. Definisci una proposizione che ti permetta di valutare se un numero è pari. Definisci un’altra proposizione per i nueri dispari (tip: cosa ti ricorda %%?). Definisci una proposizione per valutare la seguente condizione (ricordati di testare tutti i possibili scenari) “x è un numero compreso tra -4 e -2 oppure è un numero compreso tra 2 e 4”. Esegui le seguenti operazioni 4 ^ 3 %in% c(2,3,4) e 4 * 3 %in% c(2,3,4). Cosa osservi nell’ordine di esecuzione degli operatori? "],["objects-functions.html", "Capitolo 4 Due Compagni Inseparabili 4.1 Oggetti 4.2 Funzioni", " Capitolo 4 Due Compagni Inseparabili In questo capitolo introdurremmo i concetti di oggetti e funzioni, due elementi alla base di R (e di ogni linguaggio di programmazione). Potremmo pensare agli oggetti in R come a delle variabili che ci permettono di mantenere in memoria dei valori (e.g., i risultati dei nostri calcoli o i nostri dati). Le funzioni in R, invece, sono analoghe a delle funzioni matematiche che, ricevuti degli oggetti in input, compiono delle azioni e restituiscono dei nuovi oggetti in output. Questa è una iper-semplificazione (e pure tecnicamente non corretta) che ci permettere però di capire come, partendo dai nostri dati o valori iniziali, possiamo manipolarli applicando delle funzioni per ottenere, attraverso differenti step, i risultati desiderati (e.g., analisi statistiche o grafici e tabelle). Qui valuteremo gli aspetti fondamentali riguardanti l’utilizzo degli oggetti e delle funzioni che saranno successivamente approfonditi rispettivamente nel corso della seconda e della terza sezione del libro (TODO). 4.1 Oggetti Quando eseguiamo un commando in R, il risultato ottenuto viene immediatamente mostrato in Console. Tale risultato, tuttavia, non viene salvato in memoria e quindi non potrà essere riutilizzato in nessuna operazione futura. Condurre delle analisi in questo modo sarebbe estremamente complicato ed inefficiente. La soluzione più ovvia è quella di salvare in memoria i nostri risultati intermedi per poterli poi riutilizzare nel corso delle nostre analisi. Si definisce questo processo come assegnare un valore ad un oggetto. 4.1.1 Assegnare e Richiamare un oggetto Per assegnare il valore numerico 5 all’oggetto x è necessario eseguire il seguente comando: x &lt;- 5 La funzione &lt;- ci permette di assegnare i valori che si trovano alla sua destra all’oggetto il cui nome è definito alla sinistra. Abbiamo pertanto il seguente pattern: &lt;nome-oggetto&gt; &lt;- &lt;valore-assegnato&gt;.Notate come in Console appaia solo il comando appena eseguito ma non venga mostrato alcun risultato. Per utilizzare il valore contenuto nell’oggetto sarà ora sufficiente richiamare nel proprio codice il nome dell’oggetto desiderato. x + 3 ## [1] 8 E’ inoltre possibile “aggiornare” o “sostituire” il valore contenuto in un oggetto. Ad esempio: # Aggiornare un valore x &lt;- x*10 x ## [1] 50 # Sostituire un valore x &lt;- &quot;Hello World!&quot; x ## [1] &quot;Hello World!&quot; Nel primo caso, abbiamo utilizzato il vecchio valore contenuto in x per calcolare il nuovo risultato che è stato assegnato a x. Nel secondo caso, abbiamo sostituito il vecchio valore di x con un nuovo valore (nell’esempio una stringa di caratteri). Esistono due operatori principali che sono usati per assegnare un valore ad un oggetto: l’operatore &lt;- e l’operatore =. Entrambi sono validi e spesso la scelta tra i due diventa solo una questione di stile personale. x_1 &lt;- 45 x_2 = 45 x_1 == x_2 ## [1] TRUE Esistono, tuttavia, alcune buone ragioni per preferire l’uso di &lt;- rispetto a = (attenti a non confonderlo con l’operatore relazionale ==). L’operazione di assegnazione è un’operazione che implica una direzionalità, il chè è reso esplicito dal simbolo &lt;- mentre il simbolo = non evidenzia questo aspetto e anzi richiama la relazione di uguaglianza in matematica. La decisione su quale operatore adottare è comunque libera, ma ricorda che una buona norma nella programmazione riguarda la consistenza: una volta presa una decisione è bene mantenerla per facilitare la comprensione del codice. 4.1.2 Nomi degli oggetti La scelta dei nomi degli oggetti sembra un aspetto secondario ma invece ha una grande importanza per facilitare la chiarezza e la comprensione dei codici. Ci sono alcune regole che discriminano nomi validi da nomi non validi. Il nome di un oggetto: deve iniziare con una lettera e può contenere lettere, numeri, underscore (_), o punti (.). potrebbe anche iniziare con un punto (.) ma in tal caso non può essere seguito da un numero. non deve contenere caratteri speciali come #, &amp;, $, ?, etc. non deve essere una parola riservata ovvero quelle parole che sono utilizzate da R con un significato speciale (e.g, TRUE, FALSE, etc.; esegui il comando ?reserved per la lista di tutte le parole riservate in R). Nota come R sia Case-Sensitive, ovvero distingua tra lettere minuscole e maiuscole. Nel seguente esempio i due nomi sono considerate diversi e pertanto non avviene una sovrascrizione ma due differenti oggetti sono creati: My_name &lt;- &quot;Monty&quot; my_name &lt;- &quot;Python&quot; My_name ## [1] &quot;Monty&quot; my_name ## [1] &quot;Python&quot; Inoltre, il nome ideale di un oggetto dovrebbe essere: auto-descrittivo: dal solo nome dovrebbe essere possibile intuire il contenuto dell’oggetto. Un nome generico quale x o y ci sarebbero di poco aiuto poichè potrebbero contenere qualsiasi informazione. Invece un nome come weight o gender ci suggerirebbe chiaramente il contenuto dell’oggetto (e.g., il peso o il gender dei partecipanti del nostro studio). della giusta lunghezza: non deve essere ne troppo breve (evitare sigle incomprensibili) ma neppure troppo lunghi. La lunghezza corretta è quella che permette al nome di esssere sufficientemente informativo senza aggiungere inutili dettagli. In genere sono sufficienti 2 o 3 parole. Spesso più parole sono usate per ottenere un nome sufficientemente chiaro. Dato che però non è possibile includere spazi in un nome, nasce il problema di come unire più parole senza che il nome diventi incomprensibile, ad esempio mediatestcontrollo. Esistono diverse convenzioni tra cui: CamelCase. L’inizio di una nuova parole viene indicata con l’uso della prima lettera maiuscola. Ad esempio mediaTestControllo. snake_case. L’inizio di una nuova parola viene indicata con l’uso carattere _. Ad esempio media_test_controllo. una variante al calssico snake_case riguarda l’uso del ., ad esempio media.test.controllo. Questo approccio in genere è evitato poichè in molti linguaggi di progtrammazione (ed anche in R in alcune condizioni) il carattere . è un carattere speciale. In genere viene raccomandato di seguire la convenzione snake_case. Tuttavia, la decisione su quale convenzione adottare è libera, ma ricorda ancora che una buona norma nella programmazione riguarda la consistenza: una volta presa una decisione è bene mantenerla per facilitare la comprensione del codice. 4.1.3 Tipologie Dati e Strutture Dati Per lavorare in modo ottimale in R, è fondamentale conoscere bene e distinuere chiaramente quali sono le tipologie di dati e le strutture degli oggetti usati. In R abbiamo 4 principali tipologie di dati, ovvero tipologie di valori che possono essere utilizzati: character - Stringhe di caratteri i cui valori alfannumerici vengono delimitati dalle doppie vigolette \"Hello world!\" o virgolette singole 'Hello world!'. double - Valori numerici con o senza cifre decimali ad esempio 27 o 93.46. integer - Valori interi definiti apponendo la lettera L al numero desiderato, ad esempio 58L. logical - Valori logici TRUE e FALSE usati nelle operazioni logiche. typeof(&quot;Psicostat&quot;) ## [1] &quot;character&quot; typeof(24.04) ## [1] &quot;double&quot; typeof(1993L) ## [1] &quot;integer&quot; typeof(TRUE) ## [1] &quot;logical&quot; In R abbiamo inoltre differenti tipologie di oggetti, ovvero diverse strutture in cui possono essere organizzati i dati: Vettori Matrici Dataframe Liste Approfondiremo la loro definizione, le loro caratteristiche ed il loro utilizzo nel corso di tutta la seconda sezione di questo libro TODO. 4.2 Funzioni Possiamo pensare alle funzioni in R in modo analogo alle classiche funzioni matematiche. Dati dei valori in input, le funzioni eseguono dei specifici calcoli e restituiscono in output il risultato ottenuto. Abbiamo già incontrato le nostre prime funzioni per eseguire specifiche operazioni matematiche nel Capitolo 3.1 come ad esempio sqrt() o abs() usate per ottenere ripettivamente la radice quadrata o il valore assoluto di un numero. Ovviamente le funzioni in R non sono limitate ai soli calcoli matematici ma possono eseguire qualsiasi genere di compito come ad esempio creare grafici e tabelle o manipolare dei dati o dei file. Tuttavia il concetto rimane lo stesso: ricevuti degli oggetti in input, le funzioni compiono determinate azioni e restituiscono dei nuovi oggetti in output. In realtà incontreremo delle funzioni che non richiedono input o non produrre degli output. Ad esempio getwd() non richiede input oppure la funzione rm() non produce output. Tuttavia questo accade nella minoranza dei casi. Per eseguire una funzione in R è necessario digitare il nome della funzione ed indicare tra parentesi i valori che vogliamo assegnare agli argomenti della funzione, ovvero i nostri input, separati da virgole. Generalmente si utilizza quindi la seguente sintassi: &lt;nome-funzione&gt;(&lt;nome-arg1&gt; = &lt;valore-arg1&gt;, &lt;nome-arg2&gt; = &lt;valore-arg2&gt;,...) Ad esempio per creare una sequenza di valori con incrementi di 1 posso usare la funzione seq(), i cui argomenti sono from e to ed indicano rispettivamente il valore iniziale ed il valore massimo della sequenza. # creo una sequenza di valori da 0 a 10 con incrementi di 1 seq(from = 0, to = 10) ## [1] 0 1 2 3 4 5 6 7 8 9 10 4.2.1 Argomenti di una Funzione Nel definire gli argomenti di una funzione non è necessario specificare il nome degli argomenti. Ad esempio il comando precedente può essere eseguito anche specificando solamente i valori. # creo una sequenza di valori da 0 a 10 con incrementi di 1 seq(0, 10) ## [1] 0 1 2 3 4 5 6 7 8 9 10 Tuttavia, questo rende più difficile la lettura e la comprensione del codice poichè non è chiaro a quali argomenti si riferiscono i valori. L’ordine con cui vengono definiti i valori in questo caso è iportante, poichè R assume rispetti l’ordine prestabilito degli argomenti. Osserva come invertendo invertendo i valori ovviamente otteniamo risultati differenti da quelli precedenti, ma questo non avviene quando il nome dell’argomento è specificato. # inverto i valori senza i nomi degli argomenti seq(10, 0) ## [1] 10 9 8 7 6 5 4 3 2 1 0 # inverto i valori con i nomi degli argomenti seq(to = 10, from = 0) ## [1] 0 1 2 3 4 5 6 7 8 9 10 Vediamo inoltre come le funzioni possano avere molteplici argomenti, ma che non sia necessario specificare il valore per ognuno di essi. Molti argomenti, infatti, hanno già dei valori prestabiliti di default e non richiedo quindi di essere specificati almeno che ovviamente non si vogliano utilizzare impostazioni diverse da quelle di default. Oppure lo specificare un dato argomento rispetto ad un altro può definire il comportamento stesso della funzione. Ad esempio la funzione seq() possiede anche gli argomenti by e length.out che prima non erano stati specificati. by permette di definire l’incremento per ogni elemento successivo della sequenza mentre length.out permette di definire il numero di elementi della sequenza. Vediamo come allo specificare dell’uno o dell’altro agromento (o di entrambi) il comportamento della funzione vari. seq(from = 0, to = 10, by = 5) ## [1] 0 5 10 seq(from = 0, to = 10, length.out = 5) ## [1] 0.0 2.5 5.0 7.5 10.0 seq(from = 0, to = 10, length.out = 5, by = 4) ## Error in seq.default(from = 0, to = 10, length.out = 5, by = 4): too many arguments E’ pertanto cosigliabile esplicitare sempre gli argomenti di una funzione per rendere chiaro a che cosa si riferiscono i valori indicati. Questo è utlile anche per evitare eventuali comportamenti non voluti delle funzioni ad individuare più facilmente possibili errori. Gli argomenti di una funzione, inoltre, richiedono specifiche tipologie e strutture di dati e sta a noi assicuraci che i dati siano forniti nel modo corretto. Vediamo ad esempio come la funzione mean() che calcola la media di un insieme di valori, richieda come input un vettore di valori numerici. Approfondiremo il concetto di vettori nel Capitolo TODO, al momento ci basta sapere che possiamo usare la funzione c() per combinare più valori in un unico vettore. # Calcolo la media dei seguenti valori (numerici) mean(c(10, 6, 8, 12)) # c() combina più valori in un unico vettore ## [1] 9 mean(10, 6, 8, 12) ## [1] 10 Notiamo come nel primo caso il risultato sia corretto mentre nel secondo è sbagliato. Questo perchè mean() richiede come primo argomento il vettore su cui calcolare la media. Nel primo caso abbiamo correttamente specificato il vettore di valori usando la funzione c(). Nel secondo caso invece, il primo argomento risulta essere solo il valore 10 ed R calcola la media di 10 ovvero 10. Gli altri valori sono passati ad altri argomenti che non alterano il comportameto ma neppure ci segnalano di questo importante errore. Nel seguente esempio, possiamo vedere come mean() richieda che i valori siano numerici. Seppur \"1\" \"2\", e \"3\" siano dei numeri, l’utilizzo delle doppie virgolette li rende delle stringhe di caratteri e non dei valori numerici e giustamente R non può eseguire una media su dei caratteri. # Calcolo la media dei seguenti valori (caratteri) mean(c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)) ## Warning in mean.default(c(&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)): argument is not numeric or logical: ## returning NA ## [1] NA Capiamo quindi che per usare correttamente le funzioni è fondamentale conoscerne gli argomenti e rispettare le tipologie e strutture di dati richieste. 4.2.2 Help! I need Somebody…Help! Conoscere tutte le funzioni e tutti i loro argomenti è impossibile. Per fortuna R ci viene in soccorso fornendoci per ogni funzione la sua documentazione. Qui vengono fornite tutte le informazioni riguardanti la finalità della funzione, la descrizione dei suoi argomenti, i dettagli riguardanti i suoi possibili utilizzi. Per accedere alla documentazione possiamo utilizzare il comando ?&lt;nome-funzione&gt; oppure help(&lt;nome-funzione&gt;). Ad esempio: ?seq help(seq) Una pagina si aprirà nel pannello “Help” in basso a destra con la documentazione della funzione in modo simile a quanto rappresentato in Figura 4.1. Figure 4.1: Help-page della funzione seq() Il formato e le informazioni presenti nella pagina seguono delle norme comuni ma non obbligatorie. Infatti, non necessariamente vengono usati sempre tutti i campi e comunque all’autore delle funzioni è lasciato un certo grado di libertà nel personalizzare la documentazione. Tra i campi principali e più comunemente usati abbiamo: Tiolo - Titolo esplicativo della finalità della funzione Description - Descrizione coincisa della funzione Usage - Viene mostrata la struttura della funzione con i suoi argomenti e valori di default Arguments - Elenco con la descrizione dettagliata di tutti gli argomenti. Qui troviamo per ogni argomento sia le opzioni utilizzabili ed il loro effetto, che la tipologia di valori richiesti Details - Descrizione dettagliata della funzione considerando i casi di utilizzo ed eventuali note tecniche Value - Descrizione dell’output dalla funzione. Qui troviamo sia la descrizione della struttura dei dati dell’output che la descrizione dei suei elementi utile per interpretare ed utilizzare i rsultati ottenuti See Also - Eventuali link ad altre funzioni simili o in relazione con la nostra funzione Examples - Esempi di uso della funzione Ricerca per Parola Quando non si conosce esattamente il nome di una funzione o si vuole cercare tutte le funzioni e pagine che includono una certa parola, è possibile utilizzare il comando ??&lt;parola&gt; oppure help.search(&lt;parola&gt;). R eseguirà una ricerca tra tutta la documentazione disponibile è fornirà un elenco delle pagine che contengono la parola desiderata nel titolo o tra le keywords. La natura dei programmatori è essere pigri e smemorati. Per fortuna ogni code editor che si rispetti (i.e., programma per la scrittura di codici) possiede delle utli funzioni di autocompletamento e suggerimento dei comandi che semplificano la scrittura di codici. In Rstudio, i suggerimenti compaino automaticamente durante la scrittura di un comando oppure possono essere richiamati premendo il tasto Tab in alto a sinistra della tastiera ( ). Comparirà una finestra con possibili soluzioni di autocompletamento del nome della funzione. Utilizzando le frecce della tastiera possiamo evidenziare lq funzione voluta e premere Invio per autocompletare il comando. Nota come accanto al nome della funzione appare anche un piccolo riquadro giallo con la descrizione della funzione. Per inserire gli argomenti della funzione possiamo fare affidamento nuovamente ai suggerimenti e alla funzione di autocompletamento. Sarà sufficiente premere nuovamente il tasto Tab e questa volta comparirà una lista degli argomenti con la relativa descrizione. Sarà quindi sufficiente selezionare con le frecce l’argomento desiderato e premere Invio. Notate come la funzione di autocompletamento non sia utilizzata solo per le funzioni ma anche per i nomi degli oggetti. Questo ci consentirà di richiamare velocemente oggetti precedentemente creati evitando di digitare l’intero nome. "],["working-environment.html", "Capitolo 5 Ambiente di Lavoro 5.1 Environment 5.2 Working Directory 5.3 R-packages", " Capitolo 5 Ambiente di Lavoro In queso capitolo introdurremo alcuni concetti molto importanti che riguardano l’ambiente di lavoro in R o RStudio. In particolare parleremo dell’environment, della working directory e dell’utilizzo dei pacchetti. 5.1 Environment Nel Capitolo 4.1, abbiamo visto come sia possibile assegnare dei valori a degli oggetti. Questi oggetti vengono creati nel nostro ambiente di lavoro (o meglio Environment) e potranno essere utilizzati in seguito. Il nostro Enviroment raccoglie quindi tutti gli oggetti che vengono creati durante la nostra sessione di lavoro. E’ possibile valutare gli oggetti attualmente presenti osservando il pannello Environment in alto a destra (vedi Figura 5.1) oppure utilizzadno il comando ls(), ovvero list objects. Figure 5.1: Environment - Elenco degli oggetti e variabili presenti nel’ambiente di lavoro All’inizio della sessione di lavoro il nostro Environment sarà vuoto (vedi Figura 5.2). Il comando ls() non restituirà alcun oggeto ma per indicare l’assenza di oggerri userà la risposta character(0), ovvero un vettore di tipo caratteri di lunghezza zero (vedi Capitolo TODO). Figure 5.2: Environment vuoto ad inizio sessione di lavoro # Environment vuoto ls() ## character(0) 5.1.1 Aggiungere Oggetti all’Environment Una volta creati degli oggetti, questi saranno presenti nel nostro Environment e il comando ls() restituirà un vettore di caretteri in cui vengono elencati tutti i loro nomi. # Creo oggetti x &lt;- c(2,4,6,8) y &lt;- 27 word &lt;- &quot;Hello Word!&quot; # Lista nomi oggetti nell&#39;Environment ls() ## [1] &quot;word&quot; &quot;x&quot; &quot;y&quot; Nel pannello in alto a destra (vedi Figura 5.3), possiamo trovare un elenco degli oggetti attualmente presenti nel nostro Environment. Insieme al nome vengono riportate anche alcune utili inforamzioni a seconda del tipo di oggetto. Vediamo come nel nostro esempio, nel caso di variabili con un singolo valore (e.g., word e y) venganno presentati direttamente gli stessi valori. Mentre, nel caso di vettori (e.g., x) vengano fornite anche informazioni riguardanti la tipologia di vettore e la sua dimensione (vedi Capitolo TODO), nell’esempio abbiimao un vettore numerico (num) di 4 elementi ([1:4]). Figure 5.3: Environment contenente gli oggetti creati 5.1.2 Rimuovere Oggetti dall’Environment Per rimuovere un oggetto dal proprio environment è possibile utilizzare il comando remove() oppure la sua abbreviazione rm(), indicando tra parentesi il nome dell’oggetto che si intende rimuovere. E’ possibile indicare più di un oggetto separando i loro nomi con la virgola. # Rimuovo un oggetto rm(word) ls() ## [1] &quot;x&quot; &quot;y&quot; # Rimuovo più oggetti contemporaneamente rm(x,y) ls() ## character(0) Qualora fosse necessario eliminare tutti gli oggetti attualmete presenti nel nosto ambiente di lavoro è possibile ricorrere alla formula rm(list=ls()). In questo modo si avrà la certezza di pulire l’ambiente da ogni oggetto e di ripristinarlo alle condizioni iniziali della sessione. Avere cura di mantenre il proprio Environment ordinato ed essere consapevoli degli oggetti attualmente presenti è importante. Questo ci permette di evitare di compiere due errori comuni. Utilizzare oggetti non ancora creati. In questo caso l’errore è facilemente individuabile dat che sarà lo stesso R ad avvisarci che “object ‘’ not found”. In questo caso dovremmo semplicemente eseguire il comando per creare l’oggetto richieto. oggetto_non_esistente ## Error in eval(expr, envir, enclos): object &#39;oggetto_non_esistente&#39; not found Utilizzare oggetti con “vecchi” valori. Se non si ha cura di mantenere ordinato il proprio ambiente di lavoro potrebbe accadere che diversi oggetti vengano creati durante successive sessioni di lavoro. A questo punto si corre il rischio di perdere il controllo rispetto al vero contenuto degli oggetti e potremmo quindi utilizzare degli oggetti pensando che contengano un certo valore, quando invece si riferisono a tutt’altro. Questo comporta che qualsiasi nostro risultato perda di significato. Bisogna prestare molta attenzione perchè R non potrà avvisarci di questo errore (per lui sono solo numeri), siamo noi che dobbiamo essere consapevoli del fatto che i comandi eseguiti abbiano senso oppure no. Per mantere un Environmet ordinato vi consigliamo innanzitutto di non salvare automaticamente il vostro workspace quando terminate una sessione di lavoro. E’ possibile settare tale opzione nelle impostazioni generali di R selezionando “Never” alla voce “save workspace to .RData on exit” come riportato nella Figura seguente. Questo vi permetterà di iniziare ogni nuova sessione di lavoro in un Environment vuoto, evitando che vecchi oggetti si accumulino nel corso delle diverse sesssioni di lavoro. Durante le vostre sessioni, inoltre, sarà utile eseguire il comando rm(list=ls()) quando inizierete un nuovo compito in modo da eliminare tutti i vecchi oggetti. Environment una Memoria a Breve Termine Notiamo quindi come l’Environment sia qualcosa di transitorio. Gli oggetti vengono salvati nella memoria primaria del computer (RAM, possiamo pensarla in modo analogo alla memoria a breve termine dei modelli cognitivi) e verranno cancellati al comando rm(list=ls()) o al termine di ogni sessione di lavoro. Il fatto di partire ogni volta da un Environment vuoto, vi costringerà a raccogliere tutti i passi delle vostre analisi all’interno di uno script in modo ordinato evitando di fare affidamento su vecchi oggetti. Tutti gli oggetti necessari durante le analisi, infattii, dovranno essere ricreati ad ogni sessione, garantendo la riproducibilità e correttezza del lavro (almeno dal punto di vista di programmazione). Idealmente dovrebbe essere posibile, in una sessione di lavoro, partire da un Environment vuoto ed eseguire in ordine tutti i comandi contenuti in uno script fino ad ottenere i risultati desiderati. E’ facile intuire come in certe situazioni questa non sia la soluzione più efficiente. Alcuni comandi, infatti, potrebbero richiedere molti minuti (o anche giorni) per essere eseguiti. In questi casi sarebbe conveniente, pertanto, salvare i risultati ottenuti per poterli utilizzare anche in sessioni successive, senza la necessità di dover eseguire nuovamente tutti i comadi. Vedremo nel Capitolo TODO come sarà possibile salvare permanentemente gli oggetti creati nella memoria secondaria del computer (hard-disk, nella nostra analogia la memoria a lungo termine) e come caricarli in una successiva sessione di lavoro. 5.2 Working Directory Il concetto di working directory è molto importante ma spesso poco conosciuto. La working directory è la posizione all’interno del computer in cui ci troviamo durante la nostra sessione di lavoro e da cui eseguiamo i nostri comandi. 5.2.1 Organizzazione Computer L’idea intuitiva che abbiamo comunemente del funzionamento del computer è fuorviante. Spesso si pensa che il Desktop rispecchi l’organizzazione del nostro intero computer e che tutte le azioni siano gestite attraverso l’interfaccia punta-e-clicca a cui ormai siamo abituati dai moderni sistemi operativi. Senza entrare nel dettaglio, è più corretto pensare all’organizzazione del cumputer come ad un insieme di cartelle e sottocartelle che contengono tutti i nostri file e al funzionamento del computer come ad un insieme di processi (o comandi) che vengono eseguiti. Gli stessi programmi che installiamo non sono altro che delle cartelle in cui sono contenuti tutti gli script che determinano il loro funzionamento. Anche il Desktop non è altro che una semplice cartella mentre quello che vediamo noi è un programma definito dal sistema operativo che visualizza il contenuto di quella cartella sul nostro schermo e ci permette di interfacciarci con il mouse. Tutto quello che è presente nel nostro computer, compresi i nostri file, i programmi e lo stesso sistema operativo in uso, tutto è organizzato in un articolato sistema di cartelle e sottocartelle. Approsimativamente possiamo pensare all’organizzazione del nostro computer in modo simile alla Figura 5.4 (da: https://en.wikipedia.org/wiki/Operating_system). Figure 5.4: Organizzazione Computer (da Wikipedia vedi link nel testo) Ai livelli più bassi troviamo tutti i file di sistema ai quali gli utenti possono accedere solo con speciali autorizzazioni. Al livello superiore troviamo tutte i file riguardanti i programmi e applicazioni installati che in genere sono utilizzabili da più utenti sullo stesso computer. Infine troviamo tutte le cartelle e file che riguardano lo specifico utente. 5.2.2 Absolute Path e Relative Path Questo ampio preambolo riguardante l’organizzazione in cartelle e sottocartelle, ci serve perchè è la struttura che il computer utilizza per orientarsi tra tutti file quando esegue dei comandi attraverso un’interfaccia a riga di comando (e.g., R). Se vogliamo ad esempio caricare dei dati da uno specifico file in R devo fornire il path (o indirizzo) corretto che mi indichi esattamente la posizione del file all’interno della struttura di cartelle del computer. Ad esempio, immaginiamo di avere dei dati My-data.Rda salvato nella cartella Introduction2R nel proprio Desktop. Desktop | |- Introduction2R | | | |- Dati | | |- My-data.Rda Per indicare la posizione del File potrei utilizzare un: absolute path - la posizione “assoluta” del file rispetto alla root directory del sistema ovvero la cartella principale dell’intero computer. # Mac &quot;/Users/&lt;username&gt;/Desktop/Introduction2R/Dati/My-data.Rda&quot; # Windows Vista &quot;c:\\Users\\&lt;username&gt;\\Desktop\\Introduction2R\\Dati\\My-data.Rda&quot; relative path - la posizione del file rispetto alla nostra attuale posizione nel computer da cui stiamo eseguendo il comando, ovvero rispetto alla working directory della nostra sessione di lavoro. In questo riprendendo il precedente esempio se la nostra working directory fosse la cartella Desktop/Introduction2R avremmo i seguenti relative path: # Mac &quot;Dati/My-data.Rda&quot; # Windows Vista &quot;Dati\\My-data.Rda&quot; Nota come sia preferibile l’utilizzo dei relative path poichè gli absolute path sono unici per il singolo computer di riferimento e non possono essere quindi utilizzati su altri computer. Qualora si utilizzasse un relative path per indicare la posizione di un file, è importante che la working directory attualment in uso sia effettivamente quella prevista. Se ci trovassimo in una divesa cartella, ovviamente il “relative path” indicato non sarebbe più valido e R ci mostrerebbe un messaggio di errore. Riprendendo l’esempio precedente, supponiamo che la nostra attuale working directory sia Desktop invece di Desktop/Introduction2R. Eseguendo il comadno load() per caricare i dati utilizzando il relative path ora non più valido ottengo: load(&quot;Dati/My-data.Rda&quot;) ## Warning in readChar(con, 5L, useBytes = TRUE): cannot open compressed file ## &#39;Dati/My-data.Rda&#39;, probable reason &#39;No such file or directory&#39; ## Error in readChar(con, 5L, useBytes = TRUE): cannot open the connection Il messaggio di errore mi indica che R non è stato in grado di trovare il file seguendo le mie indicazioni. E’ come se chiedessi al computer di aprire il frigo ma attualmente si trovasse in camera, devo prima dargli le indicazioni per raggiungere la cucina altrimenti mi risponderebbe “frigo non trovato”. Risulta pertanto fondamentale essere sempre consapevoli di quale sia l’attuale working directory in cui si sta svolgendo la sessione di lavoro. Ovviamente otterrei lo stesso errore anche usando un absolute path se questo contenesse degli errori. Come avrai notato dagli esempi precedenti, sia la struttura in cui vengono organizzati i file nel computer sia la sintassi utilizzata per indicare i path è differente in base al sistema operativo utilizzato. Mac OS e Linux Il carattere utilizzato per separare le cartelle nella definizione del path è \"/\": &quot;Introduction2R/Dati/My-data.Rda&quot; La root-directory viene indicata iniziando il path con il carattere \"/\": &quot;/Users/&lt;username&gt;/Desktop/Introduction2R/Dati/My-data.Rda&quot; La cartella home dell’utente (ovvero /Users/&lt;username&gt;/) viene indicata iniziando il path con il carattere \"~\": &quot;~/Desktop/Introduction2R/Dati/My-data.Rda&quot; Windows Il carattere utilizzato per separare le cartelle nella definizione del path è \"\\\": &quot;Introduction2R\\Dati\\My-data.Rda&quot; La root-directory viene indicata con \"c:\\\": &quot;c:\\Users\\&lt;username&gt;\\Desktop\\Introduction2R\\Dati\\My-data.Rda&quot; 5.2.3 Working Directory in R Vediamo ora i comandi utilizzati in R per valutare e cambiare la working directory nella propria sessione di lavoro. Nota negli esempi successivi, come in R il caratere \"/\" sia sempre utilizzato per separare le cartelle nella definizione del path indipendentemente dal sistema operativo. Attuale Working Directory In R è possibile valutare l’attuale working directory utilizzando il comando getwd() che restituirà l’absolute path dell’attuale posizione. getwd() ## [1] &quot;/Users/&lt;username&gt;/Desktop/Introduction2R&quot; In alternativa, l’attuale working directory è anche riportata in alto a sinistra della Console come mostrato in Figura 5.5. Figure 5.5: Workig directory dell’attuale sessione di lavoro Premendo la freccia al suo fianco il pannello Files in basso a destra sarà reindirizzato direttamento alla workig directory dell’attuale sessione di lavoro. In questo modo sarà facile navigare tra i file e cartelle presenti al suo interno (vedi Figura 5.6). Figure 5.6: Workig directory dell’attuale sessione di lavoro Cambiare Working Directory Per cambiare la working directory è possibile utilizzare il comando setwd() indicando il path (absolute o relative) della nuova working directory. Nota come, nel caso in cui venga indicato un relative path, questo dovrà indicare la posizione della nuova working directory rispetto alla vecchia working directory. getwd() ## [1] &quot;/Users/&lt;username&gt;/Desktop/Introduction2R&quot; setwd(&quot;Dati/&quot;) getwd() ## [1] &quot;/Users/&lt;username&gt;/Desktop/Introduction2R/Dati&quot; In alternativa è possibile selezionare l’opzione “Choose Directory” dal menù “Session” &gt; “Set Working Directory” come mostrato in Figura 5.7. Verrà quindi richiesto di selezionare la working directory desiderata e preme “Open”. Figure 5.7: Definire la working directory Nota come sia possibile nel digitare il path sfruttare l’autocompletamento. All’interno delle virgolette \"\" premi il tasto Tab per visualizzare i suggerimenti dei path relativi alla attuale working directory. E’ possibile inoltre utilizzare i caratteri speciali \"./\" e \"../\" per indicare rispettivamente l’attuale working directory e la cartella del livello superiore (i.e., parent folder) che include l’attuale working directory. \"../\" ci permette quindi di navigare a ritroso dalla nostra attuale posizione tra le cartelle del computer. getwd() ## [1] &quot;/Users/&lt;username&gt;/Desktop/Introduction2R&quot; setwd(&quot;../&quot;) getwd() ## [1] &quot;/Users/&lt;username&gt;/Desktop/&quot; 5.3 R-packages Uno dei grandi punti di forza di R è quella di poter estendere le proprie funzioni di base in modo semplice ed intuitivo utilizzando nuovi pacchetti. Al momento esistono oltre 17’000 pachetti disponibili gratuitamente sul CRAN (la repository ufficiale di R). Questi pacchetti sono stati sviluppati dall’immensa comunity di R per svolgere ogni sorta di compito. Si potrebbe dire quindi che in R ogni cosa sia possibile, basta trovare il giusto pacchetto (oppure crearlo!). Quando abbiamo installato R in automatico sono stati installati una serie di pacchetti che costituiscono la system library, ovvero tutti quei pacchetti di base che permettono il fuzionamento di R. Tuttavia, gli altri pacchetti non sono disponibili da subito. Per utilizzare le funzioni di altri pacchetti, è necessario seguire una procedura in due step come rappresentato in Figura 5.8: Scaricare ed installare i pacchetti sul nostro computer. I pacchetti sono disponibili gratuitamente online nella reopsitory del CRAN, una sorta di archivio. Vengono quindi scaricati ed installati nella nostra library, ovvero la raccolta di tutti i pacchetti di R disponibili sul nostro computer. Caricare il paccheto nella sessione di lavoro. Anche se il paccheto è installato nella nostra library non siamo ancora pronti per utilizzare le sue funzioni. Sarà necessario prima caricare il pacchetto nella nostra sessione di lavoro. Solo ora le funzionni del pacchetto saranno effetivamente disponibili per essere usate. Figure 5.8: Utilizzare i paccheti in R Questo procedimento in due step potrebbe sembrare poco intuitivo. “Perchè dover caricare qualcosa che è già installato?” La risposta è molto semplice ci serve per mantenere efficiente e sotto controllo la nostra sessione di lavoro. Infatti non avremo mai bisogno di tutti i pacchetti installati ma a seconda dei compiti da eseguire utilizzeremo di volta in volta solo alcuni pacchetti specifici. Se tutti i pacchetti fossero caricati automaticamente ogni volta sarebbe un inutile spreco di memoria e si creerebbero facilmente dei conflitti. Ovvero, alcune funzioni di diversi pacchetti potrebbero avere lo stesso nome ma scopi diversi. Sarebbe quindi molto facile ottenere errori o comunque risultati non validi. Vediamo ora come eseguire queste operazioni in R. 5.3.1 install.packages() Per installare dei pacchetti dal CRAN nella nostra library è possibile eseguire il comando install.packages() indicando tra parentesi il nome del pacchetto desiderato. # Un ottimo pacchetto per le analisi statistiche di John Fox # un grandissimo statistico...per gli amici Jonny la volpe ;) install.packages(&quot;car&quot;) In alternativa è possibile utilizzare il pulsante “Install” nella barra in alto a sinistra del pannello Packages ( vedi Figura 5.9), indicando successivamente il nome del pacchetto desiderato. Figure 5.9: Installare paccektti tramite interfacci RStudio Nota come installare un pacchetto potrebbe comportare l’installazione di più pacchetti. Questo perchè verranno automaticamente installate anche le dependencies del pacchetto, ovverro, tutti i pacchetti usati internamente dal pacchetto di interesse che quindi necessari per il suo corretto funzionaemnto (come in un gioco di matrioske). Una volta installato il pacchetto, questo comarirà nella library ovvero la lista dei pacchetti disponibili mostrata nel pannello Packages (vedi Figura 5.10). Figure 5.10: Il pacchetto car è ora disponibile nella library Nell’installare dei pacchetti, potrebbe accadere che R presenti un messaggio simile al seguente: There are binary versions available but the source versions are later: binary source needs_compilation devtools 1.13.4 2.0.1 FALSE [... una lista di vari pacchetti...] Do you want to install from sources the packages which need compilation? In breve, la risposta da dare è NO (\"n\"). Ma che cosa ci sta effetivamente chiedendo R? Esistono diversi modi in cui un pacchetto è disponibile, tra i principali abbiamo: Versione Binary - pronta all’uso e semplice da installare Versione Source - richiede una particolare procedura per essere installata detta compilazione In genere quindi, è sempre preferibile installare la versione Binary. Tuttavia, in questo caso R ci avverte che, per alcuni pacchetti, gli aggiornameni più recenti sono disponibili solo nella versione Source e ci chiede quindi se installarli attraverso la procedura di compilazione. E’ preferibile rispondere “no”, installando così la versione Binary pronta all’uso anche se meno aggiornata. Qualora fosse richiesto obbligatoriamente di installare un pacchetto nella version Source (perchè ci servono gli ultimi aggiornamenti o perchè non disponibile altrimenti) dovremmo avere prima installato R tools (vedi “Approfondimento: R Tools” nel Capitolo 1.1), che ci fornirà gli strumenti necessari per compilare i pacchetti. Per una discussione dettagliata vedi https://community.rstudio.com/t/meaning-of-common-message-when-install-a-package-there-are-binary-versions-available-but-the-source-versions-are-later/2431 e https://r-pkgs.org/package-structure-state.html 5.3.2 library() Per utilizzare le funzioni di un pacchetto già presente nella notra library, dobbiamo ora caricarlo nella nostra sessione di lavoro. Per fare ciò, posssiamo utilizzare il comando library() indicando tra parentesi il nome del pacchetto richiesto. library(car) In alternativa è possibile spuntare il riquadro alla sinistra del nome del pacchetto dal pannello Packages come mostrato in Figura 5.11. Nota tuttavia come questa procedura sia sconsigliata. Infatti, ogni azione punta-e-clicca dovrebbe essere eseguita ad ogni sessione mentre l’utilizzo di comandi inclusi nello script garantisce la loro esecuzione automatica. Figure 5.11: Caricare un pacchetto nella sessione di lavoro Ora siamo finalmente pronti per utilizzare le funzioni del pacchetto nella nostra sessione di lavro. Esiste un piccolo trucco per utilizzare la funzione di uno specifico pacchetto senza dover caricare il pacchetto nella propria sessione. Per fare questo è possibile usare la sintassi: &lt;nome-pacchetto&gt;::&lt;nome-funzione&gt;() # Esempio con la funzione Anova del pacchetto car car::Anova() L’utilizzo dei :: ci permette di richiamare direttamente la funzione desiderata. La differennza tra l’uso di library() e l’uso di :: riguarda aspetti abbastanza avanzati di R (per un approfondimento vedi https://r-pkgs.org/namespace.html). In estrema sintesi, possiamo dire che in alcuni casi è preferibile non caricare un’intero pacchetto se di questo abbiamo bisogno di un’unica funzione. 5.3.3 Aggiornare e Rimuovere Pacchetti Anche i pacchettti come ogni altro software vengono aggiornati nel corso del tempo fornendo nuove funzionalità e risolvendo eventuli problemi. Per aggiornare i pacchetti alla versione più recente è possibile eseguire il comando update.packages() senza inidare nulla tra le parentesi. In alternativa è possibile premere il pulsante “Update” nella barra in alto a sinistra del pannello Packages ( vedi Figura 5.12), indicando successivamente i pachetti che si desidera aggiornare. Nota come nella lista dei pacchetti venga riportata l’attuale versione alla voce “Version”. Figure 5.12: Aggiornare i pacchetti Nel caso in cui si vogli invece rimuover uno specifico pacchetto, è possibile eseguire il comando remove.packages() indicando tra le parentesi il nome del pacchetto. In alternativa è possibile premere il pulsante x alla destra del paccehettto nel pannello Packages come mostrao in Figura 5.13. Figure 5.13: Rimuovere un pacchetto 5.3.4 Documentazione Pacchetti Ogni pacchetto include la documentazione delle proprie funzioni e delle vignette ovvero dei brevi tutorial che mostrano degli esempi di applicazione e utilizzo del pacchetto. Documentazione funzione - Per accedere alla documentazione di una funzione è sufficiente utilizzare il comando ?&lt;nome-funzione&gt; oppure help(&lt;nome-funzione&gt;). Ricorda è necessario avere prima caricato il pacchetto altrimenti la funzione non risulta ancora disponibile. In alternativa si potrebbe estendere la ricerca utilizzando il comando ??. Vignette - Per ottenere la lista di tutte le vignette di un determinato pacchetto è possibile utilizzare il comando browseVignettes(package = &lt;nome-pacchetto&gt;)'. Mentre, per accedere ad una specifica vignetta, si utilizza il comando vignette(\"&lt;name-vignetta&gt;\"). Documentazione intero pacchetto - Premendo il nome del pacchetto dal pannello Packages in basso a destra, è possibile accedere alla lista di tutte le informazioni relative al pacchetto come riportato in Figura 5.14. Vengono prima forniti i link per le vignette ed altri file relativi alle caratteristiche del pacchetto. Successivamente sono presentate in ordine alfabetico tutte le funzioni. Figure 5.14: Documetazione del pacchetto car Ricordate tuttavia che in ogni caso la più grande risorsa di informazioni è come sempre google. Spesso i pacchetti più importanti hanno addirittura un proprio sito in cui raccolgono molto materiale utile. Ma comunque in ogni caso in internet sono sempre disponibili moltissimi tutorial ed esempi. Il CRAN non è l’unica risorsa da cui è possibile installare dei pacchetti di R tuttavia è quella ufficiale e garantisce un certo standard e stabilità dei pacchetti presenti. In internet esistono molte altre repository che raccolgono paccetti di R (e software in generale) tra cui una delle più popolari è certamente GitHub (https://github.com/). Github viene utilizzato come piattaforma di sviluppo per molti pacchetti di R ed è quindi possibile trovarve le ultime versioni di sviluppo dei pacchetti con gli aggirnamenti più recenti o anche nuovi pacchetti non ancora disponibili sul CRAN. Va sottolineato tuttavia, come quete siano appunto delle versioni di sviluppo e quindi potrebbero presentare maggiori problemi. Inoltre per installare i pacchetti in questo modo, è richiesta l’installzione di R tools (vedi “Approfondimento: R Tools” nel Capitolo 1.1). Per installare un pacchetto direttamente da Github è posibile utilizzare il comando install_github() del pacchetto devtools, indicanto tra parentesi la l’url della repository desiderata. install.packages(&quot;devtools&quot;) # ggplot2 il miglior pacchetto per grafici devtools::install_github(&quot;https://github.com/tidyverse/ggplot2&quot;) "],["working-session.html", "Capitolo 6 Sessione di Lavoro 6.1 Organizzazione Script 6.2 R projects 6.3 Messages, Warnings e Errors", " Capitolo 6 Sessione di Lavoro In questo capitolo, discuteremo di alcuni aspetti generali delle sessioni di lavoro in R. Descriveremo delle buone abitudini riguardanti l’organizzazione degli scripts e l’uso degli RStudio Projects per essere ordinati ed efficaci nel proprio lavoro. Infine approfondiremo l’uso dei messaggi di R ed in particolare come comportarsi in caso di errori. 6.1 Organizzazione Script Abbiamo visto che idealmente tutti i passaggi delle nostre analisi devono essere raccolti in modo ordinato all’interno di uno script. Eseguendo in ordine linea per linea i comandi, dovrebbe essere possibile svolgere tutte le analisi fino ad ottenere i risultati desiderati. Vediamo ora una serie di buone regole per organizzare in modo ordinato il codice all’interno di uno script e facilitare la sua lettura. 6.1.1 Creare delle Sezioni Per mantenere chiara l’oreganizzazione degli script e facilitare la sua comprensione, è utile suddividere il codice in sezioni dove vengono eseguiti i diversi step delle analisi. In RStudio è possibile creare una sezione aggiungendo al termine di una linea di commento i caratteri #### o ----. Il testo del commento verrà considerao il titolo della sezione e comparirà una piccola freccia a lato del numero di riga. E’ possibile utilizzare a piacere i caratteri # o - per creare lo stile desiderato, l’importante è che la linea si concluda con almeno quattro caratteri identici. # Sezione 1 #### # Sezione 2 ---- #---- Sezione 3 ---- #### Sezione non valida --## A titolo del tutto esemplificativo prendiamo in esempio la divisione in sezioni utilizzata nello script in Figura 6.1. Figure 6.1: Esempio di suddivisione in sezioni di uno script Titolo - Un titolo esplicativo del contenuto dello script. E’ possibile utilizzare altri caratteri all’interno dei commenti per creare l’effetto desiderato. Intorduzione - Descrizione e utili informazioni che riguardano sia l’obbiettivo del lavoro che l’esecuzione del codice (e.g., dove sono disponibili i dati, eventuali specifiche tecniche). Potrebbe essere utile anche indicare l’autore e la data del lavoro. Setting - Sezione fondamentale in cui si predispone l’abiente di lavoro. Le operazioni da svolgere sono: rm(list = ls()) per pulire l’Environment da eventuali oggetti in modo da eseguire lo script partendo da un ambiente vuoto (vedi Capitolo 5.1). setwd() per settare la working directory per assicuraci che i comandi siano eseguiti dalla correttta posizione nel nostro computer (vedi Capitolo 5.2). library() per caricare i pacchetti utilizzati nel corso delle analisi (vedi Capitolo 5.3). Caricare e Pulire i Dati - Generica sezione in cui eseguire l’importazione e pulizia dei dati. Codifica e Scoring dei Dati - Generica sezione in cui eseguire la codifica ed eventuale scoring dei dati. Analisi Descrittive - Generica sezione in cui eseguire le analisi descrittive. Analisi Inferenziali - Generica sezione in cui eseguire le analisi inferenziali Oltre che a mantenere ordinato e chiaro il codice, suddividere il proprio script in sezioni ci permette anche di navigare facilmente tra le diverse parti del codice. Possiamo infatti sfruttare l’indice che automaticamente viene creato. L’indice è consultabile premendo il tasto in alto a destra dello script da cui successivamente selezionare la sezione desiderata (vedi Figura 6.2). Figure 6.2: Indice in alto per navigazione sezioni In alternativa, è possibile utilizzare il menù in basso a sinistra dello script (vedi Figura 6.3). Figure 6.3: Menù in basso per navigazione sezioni Infine, un altro vantaggio è quello di poter compattare o espandere le sezioni di codice all’interno dell’editor, utilizzando le frecce a lato del numero di riga (vedi Figura 6.4). Figure 6.4: Compattare ed espandere le sezioni di codice 6.1.2 Sintassi Elenchiamo qui altre buone norme nella scrittura del codice che ne facilitano la comprensione. Commenti L’uso dei commenti è molto importante, ci permette di documentare le varie parti del codice e chiarire eventuli comandi difficili da capire. Tuttavia, non è necessario commentare ogni singola riga di codice ed anzi è meglio evitare di commentare laddove i comandi sono facilemtne interpetabili semplicemnte leggendo il codice. La capacità di scrivere commenti utili ed eviare quelli rindondanti si impara con l’esperienza. In generale un commento non dovrebbe indicare “che cosa” ma piuttosto il “perchè” di quella parte di codice. Infatti il cosa è facilmente interpretabile dal codice stesso mentre il perchè potrebbe essere meno ovvio e soprattutto più utile per la comprensione dell’intero script. Ad esempio: x &lt;- 10 # assegno a x il valore 10 x &lt;- 10 # definisco massimo numero risposte Il primo commento è inutile poichè è facilmente comprensibile dal codice stesso, mentre il secondo commento è motlo utile perchè chiarisce il significato della variabile e mi faciliterà nella comprensione del codice. Nomi Oggetti Abbiamo visto nel Capitolo 4.1.2 le regole che discriminano nomi validi da nomi non validi e le convenzioni da seguire nella definizione di un nome. Ricordiamo qui le caratterisiche che un nome deve avere per facilitare la comprensione del codice. Il nome di un oggetto deve essere: auto-descrittivo - Dal solo nome dovrebbe essere possibile intuire il contenuto dell’oggetto. E’ meglio quindi evitare nomi generici (quali x o y) ed utilizzare invece nomi che chiaramente descrivano il contenuto dell’oggetto. della giusta lunghezza - Non deve essere ne troppo breve (evitare sigle incomprensibili) ma neppure troppo lunghi. In genere sono sufficienti 2 o 3 parole per descrivere chiaramente un oggetto. E’ inoltre importante essere consistenti nella scelta dello stile con cui si nominano le variabili. In genere è preferibile usare lo snake_case rispetto al CamelCase, ma la scelta è comunque libera. Tuttavia, una volta presa una decisione, è bene mantenerla per facilitare la comprensione del codice. Esplicitare Argomenti Abbiamo visto nel Capitolo 4.2.1 l’importanza di esplicitare il nome degli argomenti quando vengono utilizzati nelle funzioni. Specificando a che cosa si riferiscono i vari valori facilitiamo la lettura e la comprensione del codice. Ad esempio: seq(0, 10, 2) Potrebbe non essere chiaro se intendiamo una sequennza tra 0 e 10 di lunghezza 2 o a intervalli di 2. Specificando gli argomenti evitiamo incomprensioni e possibili errori. seq(from = 0, to = 10, by = 2) seq(from = 0, to = 10, length.out = 2) Spazi, Indentazione ed allineamento Al contrario di molti altri software, R non impone regole severe nell’utilizzo di spazi, indentazioni ed allineamenti ed in genere è molto permissivo per quanto riguarda la sintassi del codice. Tuttavia è importante ricordare che: Good coding style is like using correct punctuation. You can manage without it, but it sure makes things easier to read. Hadley Wickham Prendiamo ad esempio le seguenti linee di codice, che includono delle funzioni avanzate di R: # Stile 1 k=10;if(k&lt;5){x&lt;-5:15}else{x&lt;-seq(0,16,4)};y=7*2-12;mean(x/y) ## [1] 4 # Stile 2 k &lt;- 10 if (k &lt; 5){ x &lt;- 5:15 } else { x&lt;-seq(from = 0, to = 16, by = 4) } y &lt;- 7 * 2 - 12 mean(x / y) ## [1] 4 Come puoi notare otteniamo in entrambi i casi gli stessi risultati, per R non c’è alcuna differenza. Tuttavia, l’uso di spazi, una corretta indentazione ed un appropriato allineamento facilita la lettura e comprensione del codice. In genere sono valide le seguenti regole: Aggiungi degli spazi intorno agli operatori (+, -, &lt;-, etc.) per separargli dagli argomenti ad eccezione di :. # Good 35 / 5 + 7 x &lt;- 0:10 # Bad 35/5+7 x&lt;-0 : 10 Nelle funzioni aggiungi degli spazi intorno al simbolo = che separa il nome degli argomenti e il loro valore. Aggiungi uno spazio dopo ogni virogola ma non separare il nome della funzione dalla parentesi sinistra. # Good seq(from = 0, to = 10, by = 2) # Bad seq (from=0,to=10,by=2) Usa la corretta indentazione per i blocchi di codice posti all’interno delle parentesi graffe. Il livello di indentazione deve rispecchiare la struttura di annidamento del codice. # Good for (...) { # loop più esterno ... for (...) { # loop interno ... if (...) { # isruzione condizionale ... } } } # Bad for (...) { # loop più esterno ... for (...) { # loop interno ... if (...) { # isruzione condizionale ... } } } Allinea gli argomenti di una funzione se questi spaziano più righe. # Good data.frame(id = ..., name = ..., age = ..., sex = ...) # Bad data.frame(id = ..., name = ..., age = ..., sex = ...) Potete trovare ulteriori regole e consigli riguardanti lo stile nella scrittura di codici al seguente link https://irudnyts.github.io/r-coding-style-guide/. 6.2 R projects TODO 6.2.1 Più di uno script idea di organizzare in vairi script, cartelle working directory tutto in funzione alla cartella 6.3 Messages, Warnings e Errors R utilizza la console per comunicare con noi durante le nostre sessioni di lavoro. Oltre a fornirci i risultati dei nostri comandi, R ci segnala anche altre utili informazioni attraverso diverse tipologie di messaggi. In particolare abbiamo: Messages: dei semplici messaggi che ci possono aggiornare ad esempio sullo stato di avanzamento di un dato compito oppure fornire suggerimenti sull’uso di una determinata funzione o pacchetto (spesso vengono mostrati quando viene caricato un pacchetto). Warnings: questi messaggi sono utlizzati da R per dirci che c’è stato qualche cosa di strano che ha messo in allerta R. R ci avvisa che, sebbene il comando sia stato eseguito ed abbiamo ottenuto un risultato, ci sono stati dei comportamenti inusuali o magari eventuali correzioni apportate in automatico. Nel caso di warnings non ci dobbiamo allramre, è importante controllare che i comandi siano corretti e che abbiamo effetivamente ottenuto il risultato desiderato. Una volta sicuri dei risultati possiamo procedere tranquillamente. Errors: R ci avvisa di eventuali errori e problemi che non permettono di eseguire il comando. in questo caso non otterremo nnessun risultato ma sarà necessario capire e risolvere il problema per poi rieseguire nuovamente il comando e procedere. Notiamo quindi come non tutti i messaggi che R ci manda sono dei messaggi di errore. E’ quindi importante non spaventarsi ma leggere con attenzione i messaggi, molte volte si tratta semplicemente di avvertimenti o suggerimenti. Tuttavia gli errori rappresentano sempre il maggiore dei problemi perchè non è possibile procedere nel lavoro senza averli prima risolti. E’ importante ricordare che i messaggi di errore non sono delle critiche che R ci rivolge perchè sbagliamo. Al contrario, sono delle richieste di aiuto fatte da R perchè non sa come comportarsi. Per quanto super potente, R è un seplice programma che non può interpretare le nostre richieste ma si basa sull’uso dei comandi che seguono una rigida sintassi. A volte è sufficiente una virgola mancante o un charattere al posto di un numero per mandare in confusione R e richiedere il nostro intervento risolutore. 6.3.1 Risolvere gli Errori Quando si approccia la scrittura di codice, anche molto semplice, la cosa che sicuramente capiterà più spesso sarà riscontrare messaggi di errore e quindi trovare il modo per risolverli. Qualche programmatore esperto direbbe che l’essenza stessa di programmare è in realtà risolvere gli errori che il codice produce. L’errore non è quindi un difetto o un imprevisto, ma parte integrante della scrittura del codice. L’importante è capire come gestirlo. Abbiamo tutti le immagini in testa di programmatori da film che scrivono codice alla velocità della luce, quando nella realtà dobbiamo spesso affrontare bug, errori di output o altri problemi vari. Una serie di skills utili da imparare sono: Comprendere a fondo gli errori (non banale) Sapere come e dove cercare una soluzione (ancora meno banale) In caso non si trovi una soluzione direttamente, chiedere aiuto in modo efficace Comprendere gli errori Leggere con attenzione i messaggi di errore è molto importante. R è solitamente abbastanza esplicito nel farci capire il problema. Ad esempio usare una funzione di un pacchetto che non è stato caricato di solito fornisce un messaggio del tipo Error in funzione : could not find function \"funzione\". Tuttavia, in altre situazioni i messaggi potrebbero non essere altrettanto chiari. Seppur esplicito R è anche molto sintetico e quindi l’utilzzo di un linguaggio molto specifico (e almeno inizialmente poco familiare), potrebbe rendere difficile capire il loro significato o addirittura renderli del tutto incomprensibili. Man mano che diventerete più esperti in R, diventerà sempre più semplice ed immmediato capire quale sia il problema e anche come risolverlo. Ma nel caso non si conosca la soluzione è necessario cercarla in altro modo. Problema + Google = Soluzione In qualsiasi situazione Google è il nostro miglior amico. Cercando infatti il messaggio di errore/warning su Google, al 99% avremo altre persone che hanno avuto lo stesso problema e probabilmente anche una soluzione. Il modo migliore per cercare è copiare e incollare su Google direttamente l’output di errore di R come ad esempio Error in funzione : could not find function \"funzione\" piuttosto che descrivere a parole il problema. I messaggi di errore sono standard per tutti, la tua descrizione invece no. Cercando in questo modo vedrete che molti dei risultati saranno esattamente riferiti al vostro errore: Chiedere una soluzione Se invece il vostro probelma non è un messaggio di errore ma un utilizzo specifico di R allora il consiglio è di usare una ricerca del tipo: argomento + breve descrizione problema + R. Nelle sezioni successive vedrete nel dettaglio altri aspetti della programmazione ma se volete ad esempio calcolare la media in R potrete scrivere compute mean in R. Mi raccomando, fate tutte le ricerche in inglese perchè le possibilità di trovare una soluzione sono molto più alte. Dopo qualche ricerca, vi renderete conto che il sito che vedrete più spesso si chiama Stack Overflow. Questo è una manna dal cielo per tutti i programmatori, a qualsiasi livello di expertise. E’ una community dove tramite domande e risposte, si impara a risolvere i vari problemi ed anche a trovare nuovi modi di fare la stessa cosa. E’ veramente utile oltre che un ottimo modo per imparare. L’ultimo punto di questa piccola guida alla ricerca di soluzioni, riguarda il fatto di dover non solo cercare ma anche chiedere. Dopo aver cercato vari post di persone che richiedevano aiuto per un problema noterete che le domande e le risposte hanno sempre una struttura simile. Questo non è solo un fatto stilistico ma anzi è molto utile per uniformare e rendere chiara la domanda ma sopratutto la risposta, in uno spirito di condivisione. C’è anche una guida dedicata per scrivere la domanda perfetta. In generale1: Titolo: un super riassunto del problema Contesto: linguaggio (es. R), quale sistema operativo (es. Windows) Descrizione del problema/richiesta: in modo chiaro e semplice ma non troppo generico Codice ed eventuali dati per capire il problema L’ultimo punto di questa lista è forse il più importante e si chiama in gergo tecnico REPREX (Reproducible Example). E’ un tema leggermente più avanzato ma l’idea di fondo è quella di fornire tutte le informazioni possibili per poter riprodurre (e quindi eventualmente trovare una soluzione) il codice di qualcuno nel proprio computer. Se vi dico “R non mi fa creare un nuovo oggetto, quale è l’errore?” è diverso da dire “il comando oggetto -&gt; 10 mi da questo errore Error in 10 &lt;- oggetto : invalid (do_set) left-hand side to assignment, come posso risolvere?” Ci sono anche diversi pacchetti in R che rendono automatico creare questi esempi di codice da poter condividere, come il pacchetto reprex. Fonte: Writing the perfect question - Jon Skeet↩︎ "],["introduzione.html", "Introduzione", " Introduzione In questa sezione verranno introdotte le principali tipologie di oggetti usati in R . Ovvero le principali strutture in cui possono essere organizzati i dati: Vettori, Matrici, Dataframe e Liste. Per ognuna di esse descriveremo le loro caretteristiche e vedremo come crearle, modificarle e manipolarle a seconda delle necessità I capitoli sono così organizzati: Capitolo 7 - Vettori. Impareremo le caratterisiche e l’uso dei vettori soffermandoci anche sulle diverse tipologie di dati. Capitolo 8 - Fattori. Impareremo le caratterisiche e l’uso dei fattori un particolare tipo di vettori usati per le variabili categoriali ed ordinali. "],["vector.html", "Capitolo 7 Vettori 7.1 Creazione 7.2 Selezione Elementi 7.3 Funzioni ed Operazioni 7.4 Data Type", " Capitolo 7 Vettori I vettori sono la struttura dati più semplice tra quelle presenti in R. Un vettore non è altro che un insieme di elementi disposti in uno specifico ordine e possiamo quindi immaginarlo in modo simile a quanto rappresentato in Figura 7.1. Figure 7.1: Rappresentazione struttura di un vettore di lunghezza n Due caratteristiche importanti di un vettore sono: la lunghezza - il numero di elementi da cui è formato il vettore la tipologia - la tipologia di dati da cui è formato il vettore. Un vettore infatti deve esssere formato da elementi dello stesso tipo e pertanto esistono diversi vettori a seconda della tipologia di dati da cui è formato (valori numerici, valori interi, valori logici, valori carattere). E’ fondamentale inoltre sottolineare come ogni elemento di un vettore sia caratterizzato da: un valore - ovvero il valore dell’elemento che può essere di qualsiasi tipo ad esempio un numero o una serie di caratteri. un indice di posizione - ovvero un numero intero positivo che identifica la sua posizione all’interno del vettore. Notiamo quindi come i vettori \\(x\\) e \\(y\\) così definiti: \\[ x = [1, 3, 5];\\ \\ \\ y = [3, 1, 5], \\] sebbene includano gli stessi elementi, non sono identici poichè differiscono per la loro disposizione. Tutto questo ci serve solo per ribadire come l’ordine degli elementi sia fondamentale per la valutazione di un vettore. Vedimao ora come creare dei vettori in R e come compiere le comuni operazini di selezione e manipolazione di vettori. Successivamente approfondiremo le caratteristiche dei vettori valutandone le diverse tipologie. 7.1 Creazione In realtà abbiamo già incontrato dei vettori nei precedenti capitoli poichè anche le variabili con un singolo valore altro non sono che un vettore di lunghezza 1. Tuttavia, per creare dei vettori di più elementi dobbiamo utilizzare il comando c(), ovvero “combine”, indicando tra le parentesi i valori degli elementi nella sucessione desiderata e separati da una virgola. Avremo quindi la seguente sintassi: nome_vettore &lt;- c(x_1, x_2, x_3, ..., x_n) Nota come gli elementi di un vettore debbano essere tutti della stessa tipologia ad esempio vaolri numerici o valori carattere. In altrentativa è possibile utilizzare qualsiasi funzione che restituisca come output una sequenza di valori sotto forma di vettore. Tra le funzioni più usate per creare delle sequenze abbiammo: &lt;from&gt;:&lt;to&gt; - Genera una sequenza di valori numerici crescenti (o decrescenti) dal primo valore indicato (&lt;from&gt;) al secondo valore indicato (&lt;to&gt;) a step di 1 (o -1 ). # sequenza crescente 1:5 ## [1] 1 2 3 4 5 # sequenza decrescente 2:-2 ## [1] 2 1 0 -1 -2 # sequenza con valori decimali 5.3:10 ## [1] 5.3 6.3 7.3 8.3 9.3 seq(from = , to = , by = , length.out = ) - Genera una sequenza regolare di valori numerici compresi tra from e to con incrementi indicati da by, oppure di lunghezza conplessiva indicata da length.out (vedi ?seq() per maggiori dettagli). # sequenza a incrementi di 2 seq(from = 0, to = 10, by = 2) ## [1] 0 2 4 6 8 10 # sequenza di 5 elementi seq(from = 0, to = 1, length.out = 5) ## [1] 0.00 0.25 0.50 0.75 1.00 rep(x, times = , each = ) - Genera una sequenza di valori ripetendo i valori contenuti in x. I valori di x posssono essere ripetuti nello stesso ordine più volte specificando times oppure ripetuti ciascuno più volte specificando each (vedi ?rep() per maggiori dettagli). # sequenza a incrementi di 2 rep(c(&quot;foo&quot;, &quot;bar&quot;), times = 3) ## [1] &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot; &quot;foo&quot; &quot;bar&quot; # sequenza di 5 elementi rep(1:3, each = 2) ## [1] 1 1 2 2 3 3 Esercizi Famigliarizza con la creazione di vettori (soluzioni): Crea il vettore x contenente i numeri 4, 6, 12, 34, 8 Crea il vettore y contenente tutti i numeri pari compresi tra 1 e 25 (?seq()) Crea il vettore z contenente tutti i primi 10 multipli di 7 partendo da 13 (?seq()) Crea il vettore s in cui le lettere \"A\",\"B\" e \"C\" vengono ripetute nel medesimo ordine 4 volte (?rep()) Crea il vettore t in cui le letter \"A\",\"B\" e \"C\" vengono ripetute ognuna 4 volte (?rep()) Genera il seguente output in modo pigro, ovvero scrivendo meno codice possibile ;) ## [1] &quot;foo&quot; &quot;foo&quot; &quot;bar&quot; &quot;bar&quot; &quot;foo&quot; &quot;foo&quot; &quot;bar&quot; &quot;bar&quot; 7.2 Selezione Elementi Una volta creato un vettore potrebbe essere necessario selezionare uno o più dei suoi elementi. In R per selezionare gli elementi di un vettore si utilizzano le parentesi quadre [] dopo il nome del vettore, indicando al loro interno l’indice di posizione degli elementi desiderati: nome_vettore[&lt;indice-posizione&gt;] Attenzione, non devo quindi indicare il valore dell’elemento desiderato ma il suo indice di posizione. Ad esempio: # dato il vettore my_numbers &lt;- c(2,4,6,8) # per selezionare il valore 4 utilizzo il suo indice di posizione ovvero 2 my_numbers[2] ## [1] 4 # Se utilizzassi il suo valore (ovvero 4) # otterrei l&#39;elemento che occupa la 4° posizione my_numbers[4] ## [1] 8 Per selezionare più elementi è necessario indicare tra le parentesi quadre tutti gli indici di posizione degli elementi desiderati. Nota come non sia possibile fornire semplicemente i singoli indici numerici ma questi devono essere raccolti in un vettore, ad esempio usando la funzione c(). Praticamente usiamo un vetore di indici per selezionare gli elemeni desiderati dal nostro vettore iniziale. # ERRATA selezione più valori my_numbers[1,2,3] ## Error in my_numbers[1, 2, 3]: incorrect number of dimensions # CORRETTA selezione più valori my_numbers[c(1,2,3)] ## [1] 2 4 6 my_numbers[1:3] ## [1] 2 4 6 Nota come l’operazione di selezione non modifichi l’oggetto iniziale. Pertanto è necessario salvare il risultato della selezione se si desidera mantenere le modifiche. my_words &lt;- c(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;) # Seleziono i primi 2 elementi my_words[1:2] ## [1] &quot;foo&quot; &quot;bar&quot; # Ho ancora tutti gli elementi nell&#39;oggetto my_words my_words ## [1] &quot;foo&quot; &quot;bar&quot; &quot;baz&quot; &quot;qux&quot; # Salvo i risultati my_words &lt;- my_words[1:2] my_words ## [1] &quot;foo&quot; &quot;bar&quot; Cosa accade se utiliziamo un indice di posizione maggiore del numero di elementi del nostro vettore? # Il mio vettore my_numbers &lt;- c(2,4,6,8) my_numbers[10] ## [1] NA R non restituisce un errore ma il valore NA ovvero Not Available, per indicare che nessun valore è disponibile. Osserviamo infine anche altri comportamenti particolari o possibili errori nella selezione di elementi. L’indice di posizione deve essere un valore numerico e non un carattere. # ERRATA selezione più valori my_numbers[&quot;3&quot;] ## [1] NA # CORRETTA selezione più valori my_numbers[3] ## [1] 6 I numeri decimali vengono ignorati e non “arrotondati” my_numbers[2.2] ## [1] 4 my_numbers[2.8] ## [1] 4 Utilizzando il valore 0 ottengo un vettore vuoto my_numbers[0] ## numeric(0) 7.2.1 Utilizzi Avanzati Selezione Vediamo ora alcuni utilizzi avanzati della selezione di elementi di un vettore. In particolare impareremo a: utilizzare gli operatori relazionali e logici per selezionare gli elementi di un vettore modificare l’ordine degli elemennti creare nuove combinazioni sostituire degli elementi eliminare degli elementi Operatori Relazionali e Logici Un’utile funzione è quella di selezionare tra gli elementi di un vetore quelli che rispetano una certa condizione. Per fare questo dobbiamo specificare all’interno delle parentesi quadre la proposizione di interesse utilizzando gli operatori relazionali e logici (vedi Capitolo 3.2). Possiamo ad esempio selezionare da un vettore numerico tutti gli elementi maggiori di un certo valore, oppure selezionare da un vettore di caratteri tutti gli elementi uguali ad una data stringa. # Vettore numerico - seleziono elemeni maggiori di 0 my_numbers &lt;- -5:5 my_numbers[my_numbers &gt;= 0] ## [1] 0 1 2 3 4 5 # Vettore caratteri - seleziono elemeni uguali a &quot;bar&quot; my_words &lt;- rep(c(&quot;foo&quot;, &quot;bar&quot;), times = 4) my_words[my_words == &quot;bar&quot;] ## [1] &quot;bar&quot; &quot;bar&quot; &quot;bar&quot; &quot;bar&quot; Per capire meglio questa operazione è importante notare come nello stesso comando ci siano in realtà due passaggi distinti: Vettore logico (vedi Capitolo TODO) - quando un vettore è valutato in una proposizione, R restituisce un nuovo vettore che contiene per ogni elemento del vettore iniziale la risposta (TRUE o FALSE) alla nostra proposizione. Selezione - utilizziamo il vettore logico ottenuto per selezionare gli elementi dal vettore iniziale. Gli elementi associati al valore TRUE sono selezionati mentre quelli associati al valore FALSE sono scartati. Rendiamo espliciti questi due passaggi nel seguente codice: # Vettore logico condition &lt;- my_words == &quot;bar&quot; condition ## [1] FALSE TRUE FALSE TRUE FALSE TRUE FALSE TRUE # Selezione my_words[condition] ## [1] &quot;bar&quot; &quot;bar&quot; &quot;bar&quot; &quot;bar&quot; Ordinare gli Elementi Gli indici di posizione possono essere utilizzati per ordinare gli elementi di un vettore a seconda delle necessità. messy_vector &lt;- c(5,1,7,3) # Altero l&#39;ordine degli elementi messy_vector[c(4,2,3,1)] ## [1] 3 1 7 5 # Ordino gli elementi per valori crescenti messy_vector[c(2,4,1,3)] ## [1] 1 3 5 7 Per ordinare gli elementi di un vettore in ordine crescente o decrescente (sia alfabetico che numerico), è possibile utilizzare la funzione sort() specificando l’argomento decreasing. Vedi l’help page della funzione per ulteriori informazioni (?sort()). # Ordine alfabetico my_letters &lt;- c(&quot;cb&quot;, &quot;bc&quot;, &quot;ab&quot;, &quot;ba&quot;, &quot;cb&quot;, &quot;ab&quot;) sort(my_letters) ## [1] &quot;ab&quot; &quot;ab&quot; &quot;ba&quot; &quot;bc&quot; &quot;cb&quot; &quot;cb&quot; # ordine decrescente sort(messy_vector, decreasing = TRUE) ## [1] 7 5 3 1 Nota come esista anche la funzione order() ma questa sia un false-friend perchè non ci fornisce direttamente un vettore con gli elementi ordinati ma bensì gli indici di posizione per riordinare gli elementi (?order()). Vediamo nel seguente esempio come utilizzare questa funzione: # Indici di posizione per riordinare gli elementi order(messy_vector) ## [1] 2 4 1 3 # Riordino il vettore usando gli indici di posizione messy_vector[order(messy_vector)] ## [1] 1 3 5 7 Combinazioni di Elementi Gli stessi indici di posizione possono essere richiamati più volte per ripetere gli elementi nelle combinazioni desiderate formando un nuovo vettore. my_numbers &lt;- c(5,6,7,8) # Ottengo un nuovo vettore con la combinazioen desiderata my_numbers[c(1,2,2,3,3,3,4)] ## [1] 5 6 6 7 7 7 8 Modificare gli Elementi Un importante utilizzo degli indici riguarda la modifica di un elemento di un vettore. Per sostituire un vecchio valore con un nuovo valore, posso utilizzare la funzione assign (&lt;- o =) come nell’esempio: my_names &lt;- c(&quot;Andrea&quot;, &quot;Bianca&quot;, &quot;Carlo&quot;) # Modifico il nome &quot;Bianca&quot; in &quot;Beatrice&quot; my_names[2] &lt;- &quot;Beatrice&quot; my_names ## [1] &quot;Andrea&quot; &quot;Beatrice&quot; &quot;Carlo&quot; Per sostituire il valore viene indicato alla sinistra dell’operatore assign il valore che si vuole modificare e alla destra il nuovo valore. Nota come questa operazione possa essere usata per aggiungere anche nuovi elementi al vettore. my_names[4] ## [1] NA # Aggiungo il nome &quot;Daniela&quot; my_names[4] &lt;- &quot;Daniela&quot; my_names ## [1] &quot;Andrea&quot; &quot;Beatrice&quot; &quot;Carlo&quot; &quot;Daniela&quot; Eliminare gli Elementi Per eliminare degli elementi da un vettore, si indicano all’interno delle parentesi quadre gli indici di posizione degli elementi da eliminare preceduti dall’operatore - (meno). Nel caso di più elementi è anche possibile indicare il meno solo prima del comando c(), ad esempio il comando x[c(-2,-4)] diviene x[-c(2,4)]. my_words &lt;- c(&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;, &quot;qux&quot;) # Elimino &quot;bar&quot; my_words[-2] ## [1] &quot;foo&quot; &quot;baz&quot; &quot;qux&quot; # Elimino &quot;foo&quot; e &quot;baz&quot; my_words[-c(1,3)] # oppure my_words[c(-1, -3)] ## [1] &quot;bar&quot; &quot;qux&quot; Nota come l’operazione di eliminazione sia comunque un’operazione di selezione. Pertanto è necessario salvare il risultato ottenuto se si desidera mantenere le modifiche. # Elimino &quot;foo&quot; e &quot;baz&quot; my_words[-c(1,3)] ## [1] &quot;bar&quot; &quot;qux&quot; # Ho ancora tutti gli elementi nell&#39;oggetto my_words my_words ## [1] &quot;foo&quot; &quot;bar&quot; &quot;baz&quot; &quot;qux&quot; # Salvo i risultati my_words &lt;- my_words[-c(1,3)] my_words ## [1] &quot;bar&quot; &quot;qux&quot; Esercizi Del vettore x seleziona il 2°, 3° e 5° elemento Del vettore x seleziona i valori 34 e 4 Dato il vettore my_vector = c(2,4,6,8) commenta il risultato del comando my_vector[my_vector] Del vettore y seleziona tutti i valori minori di 13 o maggiori di 19 Del vettore z seleziona tutti i valori compresi tra 24 e 50 Del vettore s seleziona tutti gli elementi uguali ad \"A\" Del vettore t seleziona tutti gli elementi diversi da \"B\" Crea un nuovo vettore u identico a s ma dove le \"A\" sono sostituite con la lettera \"U\" Elimina dal vettore z i valori 28 e 42 7.3 Funzioni ed Operazioni Vediamo ora alcune utili funzioni e comuni operazioni che è possibile svolgere con i vettori (vedi Tabella 7.1). Table 7.1: Operazioni con vettori Funzione Descrizione nuovo_vettore &lt;- c(vettore1, vettore2) Unire più vettori in un unico vettore length(nome_vettore) Valutare il numero di elementi contenuti in un vettore vettore1 + vettore2 Somma di due vettori vettore1 - vettore2 Differenza tra due vettori vettore1 * vettore2 Prodotto tra due vettori vettore1 / vettore2 Rapporto tra due vettori Nota che l’esecuzione di operazioni matematiche (e.g., +, -, *, / etc.) è possibile sia rispetto ad un singolo valore sia rispetto ad un altro vettore: Singolo valore - l’operazione sarà svolta per ogni elemento del vettore rispetto al singolo valore fornito. Altro vettore - l’operazione sarà svolta per ogni coppia di elementi dei due vettori. E’ quindi necessario che i due vettori abbiano la stessa lunghezza, ovvero lo stesso numero di elementi. x &lt;- 1:5 y &lt;- 1:5 # Sommo un valore singolo x + 10 ## [1] 11 12 13 14 15 # Somma di vettori (elemento per elemento) x + y ## [1] 2 4 6 8 10 Qualora i vettori differiscano per la loro lunghezza, R ci presenterà un warning avvisandoci del problema ma eseguirà comunque l’operazione utilizzando più volte il vettore più corto. x + c(1, 2) ## Warning in x + c(1, 2): longer object length is not a multiple of shorter object ## length ## [1] 2 4 4 6 6 Tuttavia, compiere operazioni tra vettori di diversa lunghezza (anche multipli) dovrebbe essere evitato perchè facile causa di errori e incomprensioni. In R la maggior parte degli operatori sono vettorizzati, ovvero calcolano direttamente il risultato per ogni elemento di un vettore. Questo è un grandissimo vantaggio poichè ci permette di essere molto efficienti e coincisi nel codice. Senza vettorizzazione, ogni operazione tra due vettori richiederebbe di specificare l’operazione per ogni elemento del vettore. Nel precedente esempio della somma tra x e y avremmo dovuto usare il seguente codice: z &lt;- numeric(length(x)) for(i in seq_along(x)) { z[i] &lt;- x[i] + y[i] } z ## [1] 2 4 6 8 10 Nota come questo sia valido anche per gli operatori relazionali e logici. Infatti valutando una proposizione rispetto ad un vettore, otterremmo una risposta per ogni elemento del vettore my_values &lt;- 1:8 # Valori compresi tra 4 e 7 my_values &gt;= 4 &amp; my_values &lt;= 7 ## [1] FALSE FALSE FALSE TRUE TRUE TRUE TRUE FALSE Esercizi Crea il vettore j unendo i vettori x ed z. Elimina gli ultimi tre elementi del vettore j e controlla che i vettori j e y abbiano la stessa lunghezza. Calcola la somma tra i vettori j e y. Moltiplica il vettore z per una costante k=3. Calcola il prodotto tra i primi 10 elementi del vettore y ed il vettore z. 7.4 Data Type Working in progress. Abbimao visto chè un’importante condizione dei vettori è che tutti gli elementi siano dello stesso tipo. Abbiamogià incontrato e osservato la differenza tra valori numerici e caratteri ma approfondiamo i diversi tipi e i relativi vatttori, relazioni tra tipologie di dati Tipi di vettori In R ci sono 4 tipi differenti di vettori: numerici, logici, caratteri e fattori. 7.4.1 Vettori Numerici I vettori numerici sono utilizzati per compiere operazioni aritmetiche, in R sono indicati come num. In R ci sono è possibil e specificare se i numeri contenuti nel vettore sono numeri interi, avremmo quindi un vettore di valori interi (indicato in R come int). Per fare ciò è possibile aggiungere L ad ogni valore numerico nel definire il vettore oppure usare la funzione as.integer() per trasformare un vettore numerico in un vettore intero. Esempio: x &lt;- c(4L, 6L, 12L, 34L, 8L) x &lt;- as.integer(c(4, 6, 12, 34, 8)) Nota: per trasformare un vettore intero in un vettore numerico è possibile usare la funzione as.numeric(). 7.4.2 Vettori logici I vettori logici sono formati dai volori TRUE e FALSE, che possono essere abbreviati rispettivamente in T e F. In R i vettori logici sono indicati come logi. In genere, i vettori logici sono il risultato delle operazioni in cui viene chiesto ad R di valutare la condizione logica di una proposizione. x&gt;10 ## [1] FALSE FALSE TRUE TRUE FALSE Nota: in R, come in molti altri software di programmazione, TRUE assume il valore numerico 1 e FALSE assume il valore 0. sum(x&gt;10) ## [1] 2 E’ possibile trasformare un vettore numerico in un vettor logico attraverso la funzione as.logical(), gli 0 assumeranno il valore FALSE mentre qualsiasi altro numero assumerà il valore TRUE. as.logical(c(1,0,.034,-1,0,8)) ## [1] TRUE FALSE TRUE TRUE FALSE TRUE 7.4.3 Vettori di caratteri I vettori di caratteri contengono stringhe di caratteri e sono indicati in R con `chr}. Non è possibile eseguire operazioni aritmetiche con vettori di caratteri ma solo valutare se due stringhe sono uguali o differenti. j&lt;-c(&quot;Hello&quot;,&quot;World&quot;,&quot;hello&quot;,&quot;world&quot;) j==&quot;hello&quot; ## [1] FALSE FALSE TRUE FALSE Per trasformare un vettore qualsiasi in una vettore di caratteri e possibile usare la funzione as.character(). as.character(x) ## [1] &quot;4&quot; &quot;6&quot; &quot;12&quot; &quot;34&quot; &quot;8&quot; as.character(x&gt;10) ## [1] &quot;FALSE&quot; &quot;FALSE&quot; &quot;TRUE&quot; &quot;TRUE&quot; &quot;FALSE&quot; is. vecor ### Valori speciali "],["factors.html", "Capitolo 8 Fattori", " Capitolo 8 Fattori Working in progress. I fattori sono utilizzati per definire delle variabili categoriali, sono indicati in R con Factor. Per creare una variabile categoriale in R si utilizza la funzione: nome_variabile&lt;-factor(c(..., data, ...), levels=c(...)) L’opzione levels=c(...) è usata per specificare quali sono i possibili livelli della variabile categoriale. E’ possibile modificare o aggiungere nuovi livelli della variabile anche in un secondo momento utilizzando la funzione: levels(nome_fattore)&lt;- c(..., nuovi_livelli, ...) Nota: nel creare un fattore R associa ad ogni livello un valore in ordine crescente e assegna agli elementi del vettore il loro volore numerico a seconda del proprio livello. Pertanto se un fattore è trasformato in un vettore numerico vengono restituiti tali valori numerici e non i livelli anche nel caso fossero dei numeri. Prendiamo per esempio la variabile anni_istruzione: anni_istruzione&lt;-factor(c(11,8,4,8,11,4,11,8)) anni_istruzione ## [1] 11 8 4 8 11 4 11 8 ## Levels: 4 8 11 as.numeric(anni_istruzione) ## [1] 3 2 1 2 3 1 3 2 Per riottenere gli estti valori numerici è necessario eseguire: as.numeric(as.character(anni_istruzione)) ## [1] 11 8 4 8 11 4 11 8 Esercizi Crea la variabile categoriale sex così definita: ## [1] M F M F M F F F M ## Levels: F M Rinomina i livelli della variabile sex rispettivamente in \"donne\" e \"uomini\". Crea la variabile categoriale intervento così definita: ## [1] CBT Psicanalisi CBT Psicanalisi CBT Psicanalisi ## [7] Controllo Controllo CBT ## Levels: CBT Controllo Psicanalisi Correggi nella variabile intervento la 7° e 8° osservazione con la voce Farmaci. Aggiungi alla variabile intervento le seguenti nuove osservazioni: ## [1] &quot;Farmaci&quot; &quot;Controllo&quot; &quot;Farmaci&quot; "],["matrix.html", "Capitolo 9 Matrici 9.1 Creazione di una matrice 9.2 Proprietà della matrice 9.3 Indicizzazione di matrici 9.4 Indicizzazione avanzata 9.5 Combinare matrici", " Capitolo 9 Matrici 9.1 Creazione di una matrice La matrice è una struttura di dati bidimensionale che può contenere solo una tipologia di dato. Nel capitolo 7.4 sono state introdotte le varie tipologie di dato e come per i vettori, possiamo avere delle matrici di soli numeri o di soli caratteri. Il comando per creare una matrice in R è matrix() e contiene diversi argomenti: nome_matrice &lt;- matrix(data, nrow = &quot;numero righe&quot;, ncol = &quot;numero colonne&quot;, byrow = FALSE) L’argomento data sono i valori con cui vogliamo popolare la matrice e sono considerati come un vettore. Gli argomenti nrow e ncol sono rispettivamente il numero di colonne e il numero di righe della matrice L’argomento byrow indica se la matrice deve essere popolata per riga oppure per colonna. Creiamo come esempio una matrice vuota con soli valori NA con 5 righe e 5 colonne mat &lt;- matrix(data = NA, nrow = 5, ncol = 5, byrow = FALSE) mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] NA NA NA NA NA ## [2,] NA NA NA NA NA ## [3,] NA NA NA NA NA ## [4,] NA NA NA NA NA ## [5,] NA NA NA NA NA L’argomento byrow = FALSE è il default per il comando matrix() quindi R popola le matrici per colonna, se non espressamente richiesto. A questo punto popoliamo la matrice con i valori che vanno da 1 a 25. # Dati per popolare la matrice vec &lt;- 1:25 vec ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 # Matrice popolata per riga mat_bycol &lt;- matrix(data = vec, nrow = 5, ncol = 5, byrow = TRUE) mat_bycol ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 ## [3,] 11 12 13 14 15 ## [4,] 16 17 18 19 20 ## [5,] 21 22 23 24 25 # Matrice popolata per colonna mat_byrow &lt;- matrix(data = vec, nrow = 5, ncol = 5, byrow = FALSE) mat_byrow ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 6 11 16 21 ## [2,] 2 7 12 17 22 ## [3,] 3 8 13 18 23 ## [4,] 4 9 14 19 24 ## [5,] 5 10 15 20 25 Come si vede la matrice ora è popolata dai numeri che abbiamo creato e viene di default, popolata per colonna. Allo stesso modo possiamo semplicemente impostare byrow = TRUE per popolare la matrice per riga. E’ importante tenere in considerazione che l’argomento data deve essere compatibile con gli argomenti nrow e ncol. In altre parole non posso fornire più o meno dati di quelli che la matrice può contenere. E’ invece possibile specificare qualsiasi combinazione di righe e colonne rispettando che il numero totale di elementi corrisponda agli spazi disponibili. vec &lt;- 1:16 # Numero non compatibile mat &lt;- matrix(vec, ncol = 5, nrow = 5, byrow = FALSE) ## Warning in matrix(vec, ncol = 5, nrow = 5, byrow = FALSE): data length [16] is ## not a sub-multiple or multiple of the number of rows [5] mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 6 11 16 5 ## [2,] 2 7 12 1 6 ## [3,] 3 8 13 2 7 ## [4,] 4 9 14 3 8 ## [5,] 5 10 15 4 9 # Matrice non quadrata con lo stesso vettore mat &lt;- matrix(vec, ncol = 2, nrow = 8, byrow = FALSE) mat ## [,1] [,2] ## [1,] 1 9 ## [2,] 2 10 ## [3,] 3 11 ## [4,] 4 12 ## [5,] 5 13 ## [6,] 6 14 ## [7,] 7 15 ## [8,] 8 16 Abbiamo visto che possiamo facilmente popolare una matrice con un vettore. Allo stesso modo possiamo vettorizzare una matrice (in altri termini “srotolare” la matrice) per ritornare al vettore originale. Con il comando c(matrice) oppure forzando la tipologia di oggetto a vettore con vector(matrice) o as.vector(matrice). # Da matrice a vettore c(mat) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 as.vector(mat) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 La matrice è una tipologia di oggetto molto importante sia in R ma anche nella matematica, ad esempio nell’algebra lineare. Come vedremo ci sono diverse operazioni matematice (somma, moltiplicazione, inversione, etc.) che si possono eseguire. Abbiamo inoltre accennato che la matrice può contenere anche valori non numerici. # Creare una matrice di caratteri chr_mat &lt;- matrix(data = &quot;chr&quot;, nrow = 5, ncol = 5, byrow = FALSE) chr_mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] &quot;chr&quot; &quot;chr&quot; &quot;chr&quot; &quot;chr&quot; &quot;chr&quot; ## [2,] &quot;chr&quot; &quot;chr&quot; &quot;chr&quot; &quot;chr&quot; &quot;chr&quot; ## [3,] &quot;chr&quot; &quot;chr&quot; &quot;chr&quot; &quot;chr&quot; &quot;chr&quot; ## [4,] &quot;chr&quot; &quot;chr&quot; &quot;chr&quot; &quot;chr&quot; &quot;chr&quot; ## [5,] &quot;chr&quot; &quot;chr&quot; &quot;chr&quot; &quot;chr&quot; &quot;chr&quot; # Popolare una matrice di caratteri vec_chr &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;, &quot;f&quot;, &quot;g&quot;, &quot;h&quot;, &quot;i&quot;, &quot;l&quot;, &quot;m&quot;, &quot;n&quot;, &quot;o&quot;, &quot;p&quot;, &quot;q&quot;, &quot;r&quot;) chr_mat &lt;- matrix(vec_chr, nrow = 4, ncol = 4, byrow = FALSE) chr_mat ## [,1] [,2] [,3] [,4] ## [1,] &quot;a&quot; &quot;e&quot; &quot;i&quot; &quot;o&quot; ## [2,] &quot;b&quot; &quot;f&quot; &quot;l&quot; &quot;p&quot; ## [3,] &quot;c&quot; &quot;g&quot; &quot;m&quot; &quot;q&quot; ## [4,] &quot;d&quot; &quot;h&quot; &quot;n&quot; &quot;r&quot; Per questo tipo di matrice valgono tutte le proprietà che vedremo o abbiamo visto fino ad ora. Tuttavia, non è molto frequente l’utilizzo di matrici di caratteri visto che chiaramente tutte le operazioni comuni non sono possibili. Esercizi Crea la matrice A così definita: \\[ \\begin{matrix} 2 &amp; 34 &amp; 12 &amp; 7\\\\ 46 &amp; 93 &amp; 27 &amp; 99\\\\ 23 &amp; 38 &amp; 7 &amp; 04 \\end{matrix} \\] Crea la matrice B contenente tutti i primi 12 numeri dispari disposti su 4 righe e 3 colonne. Crea la matrice C contenente i primi 12 multipli di 9 disposti su 3 righe e 4 colonne. Crea la matrice D formata da 3 colonne in cui le lettere \"A\",\"B\" e \"C\" vengano ripetute 4 volte ciascuna rispettivamente nella prima, seconda e terza colonna. Crea la matrice E formata da 3 righe in cui le lettere \"A\",\"B\" e \"C\" vengano ripetute 4 volte ciascuna rispettivamente nella prima, seconda e terza riga. 9.2 Proprietà della matrice La matrice essendo bidimensionale è formata da due elementi, righe e colonne. Sapendo il numero di righe e colonne infatti sappiamo la quantità di elementi nella matrice. Per ottenere queste informazioni possiamo usare i comandi ncol() e nrow(). vec &lt;- 1:25 mat &lt;- matrix(vec, ncol = 5, nrow = 5, byrow = FALSE) # Numero di righe nrow(mat) ## [1] 5 # Numero di colonne ncol(mat) ## [1] 5 Come avete notato, la matrice viene principalmente gestita tramite indici numerici, nella sezione successiva vedremo come accedere ad ogni elemento di una matrice. In R, possiamo però anche assegnare dei nomi alle proprietà (o dimensioni) della matrice. Con i comandi rownames() e colnames() possiamo accedere ai nomi di righe e colonne o assegnarne di nuovi. Un comando più rapido è dimnames() che restituisce direttamente i nomi di riga e/o colonna. vec &lt;- 1:25 mat &lt;- matrix(vec, ncol = 5, nrow = 5, byrow = FALSE) # Nome di righe rownames(mat) ## NULL # Nome di colonne colnames(mat) ## NULL Non essendo impostati, ottieniamo un NULL come output. Se impostare i nomi di righe e/o colonne, è sufficiente assegnare a rownames(matrice) o colnames(matrice) un vettore di caratteri della stessa lunghezza della dimensione che stiamo rinominando. Se impostiamo un unico carattere, tutte le righe/colonne avranno lo stesso valore. Questo ci fa capire che R richiede che tutte le righe/colonne abbiano un nome. vec &lt;- 1:25 mat &lt;- matrix(vec, ncol = 5, nrow = 5, byrow = FALSE) dimnames(mat) ## NULL # Assegnamo i nomi row_names &lt;- letters[1:5] col_names &lt;- letters[6:10] colnames(mat) &lt;- col_names rownames(mat) &lt;- row_names dimnames(mat) ## [[1]] ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; ## ## [[2]] ## [1] &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; mat ## f g h i j ## a 1 6 11 16 21 ## b 2 7 12 17 22 ## c 3 8 13 18 23 ## d 4 9 14 19 24 ## e 5 10 15 20 25 9.3 Indicizzazione di matrici L’aspetto sicuramente più importante (e divertente) riguardo le matrici è accedere ai vari elementi. Indipendentemente da cosa la matrice contenga infatti possiamo pensare ai valori come ad una griglia dove l’incrocio tra righe \\(i\\) e colonne \\(j\\) crea una cella unica \\(ij\\) che contiene uno specifico valore. Un modo utile per capire questo concetto è immaginare una matrice \\(i \\times j\\) dove ogni elemento è il numero di riga \\(i\\) e il numero di colonna \\(j\\): ## [,1] [,2] [,3] [,4] [,5] ## [1,] &quot;11&quot; &quot;12&quot; &quot;13&quot; &quot;14&quot; &quot;15&quot; ## [2,] &quot;21&quot; &quot;22&quot; &quot;23&quot; &quot;24&quot; &quot;25&quot; ## [3,] &quot;31&quot; &quot;32&quot; &quot;33&quot; &quot;34&quot; &quot;35&quot; ## [4,] &quot;41&quot; &quot;42&quot; &quot;43&quot; &quot;44&quot; &quot;45&quot; ## [5,] &quot;51&quot; &quot;52&quot; &quot;53&quot; &quot;54&quot; &quot;55&quot; In questa matrice è chiaro che il primo elemento è nella prima riga e nella prima colonna, il secondo elemento (per riga) è nella prima riga e nella seconda colonna e così via. Questo introduce un aspetto fondamentale di come funzionano le matrici e i vettori (e come vedremo anche i dataframe) ovvero si può fare riferimento agli indici di riga e colonna per accedere a qualsiasi elemento. In sostanza, per accedere ad una matrice usiamo le parentesi quadre matrice[] e in ordine forniamo il numero di riga e il numero di colonna. L’ordine [riga, colonna] è arbitrario e deve essere rispettato. vec &lt;- 1:25 mat &lt;- matrix(vec, ncol = 5, nrow = 5, byrow = FALSE) mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 6 11 16 21 ## [2,] 2 7 12 17 22 ## [3,] 3 8 13 18 23 ## [4,] 4 9 14 19 24 ## [5,] 5 10 15 20 25 # Selezioniamo l&#39;elemento alla riga 3 e colonna 5 mat[3,5] ## [1] 23 # Selezioniamo l&#39;elemento alla riga 10 e colonna 1 mat[10,1] ## Error in mat[10, 1]: subscript out of bounds Come vedete, possiamo accedere a qualsiasi elemento. Se indichiamo un indice che non è presente nella matrice in oggetto, chiaramente otteniamo un errore. 9.4 Indicizzazione avanzata Oltre a selezionare uno specifico elemento possiamo essere interessati a selezionare più elementi insieme. La sintassi rimane la stessa quindi matrice[riga, colonna] ma possiamo combinare le conoscenze sui vettori e sulla creazione di oggetti. Quello che possiamo fare: Selezionare tutti gli elementi di una riga o colonna Selezionare la diagonale della matrice Selezionare solo alcune righe e/o colonne Selezionare elementi con operazioni logiche Per selezionare tutti gli elementi di una riga o colonna si usa la sintassi matrice[, colonna] o matrice[riga, ] per selezionare rispettivamente tutte le righe ma solo una o più colonne e tutte le colonne ma solo una o più righe. Lasciando vuoto il posto prima o dopo la virgola diciamo ad R di selezionare tutto. vec &lt;- 1:25 mat &lt;- matrix(vec, ncol = 5, nrow = 5, byrow = FALSE) mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 6 11 16 21 ## [2,] 2 7 12 17 22 ## [3,] 3 8 13 18 23 ## [4,] 4 9 14 19 24 ## [5,] 5 10 15 20 25 # Selezioniamo tutta la prima riga mat[1, ] ## [1] 1 6 11 16 21 # Selezioniamo tutta la terza colonna mat[, 2] ## [1] 6 7 8 9 10 Selezionando solo una riga/colonna ci rendiamo conto che otteniamo una cosa molto simile ad un vettore. Infatti, un vettore può essere anche visto come una matrice con una sola riga o colonna. In R comunque sia il vettore che una matrice con una sola dimensione sono trattati allo stesso modo. Riguardo la diagonale di una matrice essa può essere vista, dal punto di vista prettamente pratico, come l’insieme di elementi associati allo stesso indice di riga e colonna. Il comando diag(matrice) permette di estrarre la diagonale di una matrice e trattarla come un semplice vettore: # Matrice quadrata vec &lt;- 1:25 mat &lt;- matrix(vec, ncol = 5, nrow = 5, byrow = FALSE) mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 6 11 16 21 ## [2,] 2 7 12 17 22 ## [3,] 3 8 13 18 23 ## [4,] 4 9 14 19 24 ## [5,] 5 10 15 20 25 diag(mat) ## [1] 1 7 13 19 25 # Matrice non quadrata vec &lt;- 1:16 mat &lt;- matrix(vec, ncol = 2, nrow = 8, byrow = FALSE) mat ## [,1] [,2] ## [1,] 1 9 ## [2,] 2 10 ## [3,] 3 11 ## [4,] 4 12 ## [5,] 5 13 ## [6,] 6 14 ## [7,] 7 15 ## [8,] 8 16 diag(mat) ## [1] 1 10 Per selezionare più righe e colonne insieme possiamo usare diversi metodi. Essenzialmente se devo selezionare più elementi devo fornire ad R più indici insieme. E’ chiaro però che la notazione matrice[riga, colonna] non è direttamente compatibile se vogliamo più elementi. La scrittura matrice[riga1, riga2, colonna] infatti è sbagliata perchè R si aspetta una sola virgola che separa righe e colonne. Il modo più rapido è quindi combinare gli indici che vogliamo in un vettore (usando il comando c() ad esempio) e poi selezionare gli elementi. Se le colonne sono indicizzate come numeri in successione, ad esempio seleziono le prime 3 colonne posso utilizzare la scrittura compatta 1:3 che è equivalente a c(1,2,3) vec &lt;- 1:25 mat &lt;- matrix(vec, ncol = 5, nrow = 5, byrow = FALSE) mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 6 11 16 21 ## [2,] 2 7 12 17 22 ## [3,] 3 8 13 18 23 ## [4,] 4 9 14 19 24 ## [5,] 5 10 15 20 25 # Prime 2 righe e prime 2 colonne mat[c(1,2), c(1,2)] ## [,1] [,2] ## [1,] 1 6 ## [2,] 2 7 # Riga 1 e 4, colonna 4 e 5 mat[c(1,4), c(4,5)] ## [,1] [,2] ## [1,] 16 21 ## [2,] 19 24 # Prime tre righe e quinta colonna mat[1:3, 5] ## [1] 21 22 23 Essendo la matrice (principalmente) formata da elementi numerici, possiamo anche eseguire le principali operazioni sia matematiche (e.g. somma, differenza, moltiplicazione) ma anche quelle logiche come “quali elementi della matrice sono maggiori di x?”. Allo stesso modo possiamo selezionare (e quindi estrarre) gli elementi che rispettano una certa condizione usando la sintassi matrice[operazione logica]. Le operazioni logiche complesse sono molto utili sopratutto con i dataframe come vedremo nelle prossime sezioni. vec &lt;- 1:25 mat &lt;- matrix(vec, ncol = 5, nrow = 5, byrow = FALSE) mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 6 11 16 21 ## [2,] 2 7 12 17 22 ## [3,] 3 8 13 18 23 ## [4,] 4 9 14 19 24 ## [5,] 5 10 15 20 25 # Quali elementi sono &gt; 5 mat &gt; 5 ## [,1] [,2] [,3] [,4] [,5] ## [1,] FALSE TRUE TRUE TRUE TRUE ## [2,] FALSE TRUE TRUE TRUE TRUE ## [3,] FALSE TRUE TRUE TRUE TRUE ## [4,] FALSE TRUE TRUE TRUE TRUE ## [5,] FALSE TRUE TRUE TRUE TRUE # Quali elementi sono &lt; 1 mat &gt; 5 ## [,1] [,2] [,3] [,4] [,5] ## [1,] FALSE TRUE TRUE TRUE TRUE ## [2,] FALSE TRUE TRUE TRUE TRUE ## [3,] FALSE TRUE TRUE TRUE TRUE ## [4,] FALSE TRUE TRUE TRUE TRUE ## [5,] FALSE TRUE TRUE TRUE TRUE # Quali elementi sono = 0 mat == 5 ## [,1] [,2] [,3] [,4] [,5] ## [1,] FALSE FALSE FALSE FALSE FALSE ## [2,] FALSE FALSE FALSE FALSE FALSE ## [3,] FALSE FALSE FALSE FALSE FALSE ## [4,] FALSE FALSE FALSE FALSE FALSE ## [5,] TRUE FALSE FALSE FALSE FALSE # Selezioniamo gli elementi mat[mat &gt; 5] ## [1] 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 mat[mat == 0] ## integer(0) Un ultimo aspetto da considerare, anche se non molto diffuso consiste nell’indicizzare una matrice in base ai nomi delle righe e/o colonne. Come abbiamo visto nella sezione 9.2 possiamo assegnare dei nomi (quindi delle stringhe) alle righe e colonne. Possiamo quindi selezionare la riga 1 sia con il suo indice matrice[1, ] ma anche con il nome assegnato matrice[\"nome\",]. Queste sono operazioni fondamentali con i dataframe ma meno utili con le matrici. vec &lt;- 1:25 mat &lt;- matrix(vec, ncol = 5, nrow = 5, byrow = FALSE) row_names &lt;- letters[1:5] col_names &lt;- letters[6:10] colnames(mat) &lt;- col_names rownames(mat) &lt;- row_names mat ## f g h i j ## a 1 6 11 16 21 ## b 2 7 12 17 22 ## c 3 8 13 18 23 ## d 4 9 14 19 24 ## e 5 10 15 20 25 # Selezioniamo la riga &quot;a&quot; mat[&quot;a&quot;, ] ## f g h i j ## 1 6 11 16 21 # Selezioniamo le colonne &quot;i&quot; e &quot;j&quot; mat[, c(&quot;i&quot;, &quot;j&quot;)] ## i j ## a 16 21 ## b 17 22 ## c 18 23 ## d 19 24 ## e 20 25 9.5 Combinare matrici Abbiamo visto nel capitolo 7 come si possano fare diverse operazioni tra vettori, in particolare combinare ovvero unire vettori diversi. Anche per le matrici è possibile combinare matrici diverse, rispettando alcune regole: Posso unire matrici per riga ovvero aggiungo una o più righe ad una matrice, oppure per colonna ovvero aggiungo una o più colonne Posso unire matrici che abbiamo la stessa dimensione (i.e., numero di righe e/o colonne) rispetto alla dimensione che voglio combinare Le matrici che unisco devono essere della stessa tipologia (numeri o caratteri) Se partiamo da una matrice mat per unire a mat un’altra matrice new_mat possiamo usare il comando cbind(mat, new_mat) se vogliamo unire le due matrici per colonna invece rbind(mat, new_mat) se vogliamo unire per riga. E’ utile pensare all’unione come un collage tra matrici, in figura9.1 è presente uno schema utile per capire visivamente questo concetto. Figure 9.1: Schema per la combinazione di matrici Vediamo in R: vec &lt;- 1:25 mat &lt;- matrix(vec, ncol = 5, nrow = 5, byrow = FALSE) # Nuova matrice da aggiungere new_vec &lt;- 11:20 new_mat &lt;- matrix(new_vec, ncol = 2, nrow = 5, byrow = FALSE) mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 6 11 16 21 ## [2,] 2 7 12 17 22 ## [3,] 3 8 13 18 23 ## [4,] 4 9 14 19 24 ## [5,] 5 10 15 20 25 new_mat ## [,1] [,2] ## [1,] 11 16 ## [2,] 12 17 ## [3,] 13 18 ## [4,] 14 19 ## [5,] 15 20 # Combiniamo per colonna cbind(mat, new_mat) ## [,1] [,2] [,3] [,4] [,5] [,6] [,7] ## [1,] 1 6 11 16 21 11 16 ## [2,] 2 7 12 17 22 12 17 ## [3,] 3 8 13 18 23 13 18 ## [4,] 4 9 14 19 24 14 19 ## [5,] 5 10 15 20 25 15 20 # Combiniamo per riga rbind(mat, new_mat) ## Error in rbind(mat, new_mat): number of columns of matrices must match (see arg 2) # Scambiamo il numero di colonne e righe, per far combaciare le due matrici new_vec &lt;- 11:20 new_mat &lt;- matrix(new_vec, ncol = 5, nrow = 2, byrow = FALSE) mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 6 11 16 21 ## [2,] 2 7 12 17 22 ## [3,] 3 8 13 18 23 ## [4,] 4 9 14 19 24 ## [5,] 5 10 15 20 25 new_mat ## [,1] [,2] [,3] [,4] [,5] ## [1,] 11 13 15 17 19 ## [2,] 12 14 16 18 20 rbind(mat, new_mat) ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 6 11 16 21 ## [2,] 2 7 12 17 22 ## [3,] 3 8 13 18 23 ## [4,] 4 9 14 19 24 ## [5,] 5 10 15 20 25 ## [6,] 11 13 15 17 19 ## [7,] 12 14 16 18 20 Possiamo combinare quindi per riga/colonna solo se le righe/colonne delle due matrici sono equivalenti. Otteniamo un errore quando cerchiamo di combinare matrici di dimensioni diverse. Un ultimo aspetto utile è l’estensione dei comandi cbind() ed rbind(). Fino ad ora li abbiamo utilizzati con due elementi: matrice di partenza e matrice da aggiungere ma possono essere utilizzati con elementi multipli. Se vogliamo combinare \\(n\\) matrici possiamo usare il comando cbind(mat1, mat2, mat3, ...) o rbind(mat1, mat2, mat3, ...). In questo caso il risultato finale dipende dall’ordine degli argomenti quindi prima la mat1, poi la mat2 e così via. Ci sono molte altre operazioni da eseguire con le matrici. La tabella 9.1 riassume quelle che abbiamo visto e anche alcune operazioni più legate al mondo dell’algebra. Table 9.1: Operazioni con matrici Operazione Nome &lt;nuova-matrice&gt; &lt;- cbind(&lt;matrice1&gt;, &lt;matrice2&gt;) Per unire due matrici creando nuove colonne (le matrici devono avere lo stesso numero di righe) &lt;nuova-matrice&gt; &lt;- rbind(&lt;matrice1&gt;, &lt;matrice2&gt;) Per unire due matrici creando nuove righe (le matrici devono avere lo stesso numero di colonne) nrow(&lt;nome-matrice&gt;) Per valutare il numero di righe della matrice ncol(&lt;nome-matrice&gt;) Per valutare il numero di colonne della matrice dim(&lt;nome-matrice&gt;) Per valutare la dimensione della matrice (righe e colonne) t(&lt;nome-matrice&gt;) Per ottenere la trasposta della matrice diag(&lt;nome-matrice&gt;) Ottenere un vettore con gli elementi della diagonale della matrice det(&lt;nome-matrice&gt;) Ottenere il determinante della matrice (la matrice deve essere quadrata) solve(&lt;nome-matrice&gt;) Ottenere l’inversa della matrice colnames(&lt;nome-matrice&gt;) Nomi delle colonne della matrice rownames(&lt;nome-matrice&gt;) Nomi delle righe della matrice matrice1 + matrice2 Somma elemento per elemento di due matrici matrice1 - matrice2 Differenza elemento per elemento tra due matrici matrice1 * matrice2 Prodotto elemento per elemento tra due matrici matrice1 / matrice2 Rapporto elemento per elemento tra due matrici matrice1 %*% matrice2 Prodotto matriciale Esercizi Utilizzando la matrice creata A creata negli esercizi precedenti: Utilizzando gli indici di riga e di colonna selziona il numero 27 della matrice A Selziona gli elementi compresi tra la seconda e quarta riga, seconda e terza colonna della matrice B Seleziona solo gli elementi pari della matrice A (Nota: utilizza l’operazione resto %%) Elimina dalla matrice C la terza riga e la terza colonna Seleziona tutti gli elementi della seconda e terza riga della matrice B Seleziona tutti gli elementi diversi da “B” appartenenti alla matrice D Crea la matrice G unendo alla matrice A le prime due colonne della matrice C Crea la matrice H unendo alla matrice C le prime due righe della matrice trasposta di B Ridefinisci la matrice A eliminando la seconda colonna. Ridefinisci la matrice B eliminando la prima riga. Verifica che le matrici così ottenute abbiano la stessa dimensione. Commenta i differenti risultati che otteniamo nelle operazioni A*B, B*A, A%*%B e B%*%A. Assegna i seguenti nomi alle colonne e alle righe della matrice C: \"col\\_1\", \"col\\_2\", \"col\\_3\", \"col\\_4\", \"row\\_1\", \"row\\_2\", \"row\\_3\". "],["dataframe.html", "Capitolo 10 Dataframe 10.1 Creazione di un dataframe 10.2 Proprietà di un dataframe 10.3 Indicizzazione di dataframe 10.4 Indicizzazione avanzata", " Capitolo 10 Dataframe Il dataframe è uno degli oggetti più interessanti ed anche utilizzati del linguaggio R. Inoltre, se vi capiterà di utilizzare altri linguaggi di programmazione sopratutto mirati all’analisi dati (Matlab ad esempio) noterete come vi mancherà un oggetto potente e intuitivo come il dataframe. Come vedremo ci sono molte somiglianze tra il dataframe e la matrice. Quando necessario, si farà riferimento al capitolo precedente per far notare quali aspetti sono in comune tra queste due strutture di dati. Il dataframe come dice il nome fa riferimento ad una struttura per i dati. Dati in questo caso è volutamente generico perchè il dataframe rispetto alla matrice può contenere nello stesso oggetto, tipi diversi di dato come fattori, caratteri e numeri. Può essere utile pensare al dataframe esattamente come ad una normale tabella che si può creare un un foglio di calcolo (Excel) dove possiamo mettere nomi, date, numeri, etc. La struttura di base di un dataframe è quindi la stessa di una matrice ma contiene i nomi delle colonne (e anche delle righe eventualmente) di default. Un esempio di dataframe è rappresentato nella tabella 10.1 Table 10.1: Esempio di dataframe colonna1 colonna2 colonna3 colonna4 colonna5 colonna6 -1.38 -0.75 -0.33 -1.68 0.04 a -0.01 0.93 -0.29 -0.14 0.44 b 0.58 2.55 0.58 -0.75 -0.51 c -0.96 -0.59 -0.54 0.58 -2.00 d -0.42 -0.76 0.51 -0.21 0.71 e -0.96 -0.16 0.47 -0.31 -2.39 f 0.09 -1.05 -0.46 0.53 -1.51 g 0.33 2.85 0.10 0.57 -0.55 h -0.15 0.34 -0.93 -1.84 1.01 i 0.22 1.07 0.64 1.67 -0.01 j Come si vede abbiamo colonne con un nome che contengono sia numeri che caratteri. Questo non era chiaramente possibile con le matrici. 10.1 Creazione di un dataframe Il comando per creare un dataframe è il comando data.frame() tuttavia la creazione è leggermente diversa rispetto alla matrice. Pensando all’analogia con il foglio di calcolo Excel, intuitivamente è più facile immaginare la creazione di una dataframe mettendo insieme colonne relativamente indipendenti (dove una può contenere dei nomi, un’altra delle date e così via) piuttosto che un insieme di numeri inseriti per riga o per colonna come per le matrici. Infatti il modo di creare un dataframe è priprio questo ovvero specificando nomecolonna = valori all’interno del comando data.frame(). Vediamo un esempio in R: dat &lt;- data.frame( Id = c(&quot;subj_1&quot;,&quot;subj_2&quot;,&quot;subj_3&quot;), age = c(21,23,19), sex = c(&quot;F&quot;,&quot;M&quot;,&quot;F&quot;), item1 = c(2,1,1), item2 = c(0,2,1), item3 = c(2,0,1) ) dat ## Id age sex item1 item2 item3 ## 1 subj_1 21 F 2 0 2 ## 2 subj_2 23 M 1 2 0 ## 3 subj_3 19 F 1 1 1 In questo caso abbiamo creato un ipotetico dataframe dove in ogni riga abbiamo un soggetto e ogni colonna rappresenta una data caratteristica del soggetto come il genere, l’età e così via. Un aspetto importante adesso è proprio quello che il dataframe è stato pensato per gestire dati complessi ed eterogenei come quelli che si trovano in un’analisi di dati reale. Una convenzione molto utile da ricordare infatti è quella che le righe di un dataframe rappresentano le osservazioni (ad esempio persone) e le colonne rappresentano variabili ovvero delle proprietà misurate su quelle osservazioni. Una distinzione fondamentale nella pratica di analisi dei dati è quella tra dati in forma long (oppure lunga) o dati in forma wide (oppure larga). Non c’è un formato corretto o sbagliato ma dipende dal tipo di analisi e dal software o pacchetto che si utilizza. Alcune operazioni o analisi richiedono il dataset in forma long altre in forma wide. Mantenendo l’esempio di soggetti e caratteristiche misurate sui soggetti i due formati sono definiti come: Wide: ogni singola riga rappresenta un soggetto e ogni sua risposta o variabile misurata sarà riportata in una diversa colonna. Il dataset creato in precedenza era infatti proprio nel formato wide: data_wide&lt;-data.frame( Id=c(&quot;subj_1&quot;,&quot;subj_2&quot;,&quot;subj_3&quot;), age=c(21,23,19), sex=c(&quot;F&quot;,&quot;M&quot;,&quot;F&quot;), item_1=c(2,1,1), item_2=c(0,2,1), item_3=c(2,0,1) ) data_wide ## Id age sex item_1 item_2 item_3 ## 1 subj_1 21 F 2 0 2 ## 2 subj_2 23 M 1 2 0 ## 3 subj_3 19 F 1 1 1 Long: ogni singola riga rappresenta una singola osservazione. Quindi i dati di ogni soggetto saranno riportati su più righe e le variabili che non cambiano tra le osservazioni saranno ripetute. data_long&lt;-data.frame(Id=rep(c(&quot;subj_1&quot;,&quot;subj_2&quot;,&quot;subj_3&quot;),each=3), age=rep(c(21,23,19),each=3), sex=rep(c(&quot;F&quot;,&quot;M&quot;,&quot;F&quot;),each=3), item=rep(1:3,3), response=c(2,1,1,0,2,1,2,0,1)) data_long ## Id age sex item response ## 1 subj_1 21 F 1 2 ## 2 subj_1 21 F 2 1 ## 3 subj_1 21 F 3 1 ## 4 subj_2 23 M 1 0 ## 5 subj_2 23 M 2 2 ## 6 subj_2 23 M 3 1 ## 7 subj_3 19 F 1 2 ## 8 subj_3 19 F 2 0 ## 9 subj_3 19 F 3 1 Come potete vedere, nel dataset in forma long ogni soggetto ha 3 righe perchè oltre al genere e l’età che sono uniche, ci sono 3 variabili diverse misurate sulla stessa persona. I dati in forma long e wide hanno delle proprietà diverse sopratutto in riferimento all’utilizzo. La tipologia di dato e il risultato finale è esattamente lo stesso tuttavia alcuni software o alcuni pacchetti di R funzionano solo con dataset organizzati in un certo modo. Il consiglio però è di abituarsi il più possibile a ragionare in forma long perchè la maggior parte dei moderni pacchetti per l’analisi dati e per la creazione di grafici richiedono i dati in questo formato. Ci sono comunque delle funzioni (più avanzate) per passare velocemente da un formato all’altro. Come per le matrici, anche i dataframe richiedono che tutte le colonne (variabili) abbiano lo stesso numero di elementi. Nota: di default R considera una variabile stringa all’interno di un DataFrame come una variabile categoriale. E’ possibile cambiare questa opzione specificando stringsAsFactors=FALSE. Esercizi Crea il dataframe data_wide riportato precedentemente Crea il dataframe data_long riportato precedentemente 10.2 Proprietà di un dataframe In modo simile alle matrici, i dataframe contengono dei metadati per assegnare dei nomi alle righe rownames() e alle colonne colnames(). Inoltre il dataframe ha una dimensione intesa come numero di righe e colonne esattamente come la matrice. Di default il dataframe richiede dei nomi solo alle colonne ma è possibile anche nominare le righe. Utilizzando il dataframe precedente: data_long ## Id age sex item response ## 1 subj_1 21 F 1 2 ## 2 subj_1 21 F 2 1 ## 3 subj_1 21 F 3 1 ## 4 subj_2 23 M 1 0 ## 5 subj_2 23 M 2 2 ## 6 subj_2 23 M 3 1 ## 7 subj_3 19 F 1 2 ## 8 subj_3 19 F 2 0 ## 9 subj_3 19 F 3 1 # Controllo dei nomi rownames(data_long) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; colnames(data_long) ## [1] &quot;Id&quot; &quot;age&quot; &quot;sex&quot; &quot;item&quot; &quot;response&quot; names(data_long) # nel caso dei dataframe questo è analogo a colnames() ## [1] &quot;Id&quot; &quot;age&quot; &quot;sex&quot; &quot;item&quot; &quot;response&quot; # Dimensioni nrow(data_long) ## [1] 9 ncol(data_long) ## [1] 5 10.3 Indicizzazione di dataframe Ancora di più che per le matrici, è nell’indicizzazione che si vede la vera potenza dei dataframe. Rimandendo su un’indicizzazione tramiti indici di riga e colonna il funzionamento è esattamente analogo a quello della matrice, quindi dataframe[riga, colonna]: data_long ## Id age sex item response ## 1 subj_1 21 F 1 2 ## 2 subj_1 21 F 2 1 ## 3 subj_1 21 F 3 1 ## 4 subj_2 23 M 1 0 ## 5 subj_2 23 M 2 2 ## 6 subj_2 23 M 3 1 ## 7 subj_3 19 F 1 2 ## 8 subj_3 19 F 2 0 ## 9 subj_3 19 F 3 1 # Seleziono 1 riga e 4 colonna data_long[1,4] ## [1] 1 # Seleziono 1 riga e tutte le colonne data_long[1, ] ## Id age sex item response ## 1 subj_1 21 F 1 2 # Seleziono righe 1 e 3 e tutte le colonne data_long[c(1,3), ] ## Id age sex item response ## 1 subj_1 21 F 1 2 ## 3 subj_1 21 F 3 1 La reale differenza tra matrici e dataframe sta nel poter accedere direttamente alle colonne tramite il loro nome e utilizzando l’operatore $. Con la scrittura dataframe$nomevariabile accediamo direttamente a quella specifica colonna senza utilizzare indici e parentesi quadre. # Seleziono la variabile ID (soggetto) data_long$Id ## [1] &quot;subj_1&quot; &quot;subj_1&quot; &quot;subj_1&quot; &quot;subj_2&quot; &quot;subj_2&quot; &quot;subj_2&quot; &quot;subj_3&quot; &quot;subj_3&quot; ## [9] &quot;subj_3&quot; # Seleziono la variabile Sex data_long$sex ## [1] &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;M&quot; &quot;M&quot; &quot;M&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; # Analogalmente data_long[, 1] # seleziono id con indice di colonna ## [1] &quot;subj_1&quot; &quot;subj_1&quot; &quot;subj_1&quot; &quot;subj_2&quot; &quot;subj_2&quot; &quot;subj_2&quot; &quot;subj_3&quot; &quot;subj_3&quot; ## [9] &quot;subj_3&quot; data_long[, 3] # seleziono sex con indice di colonna ## [1] &quot;F&quot; &quot;F&quot; &quot;F&quot; &quot;M&quot; &quot;M&quot; &quot;M&quot; &quot;F&quot; &quot;F&quot; &quot;F&quot; Un ulteriore differenza rispetto alle matrici è quella della combinazione di dataframe o della creazione di nuove righe o colonne. Sono sempre valide le indicazioni riguardo a cbind() e rbind() ma nel caso di nuove colonne è possibile utilizzare l’operatore $. Con la scrittura dataframe$name &lt;- new_var otteniamo che nel dataframe in oggetto ci sarà una nuova colonna chiamata name che prende i valori all’interno di new_var. Attenzione che mentre la scrittura dataframe$name &lt;- new_var aggiunge direttamente la colonna al dataframe, usando cbind() dobbiamo assegnare l’operazione ad un nuovo oggetto dataframe &lt;- cbind(dataframe, new_var). In quest’ultimo caso il nome della colonna sarà new_var. Se vogliamo anche rinominare la colonna possiamo usare la sintassi cbind(dataframe, \"nome\" = new_var) oppure chiamare l’oggetto direttamente con il nome desiderato: data_wide ## Id age sex item_1 item_2 item_3 ## 1 subj_1 21 F 2 0 2 ## 2 subj_2 23 M 1 2 0 ## 3 subj_3 19 F 1 1 1 # Aggiungiamo una colonna item4 al nostro dataset new_var &lt;- c(3, 4, 7) data_wide$item_4 &lt;- new_var # Equivalente a data_wide$item_4 &lt;- c(3, 4, 7) # Equivalente a cbind(data_wide, new_var) # senza specificare il nome ## Id age sex item_1 item_2 item_3 item_4 new_var ## 1 subj_1 21 F 2 0 2 3 3 ## 2 subj_2 23 M 1 2 0 4 4 ## 3 subj_3 19 F 1 1 1 7 7 cbind(data_wide, &quot;item_4&quot; = new_var) # specificando anche il nome ## Id age sex item_1 item_2 item_3 item_4 item_4 ## 1 subj_1 21 F 2 0 2 3 3 ## 2 subj_2 23 M 1 2 0 4 4 ## 3 subj_3 19 F 1 1 1 7 7 Leggermente più complessa (e inusuale) è l’aggiunta di righe ad un dataframe. Al contrario della matrice che di base non aveva nomi per le colonne e solo numeri o stringhe come tipologia di dato, per combinare per riga due dataframe dobbiamo avere: Lo stesso numero di colonne (come per le matrici) Lo stesso nome delle colonne tra i due dataframe data_wide ## Id age sex item_1 item_2 item_3 item_4 ## 1 subj_1 21 F 2 0 2 3 ## 2 subj_2 23 M 1 2 0 4 ## 3 subj_3 19 F 1 1 1 7 # Nuovo dataset con le stesse colonne ma chiamate in un modo diverso new_row &lt;- data.frame( Id = &quot;subj_4&quot;, gender = &quot;M&quot;, # gender invece che sex age = 44, item_1 = 2, item_2 = 7, item_3 = 3, item_4 = 1 ) new_row ## Id gender age item_1 item_2 item_3 item_4 ## 1 subj_4 M 44 2 7 3 1 rbind(data_wide, new_row) # Errore ## Error in match.names(clabs, names(xi)): names do not match previous names # Nuovo dataset con le stesse colonne con il nome corretto new_row &lt;- data.frame( Id = &quot;subj_4&quot;, sex = &quot;M&quot;, age = 44, item_1 = 2, item_2 = 7, item_3 = 3, item_4 = 1 ) new_row ## Id sex age item_1 item_2 item_3 item_4 ## 1 subj_4 M 44 2 7 3 1 rbind(data_wide, new_row) # Corretto ## Id age sex item_1 item_2 item_3 item_4 ## 1 subj_1 21 F 2 0 2 3 ## 2 subj_2 23 M 1 2 0 4 ## 3 subj_3 19 F 1 1 1 7 ## 4 subj_4 44 M 2 7 3 1 10.4 Indicizzazione avanzata Quello che avevamo accennato per le matrici rispetto all’indicizzazione avanzata per nome e per operazioni logiche qui è invece molto utile e rilevante. Quando trattiamo dati che non sono solo numerici e sopratutto hanno delle proprietà come “soggetti”, “età”, “genere”, è intuitivo pensare un modo altrettanto logico e intuitivo di lavorare con queste strutture di dati. Per rendere il tutto più intuitivo facciamo un esempio con un dataset fittizio dove sono inseriti i nostri amici su Facebook ed alcune caratteristiche su di loro in particolare: Nome Età (age) Genere (sex) Data iscrizione a Facebook (facebook) Numero di fratelli/sorelle (nsiblings) Numero di foto assieme a noi (foto) Vediamo il dataset in R: ## nome age sex facebook nsiblings foto ## 1 Filippo 17 M 17 0 13 ## 2 Claudio 51 M 51 4 14 ## 3 Giovanni 55 M 55 2 11 ## 4 Francesco 23 M 23 3 18 ## 5 Luigi 18 M 18 5 17 ## 6 Giacomo 34 M 34 1 2 ## 7 Gianmarco 49 M 49 4 20 ## 8 Bruna 47 F 47 3 12 ## 9 Franco 44 M 44 3 7 ## 10 Elettra 56 F 56 5 0 ## 11 Livia 32 F 32 2 2 ## 12 Anna 56 F 56 3 2 ## 13 Luca 25 M 25 5 2 ## 14 Giulia 52 F 52 4 18 ## 15 Alice 42 F 42 4 15 Ora se volessimo usare l’indicizzazione standard possiamo semplicemente usare la sintassi solita dataframe[riga/e, colonna/e]. Tuttavia se volessimo trovare tutte le informazioni associate alla nostra amica Elettra, usare gli indici di riga/colonna diventa scomodo. Quello che è stato introdotto nei capitolo iniziali rispetto agli operatori logici qui diventa molto rilevante. Possiamo infatti “interrogare” il nostro dataframe dicendo di farci vedere tutte le informazioni che rispettano una specifica richiesta. La sintassi “Tutte le informazioni riguardo Elettra” diventa tutte le colonne (informazioni) solo per la riga dove il nome è Elettra. In R questo può essere controllato in questo modo: # nomi sono nella colonna &quot;nome&quot; dat$nome ## [1] &quot;Filippo&quot; &quot;Claudio&quot; &quot;Giovanni&quot; &quot;Francesco&quot; &quot;Luigi&quot; &quot;Giacomo&quot; ## [7] &quot;Gianmarco&quot; &quot;Bruna&quot; &quot;Franco&quot; &quot;Elettra&quot; &quot;Livia&quot; &quot;Anna&quot; ## [13] &quot;Luca&quot; &quot;Giulia&quot; &quot;Alice&quot; # Per sapere quale riga corrisponde ad elettra dat$nome == &quot;Elettra&quot; ## [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE TRUE FALSE FALSE ## [13] FALSE FALSE FALSE which(dat$nome == &quot;Elettra&quot;) # Elettra è la riga 10 ## [1] 10 Praticamente con dat$nome == \"Elettra\" otteniamo una serie di TRUE e FALSE in base a se il nome è “Elettra” oppure no. Combinando questo con l’indicizzazione classica dataframe[riga/e, colonna/e] possiamo usare gli operatori logici per interrogare il dataset. dat[dat$nome == &quot;Elettra&quot;, ] ## nome age sex facebook nsiblings foto ## 10 Elettra 56 F 56 5 0 Ora la sintassi dataframe[riga/e, colonna/e] assume un significato molto diverso ovvero: dataframe[operazioni_logiche_righe, operazioni_logiche_colonne] Utilizzando gli operatori booleani AND($) OR(|) e NOT(!) possiamo inoltre combinare più operazioni logiche insieme per ottenere indicizzazioni più complesse, ma sempre intuitive dal punto di vista della scrittura. Ad esempio: “Gli amici con età maggiore di 20 anni e con più di 5 foto assieme a noi”. In questo caso un amico per ottenere un valore TRUE ed essere così inserito nei risultati deve rispettare due condizioni: dat[dat$age &gt; 20 &amp; dat$foto &gt; 5, ] ## nome age sex facebook nsiblings foto ## 2 Claudio 51 M 51 4 14 ## 3 Giovanni 55 M 55 2 11 ## 4 Francesco 23 M 23 3 18 ## 7 Gianmarco 49 M 49 4 20 ## 8 Bruna 47 F 47 3 12 ## 9 Franco 44 M 44 3 7 ## 14 Giulia 52 F 52 4 18 ## 15 Alice 42 F 42 4 15 Possiamo chiaramente eseguire selezioni sulle colonne, per esempio sapere solo il numero di fratelli/sorelle degli amici che rispettano la condizione precedente: dat[dat$age &gt; 20 &amp; dat$foto &gt; 5, &quot;nsiblings&quot;] ## [1] 4 2 3 4 3 3 4 4 Un ultimo aspetto da notare riguarda il tipo di output che otteniamo. Se la nostra selezione comprende più di 1 riga/colonna otteniamo un dataframe che è considerato un subset di quello iniziale. Se come nell’ultimo esempio otteniamo una singola colonna (o variabile) allora il risultato è un semplice vettore. res1 &lt;- dat[dat$age &gt; 20 &amp; dat$foto &gt; 5, ] res2 &lt;- dat[dat$age &gt; 20 &amp; dat$foto &gt; 5, &quot;nsiblings&quot;] str(res1) # è un dataframe ## &#39;data.frame&#39;: 8 obs. of 6 variables: ## $ nome : chr &quot;Claudio&quot; &quot;Giovanni&quot; &quot;Francesco&quot; &quot;Gianmarco&quot; ... ## $ age : int 51 55 23 49 47 44 52 42 ## $ sex : chr &quot;M&quot; &quot;M&quot; &quot;M&quot; &quot;M&quot; ... ## $ facebook : int 51 55 23 49 47 44 52 42 ## $ nsiblings: int 4 2 3 4 3 3 4 4 ## $ foto : int 14 11 18 20 12 7 18 15 str(res2) # è un vettore ## int [1:8] 4 2 3 4 3 3 4 4 Allo stesso modo di selezionare una specifica colonna o riga possiamo eliminare una osservazione. Il concetto di eliminazione o sovrascrittura in R è diverso da quello di un normale file perchè tutte le operazioni che facciamo solitamente portano a tre strade: Eseguiamo le operazioni in modalità “volatile” senza assegnare il risultato Creiamo un nuovo oggetto B che deriva da applicare ad A una certa operazione B &lt;- funzione(A) Assegnamo ad A una serie di operazioni su se stesso, di fatto sovrascrivendo l’oggetto A &lt;- funzione(A) Nel caso dei dataframe possiamo usare l’operatore - (meno) per escludere una certa selezione: ## Id age sex item_1 item_2 item_3 item_4 ## 2 subj_2 23 M 1 2 0 4 ## 3 subj_3 19 F 1 1 1 7 ## Id age item_1 item_2 item_3 item_4 ## 1 subj_1 21 2 0 2 3 ## 2 subj_2 23 1 2 0 4 ## 3 subj_3 19 1 1 1 7 ## Id sex item_1 item_2 item_3 item_4 ## 2 subj_2 M 1 2 0 4 E’ possibile anche escludere (ed eliminare in un certo senso) delle informazioni usando gli operatori logici in gli operatori NOT(!) e diverso da (!=): # Seleziono tutto tranne il soggetto 2 data_wide[!data_wide$Id == &quot;subj_2&quot;, ] # modo 1 ## Id age sex item_1 item_2 item_3 item_4 ## 1 subj_1 21 F 2 0 2 3 ## 3 subj_3 19 F 1 1 1 7 data_wide[data_wide$Id != &quot;subj_2&quot;, ] # modo 2 ## Id age sex item_1 item_2 item_3 item_4 ## 1 subj_1 21 F 2 0 2 3 ## 3 subj_3 19 F 1 1 1 7 L’utilizzo dell’operatore - è sempre in qualche modo pericoloso, sopratutto se l’oggetto che viene creato (o sovrascritto) viene poi utilizzato in altre operazioni. Eliminare delle informazioni, tranne quando è veramente necessario, non è mai una buona cosa. Se dovete selezionare una parte dei dati è sempre meglio creare un nuovo dataframe (o un nuovo oggetto in generale) e mantendere una versione di quello originale sempre disponibile. Nella tabella 10.2 è contenuto un riassunto delle principali operazioni che si possono eseguire con i dataframe: Table 10.2: Operazioni con dataframe Operazione Nome nome_DataFrame &lt;- cbind(nome_DataFrame, nuova_variabile) nome_DataFrame$nome_variabile &lt;- dati Per aggiungere una nuova variabile al DataFrame (deve avere lo stesso numero di righe) nome_DataFrame &lt;- rbind(nome_DataFrame, nuova_variabile) Per aggiungere delle osservazioni (i nuovi dati devono essere coerenti con la struttura del DataFrame) nrow(nome_DataFrame) Per valutare il numero di osservazioni del DataFrame ncol(nome_DataFrame) Per valutare il numero di variabili del DataFrame holder(nome_DataFrame) Nomi delle colonne del DataFrame rownames(nome_DataFrame) Nomi delle righe del DataFrame Esercizi Facendo riferimento ai dataframe data_long e data_wide: Utilizzando gli indici numerici di riga e di colonna seleziona i dati del soggetto subj_2 riguardanti le variabili item e response dal DataFrame data_long. Compi la stessa selezione dell’esercizio precedente usando però questa volta una condizione logica per gli indici di riga e indicando direttamente il nome delle variabili per gli indici di colonna. Considerando il DataFrame data_wide seleziona le variabili Id e sex dei soggetti che hanno risposto 1 alla variabile item_1. Considerando il DataFrame data_long seleziona solamente i dati riguardanti le ragazze con etè superiore ai 20 anni. Elimina dal DataFrame data_long le osservazioni riguardanti il soggetto subj_2 e la variabile \"sex\". Aggiungi sia al DataFrame data_wide che data_long la variabile numerica \"memory_pre\". data.frame(Id=c(&quot;subj_1&quot;,&quot;subj_2&quot;,&quot;subj_3&quot;), memory_pre=c(3,2,1)) Aggiungi sia al DataFrame data_wide che data_long la variabile categoriale \"gruppo\". data.frame(Id=c(&quot;subj_1&quot;,&quot;subj_2&quot;,&quot;subj_3&quot;), gruppo=c(&quot;trattamento&quot;,&quot;trattemento&quot;,&quot;controllo&quot;)) Aggiungi al DataFrame data_wide i dati del soggetto subj_4 e subj_5. data.frame(Id=c(&quot;subj_4&quot;,&quot;subj_5&quot;), age=c(25,22), sex=c(&quot;F&quot;,&quot;M&quot;), item_1=c(1,1), item_2=c(0,1), item_3=c(2,0), memory_pre=c(1,3), gruppo=c(&quot;trattemento&quot;,&quot;controllo&quot;)) Considerando il DataFrame datawide calcola la variabile \"memory_post\" data dalla somma degli item. Considerando il DataFrame data_wide cambia i nomi delle variabili item_1, item_2 e item_3 rispettivamente in problem_1, problem_2 e problem_3. "],["list.html", "Capitolo 11 Liste 11.1 Creazione di Liste 11.2 Selezione di Elementi di una Lista", " Capitolo 11 Liste Working in progress. 11.1 Creazione di Liste Le liste sono degli speciali oggi in R che permettono di contenere al loro interno altri oggetti indipendentemente dalla loro tipologia. Possiamo quindi avere nella stessa lista sia vettori, sia matrici sia DataFrames. In R per definire una lista si utilizza il comando: &lt;- list(nome_oggetto_1 = oggetto_1, …, nome_oggetto_n = oggetto_n) All’interno si possono riportare vari oggettiche si vogliono inserire con i relativi nomi, separati da virgole. Esercizi Crea la lista esperimento_1 contenente: DataFrame data_wide la matrice A il vettore x la variabile info = \"Prima raccolta dati\" Crea la lista esperimento_2 contenente: DataFrame data_long la matrice C il vettore y la variabile info = \"Seconda raccolta dati\" 11.2 Selezione di Elementi di una Lista In R per selezioneare gli elementi di una lista si possono usare le doppie parentesi quadre indicando l’indice della posizione dell’oggetto che si vuole selezionare: nome_lista[[indice_posizione]] In alternativa, se i nomi degli oggetti sono stati specificati, è possibile utilizzare l’operatore “$” e il nome dell’oggetto da selezionare all’interno della lista: nome_lista$nome_oggetto In seguito per accedere a specifici elementi all’interno degli oggetti si utilizzano le stesse norme precedentemente presentate a seconda del tipo di oggetto. Esempio: - esperimento_1[[2]][,2] - esperimento_1$data_wide$age Nota: per definire o cambiare i nomi degli oggetti contenuti in una lista è possibile utilizzare la funzione: names(nome_lista) &lt;- c(nome_oggetto_1, ..., nome_oggetto_n) Esercizi Utilizzando gli indici numerici di posizione selziona i dati dei soggetti subj_1 e subj_4 riguardanti le variabili age,sex e gruppo dal DataFrame data_wide contenuto nella lista esperimento_1. Compi la stessa selezione dell’esercizio precedente usando però questa volta il nome dell’oggetto per selezionare il DateFrame dalla lista. Considerando la lista esperimento_2 seleziona gli oggetti data_long, y e info Cambia i nomi degli oggetti contenuti nella lista esperimento_2 rispettivamente in \"dati_esperimento\", \"matrice_VCV\", \"codici_Id\" e \"note\" "],["introduzione-1.html", "Introduzione", " Introduzione Working in progress. "],["functions.html", "Capitolo 12 Definizione di Funzioni", " Capitolo 12 Definizione di Funzioni Working in progress. "],["coditionals.html", "Capitolo 13 Programmazione Condizionale", " Capitolo 13 Programmazione Condizionale Working in progress. "],["loop.html", "Capitolo 14 Attenti al loop", " Capitolo 14 Attenti al loop Working in progress. "],["introduzione-2.html", "Introduzione", " Introduzione Working in progress. "],["attachment.html", "Capitolo 15 Caso Studio I: Attaccamento 15.1 Infobox", " Capitolo 15 Caso Studio I: Attaccamento Working in progress. 15.1 Infobox Illustrations included in images/ are retrieved from rstudio4edu-book under CC-BY-NC. Remember to include an Attributions section in the book and repository’s README file. Lorem ipsum dolor sit amet consectetur adipisicing elit. Maxime mollitia, molestiae quas vel sint commodi repudiandae consequuntur voluptatum laborum numquam blanditiis harum quisquam eius sed odit fugiat iusto fuga praesentium optio, eaque rerum! Lorem ipsum dolor sit amet consectetur adipisicing elit. Maxime mollitia, molestiae quas vel sint commodi repudiandae consequuntur voluptatum laborum numquam blanditiis harum quisquam eius sed odit fugiat iusto fuga praesentium optio, eaque rerum! Lorem ipsum dolor sit amet consectetur adipisicing elit. Maxime mollitia, molestiae quas vel sint commodi repudiandae consequuntur voluptatum laborum numquam blanditiis harum quisquam eius sed odit fugiat iusto fuga praesentium optio, eaque rerum! Lorem ipsum dolor sit amet consectetur adipisicing elit. Maxime mollitia, molestiae quas vel sint commodi repudiandae consequuntur voluptatum laborum numquam blanditiis harum quisquam eius sed odit fugiat iusto fuga praesentium optio, eaque rerum! Lorem ipsum dolor sit amet consectetur adipisicing elit. Maxime mollitia, molestiae quas vel sint commodi repudiandae consequuntur voluptatum laborum numquam blanditiis harum quisquam eius sed odit fugiat iusto fuga praesentium optio, eaque rerum! "]]
