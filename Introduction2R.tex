% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Introduction to R},
  pdfauthor={Claudio Zandonella Callegher and Filippo Gambarota members of Psicostat},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage[a4paper,includeheadfoot,left=3cm, right=3cm, top=3cm, bottom=3cm]{geometry}  % margin settings
\usepackage{booktabs}
\usepackage{makecell} % for tables
\usepackage{amsthm}
\makeatletter
\def\thm@space@setup{%
  \thm@preskip=8pt plus 2pt minus 4pt
  \thm@postskip=\thm@preskip
}
\makeatother

\usepackage{hyperref}

%----    define infoboxes    ----%
\usepackage{tcolorbox}
\usepackage{xcolor}

% colors
\definecolor{background}{HTML}{fcfcfc}
\definecolor{tip-text}{HTML}{e7b002}
\definecolor{tip-line}{HTML}{fdce38}
\definecolor{warning-text}{HTML}{b06336}
\definecolor{warning-line}{HTML}{c97d50}
\definecolor{deffun-text}{HTML}{0b797e}
\definecolor{deffun-line}{HTML}{6CC2C9}
\definecolor{design-text}{HTML}{7c972e}
\definecolor{design-line}{HTML}{a7c84a}
\definecolor{trick-text}{HTML}{8c3031}
\definecolor{trick-line}{HTML}{A3595A}

\tcbuselibrary{breakable}
\newtcolorbox{mybox}[1][black]{
  breakable,
  colback=background,
  coltext=black,
  colframe=#1,
  boxsep=5pt,
  arc=4pt}

% tip
\newenvironment{tip}[1][Title]
  {
  \setlength{\fboxsep}{1em}
  \begin{mybox}[tip-line]
    \raisebox{-.2\height}{\includegraphics[height=.6cm]{images/lightbulb.png}} \large \textcolor{tip-text}{Tip-Box: #1}\\
    }
    {
  \end{mybox}
  }

% warning
\newenvironment{warning}[1][Title]
  {
  \setlength{\fboxsep}{1em}
  \begin{mybox}[warning-line]
    \raisebox{-.2\height}{\includegraphics[height=.6cm]{images/gotcha.png}} \large \textcolor{warning-text}{Warning-Box: #1}\\
    }
    {
  \end{mybox}
  }

% deffun
\newenvironment{deffun}[1][Title]
  {
  \setlength{\fboxsep}{1em}
  \begin{mybox}[deffun-line]
    \raisebox{-.2\height}{\includegraphics[height=.6cm]{images/gears.png}} \large \textcolor{deffun-text}{Definition-Box: #1}\\
    }
    {
  \end{mybox}
  }

% design
\newenvironment{design}[1][Title]
  {
  \setlength{\fboxsep}{1em}
  \begin{mybox}[design-line]
    \raisebox{-.2\height}{\includegraphics[height=.6cm]{images/design.png}} \large \textcolor{design-text}{Approfondimento: #1}\\
    }
    {
  \end{mybox}
  }

% trick
\newenvironment{trick}[1][Title]
  {
  \setlength{\fboxsep}{1em}
  \begin{mybox}[trick-line]
    \raisebox{-.2\height}{\includegraphics[height=.6cm]{images/hat.png}} \large \textcolor{trick-text}{Trick-Box: #1}\\
    }
    {
  \end{mybox}
  }
\usepackage{titlepic}
\titlepic{\includegraphics[width=\textwidth]{images/logo_psicostat.pdf}}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{multirow}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{colortbl}
\usepackage{pdflscape}
\usepackage{tabu}
\usepackage{threeparttable}
\usepackage{threeparttablex}
\usepackage[normalem]{ulem}
\usepackage{makecell}
\usepackage{xcolor}
\usepackage[]{natbib}
\bibliographystyle{plainnat}

\title{{Introduction to R}}
\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\subtitle{Corso per imparare le basi di \textbf{R}}
\author{\href{https://claudiozandonella.netlify.app/}{Claudio Zandonella Callegher} and \href{https://filippogambarota.netlify.app/}{Filippo Gambarota} members of \href{https://psicostat.dpss.psy.unipd.it/}{Psicostat}}
\date{07-04-2021}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{presentazione}{%
\chapter*{Presentazione}\label{presentazione}}
\addcontentsline{toc}{chapter}{Presentazione}

In questo libro impareremo le basi di \emph{R}, uno dei migliori software per la visualizzazione e l'analisi statistica dei dati. Partiremo da zero intorducendo gli aspetti fondamentili di R e i concetti alla base di ogni linguaggio di programmazione che ti pemetteranno in seguito di approfondire e sviluppare le tue abilità in questo bellissimo mondo.

\hypertarget{perchuxe8-r}{%
\section*{Perchè R}\label{perchuxe8-r}}
\addcontentsline{toc}{section}{Perchè R}

Ci sono molte ragioni per cui scegliere R rispetto ad altri programmi usati per condurre le analisi statistiche. Innanzitutto è un linguaggio di programmazione (come ad esempio Python, Java, C++, o Julia) e non semplicemente un'interfaccia punta e clicca (come ad esempio SPSS o JASP). Questo comporta si maggiori difficoltà iniziali ma ti ricompenserà in futuro poichè avari imparato ad utilizza uno strumennto molto potente.

Inoltre, R è:

\begin{itemize}
\tightlist
\item
  nato per la statistica
\item
  open-source
\item
  ricco di pacchetti
\item
  supportato da una grande community
\item
  gratis
\end{itemize}

\hypertarget{struttura-del-libro}{%
\section*{Struttura del libro}\label{struttura-del-libro}}
\addcontentsline{toc}{section}{Struttura del libro}

Il libro è suddiviso in quattro sezioni principali:

\begin{itemize}
\tightlist
\item
  \textbf{Get started}. Una volta installato R ed RStudio, famiglierizzeremo con l'ambiente di lavoro introducendo alcuni aspetti generali e le funzioni principali. Verranno inoltre descritte alcune buone regole per iniziare una sessione di lavoro in R.
\item
  \textbf{Struttura dei dati}. Impareremo gli oggetti principali che R utilizza al suo interno. Variabili, vettori, matrici, dataframe e liste non avranno più segreti e capiremo come manipolarli e utlizzarli a seconda delle varie necessità.
\item
  \textbf{Algoritmi}. Non farti spaventare da questo nome. Ne avrai spesso sentito parlarne come qualcosa di molto complicato, ma in realtà gli algoritmi sono semplicemente una serie di istruzioni che il computer segue quando deve eseguire un determinato compito. In questa sezione vedremo i principali comandi di R usati per definire degli algoritmi. Questo è il vantaggio di conoscere un linguaggio di programmazione, ci permette di creare nuovi programmi che il computer eseguirà per noi.
\item
  \textbf{Case study}. Eseguiremo passo per passo un analisi che ci permetterà di imparare come importare i dati, codificare le variabili, manipolare e preprare i dati perle analisi, condurre delle analisi descrittive e creare dei grafici.
\end{itemize}

Alla fine di questo libro probabilmente non sarete assunti da Google, ma speriamo almeno che R non vi faccia più così paura e che magari a qualcuno sia nato l'interesse di approfondire questo fantastico mondo fatto di linee di codice.

\hypertarget{risorse-utili}{%
\section*{Risorse Utili}\label{risorse-utili}}
\addcontentsline{toc}{section}{Risorse Utili}

Segnaliamo qui per il lettore interessato del materiale online (in inglese) per approfondire le conoscenze sull'uso di R.

Materiale introduttivo:

\begin{itemize}
\tightlist
\item
  \emph{R for Psychological Science} di Danielle Navarro \url{https://psyr.djnavarro.net/index.html}
\item
  \emph{Hands-On Programming with R} di Garrett Grolemund \url{https://rstudio-education.github.io/hopr/}
\end{itemize}

Materiale intermedio:

\begin{itemize}
\tightlist
\item
  \emph{R for Data Science} di Hadley Wickham e Garrett Grolemund \url{https://r4ds.had.co.nz/}
\end{itemize}

Materiale avanzato:

\begin{itemize}
\tightlist
\item
  \emph{R Packages} di Hadley Wickham e Jennifer Bryan \url{https://r-pkgs.org/}
\item
  \emph{Advanced R} di Hadley Wickham \url{https://adv-r.hadley.nz/}
\end{itemize}

\hypertarget{psicostat}{%
\section*{Psicostat}\label{psicostat}}
\addcontentsline{toc}{section}{Psicostat}

Questo libro è stato prodotto da \href{https://claudiozandonella.netlify.app/}{Claudio Zandonella Callegher} and \href{https://filippogambarota.netlify.app/}{Filippo Gambarota}, membri di \textbf{Psicostat}. Un gruppo di ricerca interdisciplinare dell'universita di Padova che unisce la passione per la statistica e la psicologia. Se vuoi conoscere di più riguardo le nostre attività visita il nosto sito \url{https://psicostat.dpss.psy.unipd.it/} o aggiungiti alla nostra mailing list \url{https://lists.dpss.psy.unipd.it/postorius/lists/psicostat.lists.dpss.psy.unipd.it/}.

\hypertarget{collaborazione}{%
\section*{Collaborazione}\label{collaborazione}}
\addcontentsline{toc}{section}{Collaborazione}

Se vuoi collaborare alla revione e scrittura di questo libro (ovviamente è tutto in R) visita la nostra repository di Github \url{https://github.com/psicostat/Introduction2R}.

\hypertarget{riconoscimenti}{%
\section*{Riconoscimenti}\label{riconoscimenti}}
\addcontentsline{toc}{section}{Riconoscimenti}

Il template di questo libro è basato su \href{https://github.com/rstudio/bookdown-demo}{Rstudio Bookdown-demo} rilasciato con licenza \href{https://creativecommons.org/publicdomain/zero/1.0/}{CC0-1.0} e \href{https://rstudio4edu.github.io/rstudio4edu-book/}{rstudio4edu-book} rilasciato con licenza \href{https://creativecommons.org/licenses/by/2.0/}{CC BY}. Nota che le illustrazioni utilizzate nelle vignette appartengono sempre a \href{https://rstudio4edu.github.io/rstudio4edu-book/}{rstudio4edu-book} e sono rilasciate con licenza \href{https://creativecommons.org/licenses/by-nc/2.0/}{CC BY-NC}.

\hypertarget{licenza}{%
\section*{Licenza}\label{licenza}}
\addcontentsline{toc}{section}{Licenza}

Questo libro è rilasciato sotto la Creative Commons Attribution-ShareAlike 4.0 International Public License (\href{https://creativecommons.org/licenses/by-sa/4.0/legalcode}{CC BY-SA}).
Le illustrazioni utilizzate nelle vignette appartengono a \href{https://rstudio4edu.github.io/rstudio4edu-book/}{rstudio4edu-book} e sono rilasciate con licenza \href{https://creativecommons.org/licenses/by-nc/2.0/}{CC BY-NC}.

\hypertarget{part-get-started}{%
\part*{Get Started}\label{part-get-started}}
\addcontentsline{toc}{part}{Get Started}

\hypertarget{introduzione}{%
\chapter*{Introduzione}\label{introduzione}}
\addcontentsline{toc}{chapter}{Introduzione}

In questa sezione verranno prima presentate le istruzioni per installare R ed RStudio. Successivamente, svolgeremo le prime oprazioni in R e famiglierizzeremo con dei concetti di base della programmazioene quali gli oggetti e le funzioni. Introdurremmo infine altri concetti relativi alle sessioni di lavoro in R e descriveremo alcune buone regole per nell'utilizzo di R.

I capitoli sono così organizzati:

\begin{itemize}
\tightlist
\item
  \textbf{Capitolo \ref{install} - Installare R e RStudio}. Instruzioni passo a passo per installare R e RStudio
\item
  \textbf{Capitolo \ref{rstudio-gui} - Interfaccia RStudio}. Introduzione all'interfaccia utente di RStudio.
\item
  \textbf{Capitolo \ref{first-comands} - Primi Passi in R}. Operatori matematici, operatori relazionali, operatori logici.
\item
  \textbf{Capitolo \ref{objects-functions} - Due Compagni Inseparabili}. Introduzione dei concetti di oggetti e funzioni in R.
\item
  \textbf{Capitolo \ref{working-environment} - Ambiente di Lavoro}. Introduzione dei concetti di Envieronment, working directory e dei pacchetti di R.
\item
  \textbf{Capitolo \ref{working-session} - Sessione di Lavoro}. Descrizione di buone pratiche nelle sessioni di lavoro e gestione degli errori.
\end{itemize}

\hypertarget{install}{%
\chapter{Installare R e RStudio}\label{install}}

R ed R-studio sono due software distinti. R è un linguaggio di programmazione usato in particolare in ambiti quali la statistica. R-studio invece è un'interfaccia \emph{user-friendly} che permette di utilizzare R.
R può essere utilizzato autonomamente tuttavia è consigliato l'utilizzo attraverso R-studio. Entrambi vanno installati separatamente e la procedura varia a seconda del proprio sistema operativo (Windows, MacOS o Linux). Riportiamo le istruzioni solo per Windows e MacOS Linux (Ubuntu). Ovviamente R è disponibile per tutte le principali distribuzioni di Linux. Le istruzioni riportate per Ubuntu (la distribuzione più diffusa) sono valide anche per le distribuzioni derivate.

\hypertarget{install-r}{%
\section{Installare R}\label{install-r}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Accedere al sito \url{https://www.r-project.org}
\item
  Selezionare la voce \textbf{CRAN} (Comprehensive R Archive Network) dal menù di sinistra sotto \textbf{Download}
\end{enumerate}

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install_CRAN.png}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Selezionare il primo link \url{https://cloud.r-project.org/}
\end{enumerate}

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install_mirror.png}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Selezionare il proprio sistema operativo
\end{enumerate}

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install_OS.png}

\hypertarget{r-windows}{%
\subsection{R Windows}\label{r-windows}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Selezionare la voce \textbf{base}
\end{enumerate}

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install-Windows-base.png}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Selezionare la voce \textbf{Download} della versione più recente di R disponibile
\end{enumerate}

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install-Windows-version.png}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Al termine del download, eseguire il file e seguire le istruzioni fino al termine dell'installazione
\end{enumerate}

\hypertarget{r-macos}{%
\subsection{R MacOS}\label{r-macos}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Selezionare della versione più recente di R disponibile
\end{enumerate}

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install_Mac_version.png}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Al termine del download, eseguire il file e seguire le istruzioni fino al termine dell'installazione di R
\item
  Successivamente è necessario installare anche una componente aggiuntiva \textbf{XQuartz} premendo il link all'interno del riquadro arancione riportato nella figura precedente
\item
  Selezionare la voce Download
\end{enumerate}

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install_Mac_XQuartz.png}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Al termine del download, eseguire il file e seguire le istruzioni fino al termine dell'installazione
\end{enumerate}

\hypertarget{r-linux}{%
\subsection{R Linux}\label{r-linux}}

Nonostante la semplicità di installazione di pacchetti su Linux, R a volte potrebbe essere più complicato da installare per via delle diverse distribuzioni, repository e chiavi per riconoscere la repository come sicura.

Sul \textbf{CRAN} vi è la guida ufficiale con tutti i comandi \texttt{apt} da eseguire da terminale. Seguendo questi passaggi non dovrebbero esserci problemi.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Andate sul \href{https://cran.r-project.org/}{CRAN}
\item
  Cliccate \texttt{Download\ R\ for\ Linux}
\item
  Selezionate la vostra distribuzione (Ubuntu in questo caso)
\item
  Seguite le istruzioni, principalmente eseguendo i comandi da terminale suggeriti
\end{enumerate}

Per qualsiasi difficoltà o errore, sopratutto con il mondo Linux, una ricerca su online risolve sempre il problema.

\begin{design}[R Tools]

Utilizzi avanzati di R richiedono l'insallazione di una serie ulteriore software definiti \textbf{R tools}.

\hypertarget{windows}{%
\subsubsection*{Windows}\label{windows}}
\addcontentsline{toc}{subsubsection}{Windows}

Seleziona la voce \textbf{Rtools} e segui le istruzioni per completare l'installazione.

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install-Windows-tools.png}

Nota che sono richieste anche delle operazioni di configurazione affinchè tutto funzioni correttamente.

\hypertarget{macos}{%
\subsubsection*{MacOS}\label{macos}}
\addcontentsline{toc}{subsubsection}{MacOS}

Seleziona la voce \textbf{tools} e segui le istruzioni riportate.

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install_Mac_tools.png}

Nota in particolare che con R 4.0 le seguenti indicazioni sono riportate.

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install_Mac_tools2.png}

\end{design}

\hypertarget{installare-r-studio}{%
\section{Installare R Studio}\label{installare-r-studio}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Accedere al sito \url{https://rstudio.com}
\item
  Selezionare la voce \textbf{DOWNLOAD IT NOW}
\end{enumerate}

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install_rstudio1.png}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Selezionare la versione gratuita di RStudio Desktop
\end{enumerate}

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install_rstudio2.png}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Selezionare la versione corretta a seconda del proprio sistema operativo
\end{enumerate}

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install_rstudio3.png}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Al termine del download, eseguire il file e seguire le istruzioni fino al termine dell'installazione
\end{enumerate}

\hypertarget{r-studio-in-linux}{%
\subsection{R Studio in Linux}\label{r-studio-in-linux}}

In questo caso, come su Windows e MacOS l'installazione consiste nello scaricare ed eseguire il file corretto, in base alla distribuzione (ad esempio \texttt{.deb} per Ubuntu e derivate). Importante, nel caso di Ubuntu (ma dovrebbe valere anche per le altre distribuzioni) anche versioni successive a quella indicata (es. Ubuntu 16) sono perfettamente compatibili.

\hypertarget{rstudio-gui}{%
\chapter{Interfaccia RStudio}\label{rstudio-gui}}

In questo capitolo presenteremo l'interfaccia utente di RStudio. Molti aspetti che introdurremo brevemente qui verranno discussi nei sucessivi capitoli. Adesso ci interessa solo famigliarizzare con l'interfaccia del nostro strumento di lavoro principale ovvero RStudio.

Come abbiamo visto nel Capitolo \ref{install}, R è il vero ``motore computazionale'' che ci permette di compiere tutte le operazioni di calcolo, analisi statistiche e magie varie. Tuttavia l'interfaccia di base di R, definita \textbf{Console} (vedi Figura \ref{fig:r-console}), è per così dire \emph{démodé} o meglio, solo per veri intenditori.

\begin{figure}

{\centering \includegraphics[width=0.85\linewidth]{images/r-console} 

}

\caption{La console di R, solo per veri intenditori}\label{fig:r-console}
\end{figure}

In genere, per lavorare con R viene utilizzato RStudio. RStudio è un programma (IDE - Integrated Development Environment) che integra in un unica interfaccia utente (GUI - Graphical User Interface) diversi strumenti utili per la scrittura ed esecuzione di codici. L'interfaccia di RStudio è costituita da 4 pannelli principali (vedi Figura \ref{fig:rstudio-gui}):

\begin{figure}

{\centering \includegraphics[width=0.85\linewidth]{images/rstudio-gui} 

}

\caption{Interfaccia utente di Rstudio con i suoi 4 pannelli}\label{fig:rstudio-gui}
\end{figure}

\begin{design}[R-Basic vs RStudio]

L'utilizzo di R attraverso l'interfaccia di base piuttosto che RStudio, non è uno scontro tra due scuole di pensiero (o generazioni). Entrambe hanno vantaggi e svantaggi e pertanto vengono scelte a seconda delle dieverse necessità.

Quando si è alla ricerca della massima ottimizzazione, l'uso dell'interfaccia di base, grazie alla sua semplicità, permette di minimizzare l'utilizzo della memoria limitandosi allo stretto e necessario.

In altri casi, invece, le funzionalità e strumenti aggiuntivi di RStudio permettono una maggiore efficacia nel proprio lavoro.

\end{design}

\hypertarget{console-il-cuore-di-r}{%
\subsubsection*{1. Console: il cuore di R}\label{console-il-cuore-di-r}}
\addcontentsline{toc}{subsubsection}{1. Console: il cuore di R}

Qui ritroviamo la \emph{Console} di R dove vengono effetivemente eseguiti tutti i tuoi codici e comandi. Nota come nell'ulitma riga della \emph{Console} appaia il carattere \texttt{\textgreater{}}. Questo è definito \emph{prompt} è ci indica che R in attesa di nuovi comandi da eseguire.

La \emph{Console} di R è un'interfaccia a linea di comando. A differenza di altri programmi ``\emph{punta e clicca}'', in R è necessario digitare i comandi utilizzando la tastiera. Per eseguire dei comandi possiamo direttamnte scrivere nella \emph{Console} le operazioni da eseguire e premere \texttt{invio}. R eseguirà immediatamente i nostro comando, riporterà il risultato e nella linea successiva apparirà nuovamente il \emph{prompt} indicando che R è pronto ad eseguire un altro comando (vedi Figura \ref{fig:comand-sequence}).

\begin{figure}

{\centering \includegraphics[width=0.95\linewidth]{images/comand-sequence} 

}

\caption{Esecuzione di comandi direttamente nella console}\label{fig:comand-sequence}
\end{figure}

Nel caso di comandi scritti su più righe, vedi l'esempio di Figura \ref{fig:multiple-line-comand}, è possibile notare come venga mostrato il simbolo \texttt{+} come \emph{prompt}. Questo indica che R è in attesa che l'intero comando venga digitato prima che esso venga eseguito.

\begin{figure}

{\centering \includegraphics[width=0.95\linewidth]{images/multiple-line-comand} 

}

\caption{Esecuzione di un comando su più righe}\label{fig:multiple-line-comand}
\end{figure}

Come avrai notato facendo alcune prove, i comandi digitati nella \emph{Console} vengono eseguiti immediatamente ma non sono salvati. Per rieseguire un comando, possiamo navigare tra quelli precedentementemente eseguiti usando le freccie della tastiera \(\uparrow\downarrow\). Tuttavia, in caso di errori dovremmo riscrivere e rieseguire tutti i comandi. Siccome scrivere codici è un continuo ``\emph{try and error}'', lavorare unicamente dalla \emph{Console} diventa presto caotico. Abbiamo bisogno quindi di una soluzione che ci permetta di lavrorare più comodamente sui nostri codici e di poter salvare i nostri comandi da eseguire all'occorrenza con il giusto ordine. La soluzione sono gli \emph{Scripts} che introdurremo vedremo nella prossima sezione.

\begin{tip}[Interrompere un comando]

Potrebbe accadere che per qualche errore nel digitare un comando o perchè sono richiesti lunghi tempi computazionali, la \emph{Console} di R diventi non responsiva. In questo caso è necessario interrompere la scrittura o l'esecuzione di un comando. Vediamo due situazioni comuni:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Continua a comparire il prompt} \texttt{+}. Specialmente nel caso di utilizzo di parentesi e lunghi comandi, accade che una volta premuto \texttt{invio} R non esegua alcun comando ma resta in attesa mostrando il \emph{prompt} \texttt{+} (vedi Figure seguente). Questo è in genere dato da un errore nella sintassi del comando (e.g., un errore nell'uso delle parentesi o delle virgole). Per riprendere la sessione è necessario premere il tasto \texttt{esc} della tastiera. L'apprire del \emph{prompt} \texttt{\textgreater{}}, indica che R è nuovamente in ascolto pronto per esequire un nuovo comando ma attento a non ripetere lo stesso errore, la sintassi dei comandi è importante (vedi Capitolo TODO).
\end{enumerate}

\begin{center}\includegraphics[width=0.95\linewidth]{images/comand-esc} \end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  \textbf{R non risponde}. Alcuni calcoli potrebbero richiedere molto tempo o semplicemnte un qualche problema ha mandato in loop la tua sessione di lavoro. In questa situazione la \emph{Console} di R diventa non responsiva. Nel caso fosse necessario interrompere i processi attualmente in esecuzione devi premere il pulsante \emph{STOP} come indicato nella Figura seguente. R si fermerà e ritornerà in attesa di nuovi comandi (\emph{prompt} \texttt{\textgreater{}}).
\end{enumerate}

\begin{center}\includegraphics[width=0.95\linewidth]{images/console-stop} \end{center}

\end{tip}

\begin{trick}[Force Quit]

In alcuni casi estremi in cui R sembra non rispondere, usa i comandi \texttt{Ctrl-C} per forzare R a interrompere il processo in esecuzione.

Come ultima soluzione ricorda uno dei principi base dell'informatica ``\emph{spegni e riaccendi}'' (a volte potrebbe bastare chiudere e riaprire RStudio).

\end{trick}

\hypertarget{source-il-tuo-blocco-appunti}{%
\subsubsection*{2. Source: il tuo blocco appunti}\label{source-il-tuo-blocco-appunti}}
\addcontentsline{toc}{subsubsection}{2. Source: il tuo blocco appunti}

In questa parte vengono mostrati i tuoi \emph{Scripts}. Questi non sono altro che degli speciali documenti (con estensione ``\textbf{.R}'') in cui sono salvati i tuoi codici e comandi che potrai eseguire quando necessario in R. Gli \emph{Scripts} ti permetteranno di lavorare comodamente sui tuoi codici, scrivere i comandi, corregerli, organizzarli, aggiungere dei commenti e soprattutto salvarli.

Dopo aver terminato di scrivere i comandi, posiziona il cursore sulla stessa linea del comando che desideri eseguire e premi \texttt{command\ +\ invio} (MacOs) o \texttt{Ctrl+R} (Windows). Automaticamente il comando verà copiato nella \emph{Console} ed eseguito. In alternativa potrai premere il tasto \textbf{Run} indicato dalla freccia in Figura \ref{fig:script-run}.

\begin{figure}

{\centering \includegraphics[width=0.95\linewidth]{images/script-run} 

}

\caption{Esecuzione di un comando da script premi `command + invio` (MacOs)/ `Ctrl+R` (Windows) o premi il tasto indicato dalla freccia}\label{fig:script-run}
\end{figure}

\begin{tip}[Commenti]

Se hai guardato con attenzione lo script rappresentato in Figura \ref{fig:script-run}, potresti aver notato delle righe di testo verde precedute dal simbolo \texttt{\#}. Questo simbolo può essere utlizzato per inserire dei \emph{commenti} all'interno dello script. R ignorerà qualsiasi commento ed eseguirà soltato le parti di codici.

L'utilizzo dei commenti è molto importante nel caso di script complessi poichè ci permette di spiegare e documentare il codice che viene eseguito. Nel Capitolo TODO approfondiremo il loro utilizzo.

\end{tip}

\begin{design}[Creare e Salvare uno Script]

Per creare un nuovo script è sufficiente premere il pulsante in alto a sinistra come mostrato in Figura e selezionare \emph{``R Script''}.

\includegraphics[width=0.75\textwidth,height=\textheight]{images/script-new.png}

Unn nuovo script senza nome verrà creato. Per salvare lo script premere l'icona del floppy e indicare il nome. Ricorda di usare l'estensione ``\textbf{.R}'' per salvare gli script.

\includegraphics[width=0.75\textwidth,height=\textheight]{images/script-save.png}

\end{design}

\hypertarget{environment-e-history-la-sessione-di-lavoro}{%
\subsubsection*{3. Environment e History: la sessione di lavoro}\label{environment-e-history-la-sessione-di-lavoro}}
\addcontentsline{toc}{subsubsection}{3. Environment e History: la sessione di lavoro}

Qui sono presentati una serie di pannelli utili per valutare informazioni inerenti alla propria sessione di lavoro. I pannelli principali sono \emph{Environment} e \emph{History} (gli altri pannelli presenti in Figura \ref{fig:environment} riguardanno funzioni avanzate di RStudio).

\begin{itemize}
\tightlist
\item
  \textbf{Environment}: elenco tutti gli oggetti e variabili attualmente presenti nel'ambiente di lavoro. Approfondiremo i concetti di variabili e di ambiente di lavoro rispettivamente nel Capitolo \ref{objects-functions} e Capitolo TODO.
\end{itemize}

\begin{figure}

{\centering \includegraphics[width=0.6\linewidth]{images/environment} 

}

\caption{*Environment* - Elenco degli oggetti e variabili presenti nel'ambiente di lavoro}\label{fig:environment}
\end{figure}

\begin{itemize}
\tightlist
\item
  \textbf{History}: elenco di tutti i comandi precedentemente eseguiti nella console. Nota che questo no equivale ad uno script, anzi, è semplicemente un elenco non modificabile (e quasi mai usato).
\end{itemize}

\hypertarget{file-plots-package-help-system-management}{%
\subsubsection*{4. File, Plots, Package, Help: system management}\label{file-plots-package-help-system-management}}
\addcontentsline{toc}{subsubsection}{4. File, Plots, Package, Help: system management}

In questa parte sono raccolti una serie di pannelli utilizzatti per interfacciarsi con ulteriori risorse del sistema (e.g., file e pacchetti) o produrre output quali grafici e tabelle.

\begin{itemize}
\tightlist
\item
  \textbf{Files}: pannello da cui è possibile navigare tra tutti i file del proprio computer
\end{itemize}

\begin{figure}

{\centering \includegraphics[width=0.6\linewidth]{images/files} 

}

\caption{*Files* - permette di navigare tra i file del proprio computer}\label{fig:files}
\end{figure}

\begin{itemize}
\tightlist
\item
  \textbf{Plots}: pannello i cui vengono prodotti i grafici e che è possibil esportare cliccando \emph{Export}.
\end{itemize}

\begin{figure}

{\centering \includegraphics[width=0.6\linewidth]{images/plots} 

}

\caption{*Plots* - presentazione dei grafici}\label{fig:plots}
\end{figure}

\begin{itemize}
\tightlist
\item
  \textbf{Packages}: elenco dei pacchetti di R (questo argomento verrà approfondito nel Capitolo TODO).
\end{itemize}

\begin{figure}

{\centering \includegraphics[width=0.6\linewidth]{images/packages} 

}

\caption{*Packages* - elenco dei pacchetti di R}\label{fig:packages}
\end{figure}

\begin{itemize}
\tightlist
\item
  \textbf{Help}: utilizzato per navigare la documentazione interna di R (questo argomento verrà approfondito nel Capitolo TODO).
\end{itemize}

\begin{figure}

{\centering \includegraphics[width=0.6\linewidth]{images/help} 

}

\caption{*Help* -  documentazione di R}\label{fig:help}
\end{figure}

\begin{tip}[Personalizza tema e layout]

RStudio permette un ampio grado di personalizzazione dell'intrafaccia grafica utilizzata. E' possibile cambiare tema, font e disposizione dei pannelli a seconda dei tuoi gusti ed esigenze.

Prova a cambiare il tema dell editor in \emph{Idle Fingers} per utlizzare on background scuro che affatichi meno la vista (vedi Figura seguente). Clicca su RStudio \textgreater{} Preferenze \textgreater{} Appearence (MacOS) o Tools \textgreater{} Options \textgreater{} Appearence (Windows).

\begin{center}\includegraphics[width=0.9\linewidth]{images/dark-theme} \end{center}

\end{tip}

\hypertarget{first-comands}{%
\chapter{Primi Passi in R}\label{first-comands}}

Ora che abbiamo iniziato a famigliarizzare con il nostro stumento di lavoro possiamo finalmente dare fuoco alle polveri e concentraci sulla scrittura di codici!

In questo capitolo muoveremo i primi passi in R. Inizieremo vedendo come utilizzare operatori matematici, relazionali e logici per compiere semplici operazioni in R. Imparare R è un lungo percorso (scoop: questo percorso non termina mai dato che R è sempre in continuo sviiluppo). Soprattutto all'inizio può sembrare eccessivamente difficile poichè è si incontrano per la prima volta molti comandi e concetti di programmazione. Tuttavia, una volta famigliarizzato con gli apetti di base, la progressione diventa sempre più veloce (inarrestabile direi!).

In questo capitolo introdurremo per la prima volta molti elementi che saranno poi ripresi e approfonditi nei seguenti capitoli. Quindi non preoccuparti se non tutto ti sarà chiaro fin da subito. Imparare il tuo primo linguaggio di programmazione è difficile ma da qualche parte bisogna pure iniziare. Pronto per le tue prime linee di codice? Let's become a useR!

\hypertarget{math-operators}{%
\section{Operatori Matematici}\label{math-operators}}

R è un'ottima calcolatrice. Nella Tabella \ref{tab:table-math-operators} sono elencati i principali operatori matematici e funzioni usate in R.

\begin{table}[!h]

\caption{\label{tab:table-math-operators}Operatori Matematici}
\centering
\begin{tabular}[t]{l|l|l}
\hline
Funzione & Nome & Esempio\\
\hline
\texttt{x + y} & Addizione & \texttt{\makecell[l]{> 5 + 3 \\{[1]} 8}}\\
\hline
\texttt{x - y} & Sottrazione & \texttt{\makecell[l]{> 7 - 2 \\{[1]} 5}}\\
\hline
\texttt{x * y} & Moltiplicazione & \texttt{\makecell[l]{> 4 * 3 \\{[1]} 12}}\\
\hline
\texttt{x / y} & Divisione & \texttt{\makecell[l]{> 8 / 3 \\{[1]} 2.666667}}\\
\hline
\texttt{x \%\% y} & Resto della divisione & \texttt{\makecell[l]{> 7 \%\% 5 \\{[1]} 2}}\\
\hline
\texttt{x \%/\% y} & Divisione intera & \texttt{\makecell[l]{> 7 \%/\% 5 \\{[1]} 1}}\\
\hline
\texttt{x \^{} y} & Potenza & \texttt{\makecell[l]{> 3\^{}3 \\{[1]} 27}}\\
\hline
\texttt{abs(x)} & Valore assoluto & \texttt{\makecell[l]{> abs(3-5\^{}2) \\{[1]} 22}}\\
\hline
\texttt{sign(x)} & Segno di un'espressione & \texttt{\makecell[l]{> sign(-8) \\{[1]} -1}}\\
\hline
\texttt{sqrt(x)} & Radice quadrata & \texttt{\makecell[l]{> sqrt(25) \\{[1]} 5}}\\
\hline
\texttt{log(x)} & Logaritmo naturale & \texttt{\makecell[l]{> log(10) \\{[1]} 2.302585}}\\
\hline
\texttt{exp(x)} & Esponenziale & \texttt{\makecell[l]{> exp(1) \\{[1]} 2.718282}}\\
\hline
\texttt{\makecell[l]{sin(x)\\cos(x)\\tan(x)\\asin(x)\\acos(x)\\atan(x)}} & Funzioni trigonometriche & \texttt{\makecell[l]{ >sin(pi/2) \\{[1]}1 \\>cos(pi/2) \\{[1]}6.123234e-17}}\\
\hline
\texttt{factorial(x)} & Fattoriale & \texttt{\makecell[l]{> factorial(6) \\{[1]} 720}}\\
\hline
\texttt{choose(n, k)} & Coefficiente binomiale & \texttt{\makecell[l]{> choose(5,3) \\{[1]} 10}}\\
\hline
\end{tabular}
\end{table}

\begin{tip}[Le prime funzioni]

Nota come per svolgere operazioni come la radice quadrata o il valore assoluto vengono utlizzate delle specifiche funzioni. In R le funzioni sono richiamate digitando \texttt{\textless{}nome-funnzione\textgreater{}()} (e.g., \texttt{sqrt(25)}) indicando all'interno delle parentesi tonde gli argomenti della funzione. Approfondiremo le funzioni nel Capitolo \ref{functions-def}.

\end{tip}

\hypertarget{ordine-operazioni}{%
\subsection{Ordine Operazioni}\label{ordine-operazioni}}

Nello svolgere le operazioni, R segue lo stesso l'ordine usato nelle normali espressioni matematiche. Quindi l'ordine di precedenza degli operatori è:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{\^{}} (potenza)
\item
  \texttt{\%\%} (resto della divisione) e \texttt{\%/\%} (divisione intera)
\item
  \texttt{*} (moltiplicazione) e \texttt{/}(divisione)
\item
  \texttt{+} (addizione) e \texttt{-}(sotttrazione)
\end{enumerate}

Nota che in presenza di funzioni (e.g., \texttt{abs()}, \texttt{sin()}), R per prima cosa sostituisca le funzioni con il loro risultato per poi procedere con l'esecuzione delle operazioni nell'ordine indicato precedentemente.

L'ordine di esecuzione delle operazioni può essere controllato attraverso l'uso delle \textbf{parentesi tondone} \texttt{()}. R eseguirà tutte le operazioni incluse nelle parentesi seguendo lo stesso ordine inndicato sopra. Utilizzando più gruppi di parentesi possiamo ottenere i risultati desiderati.

\begin{warning}[Le parentesi]

Nota che in R solo le \textbf{parentesi tonde} \texttt{()} sono utilizzate per gestire l'ordine con cui sono eseguite le oprazioni.

\textbf{Parentesi quadre} \texttt{{[}{]}} e \textbf{parentesi graffe} \texttt{\{\}} sono invece speciali operatori utilizzati in R per altre ragioni come la selezione di elemente e la definizione di blocchi di codici. Argomenti che approfondiremo rispettivamente nel Capitolo TODO e Capitolo TODO.

\end{warning}

\hypertarget{esercizi}{%
\subsection*{Esercizi}\label{esercizi}}
\addcontentsline{toc}{subsection}{Esercizi}

Calcola il risultato delle seguenti operazioni utilizzando R (\href{https://github.com/psicostat/Introduction2R/blob/master/exercises/chapter-03-first-comands.R}{soluzioni}):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \(\frac{(45+21)^3+\frac{3}{4}}{\sqrt{32-\frac{12}{17}}}\)
\item
  \(\frac{\sqrt{7-\pi}}{3\ (45-34)}\)
\item
  \(\sqrt[3]{12-e^2}+\ln(10\pi)\)
\item
  \(\frac{\sin(\frac{3}{4}\pi)^2+\cos(\frac{3}{2}\pi)}{\log_7{e^{\frac{3}{2}}}}\)
\item
  \(\frac{\sum_{n=1}^{10} n}{10}\)
\end{enumerate}

Note per la risoluzione degli esercizi:

\begin{itemize}
\tightlist
\item
  In R la radice quadrata si ottine con la funzione \texttt{sqrt()} mentre per radici di indici diversi si utilizza la notazione esponenziale (\(\sqrt[3]{x}\) è dato da \texttt{x\^{}(1/3)}).
\item
  Il valore di \(\pi\) si ottiene con \texttt{pi}.
\item
  Il valore di \(e\) si ottiene con \texttt{exp(1)}.
\item
  In R per i logaritmi si usa la funzione \texttt{log(x,\ base=a)}, di base viene considerato il logaritmo naturale.
\end{itemize}

\hypertarget{operators-rel-log}{%
\section{Operatori Relazionali e Logici}\label{operators-rel-log}}

Queste operazioni al momento potrebbero sembrare non particolrmente interessanti ma si riveleranno molto utili nei capitoli successivi ad esempio per la selezione di elementi (vedi Capitolo TODO) o la definizionne di algoritmi (vedi Capitolo TODO).

\hypertarget{operatori-relazionali}{%
\subsection{Operatori Relazionali}\label{operatori-relazionali}}

In R è possibile valutare se una data relazione è vera o falsa. Ad esempio, posiamo valutare se ``\emph{2 è minore di 10}'' o se ``\emph{4 numero è un numero pari}''.

R valuterà le proposizioni e ci restituirà il valore \texttt{TRUE} se la proposizione è vera oppure \texttt{FALSE} se la proposizione è falsa. Nella Tabella \ref{tab:relational-operators} sono elencati gli operatori relazionali.

\begin{table}[!h]

\caption{\label{tab:relational-operators}Operatori Relazionali}
\centering
\begin{tabular}[t]{l|l|l}
\hline
Funzione & Nome & Esempio\\
\hline
\texttt{x == y} & Uguale & \texttt{\makecell[l]{> 5 == 3 \\{[1]} FALSE}}\\
\hline
\texttt{x != y} & Diverso & \texttt{\makecell[l]{> 7 != 2 \\{[1]} TRUE}}\\
\hline
\texttt{x > y} & Maggiore & \texttt{\makecell[l]{> 4 > 3 \\{[1]} TRUE}}\\
\hline
\texttt{x >= y} & Maggiore o uguale & \texttt{\makecell[l]{> -2 >= 3 \\{[1]} FALSE}}\\
\hline
\texttt{x < y} & Minore & \texttt{\makecell[l]{> 7 < 5 \\{[1]} FALSE}}\\
\hline
\texttt{x <= y} & Minore o uguale & \texttt{\makecell[l]{> 7 <= 7 \\{[1]} TRUE}}\\
\hline
\texttt{x \%in\% y} & inclusione & \texttt{\makecell[l]{> 5 \%in\% c(3, 5, 8) \\{[1]} TRUE}}\\
\hline
\end{tabular}
\end{table}

\begin{warning}['==' non è uguale a '=']

Attenzione che per valutare l'uguaglianza tra due valori non bisogna utilizzare \texttt{=} ma \texttt{==}. Questo è un'errore molto comune ceh si commmette in continuazione.

L'operatore \texttt{=} è utilizzato in R per assegnare un valore ad una variablie. Argomento che vederemo nella Sezione TODO

\end{warning}

\begin{tip}[TRUE-T-1; FALSE-F-0]

Nota che in qualsiasi linguaggio di Programmazione, ai valori TRUE e FALSE sono associati rispettivament i valori numerici 1 e 0. Questi sono definiti \href{https://it.wikipedia.org/wiki/Variabile_booleana}{valori booleani}.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{TRUE} \OperatorTok{==}\StringTok{ }\DecValTok{1}   \CommentTok{# TRUE}
\OtherTok{TRUE} \OperatorTok{==}\StringTok{ }\DecValTok{2}   \CommentTok{# FALSE}
\OtherTok{TRUE} \OperatorTok{==}\StringTok{ }\DecValTok{0}   \CommentTok{# FALSE}
\OtherTok{FALSE} \OperatorTok{==}\StringTok{ }\DecValTok{0}  \CommentTok{# TRUE}
\OtherTok{FALSE} \OperatorTok{==}\StringTok{ }\DecValTok{1}  \CommentTok{# FALSE}
\end{Highlighting}
\end{Shaded}

In R è possibile anche abbreviare TRUE e FALSE rispettivamente in T e F, sebbene sia una pratica non consigliata poichè potrebbe nonn essere chiara e creare fraintendimenti. Infatti mentre TRUE e FALSE sono parole riservate (vedi Capitolo TODO) T a F non lo sono.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{T }\OperatorTok{==}\StringTok{ }\DecValTok{1}      \CommentTok{# TRUE}
\NormalTok{T }\OperatorTok{==}\StringTok{ }\OtherTok{TRUE}   \CommentTok{# TRUE}
\NormalTok{F }\OperatorTok{==}\StringTok{ }\DecValTok{0}      \CommentTok{# TRUE}
\NormalTok{F }\OperatorTok{==}\StringTok{ }\OtherTok{FALSE}  \CommentTok{# TRUE}
\end{Highlighting}
\end{Shaded}

\end{tip}

\hypertarget{operatori-logici}{%
\subsection{Operatori Logici}\label{operatori-logici}}

In R è possibile congiungere più relazioni per valutare una desiderata proposizione. Ad esempio potremmo valutare se ``\emph{17 è maggiore di 10 e minore di 20}''. Per unire più relazioni in un'unica proposizione che R valuterà come \texttt{TRUE} o \texttt{FALSE}, vengono utilizati gli operatori logici riportati in Tabella \ref{tab:logical-operators}.

\begin{table}[!h]

\caption{\label{tab:logical-operators}Operatori Logici}
\centering
\begin{tabular}[t]{l|l|l}
\hline
Funzione & Nome & Esempio\\
\hline
\texttt{!x} & Negazione & \texttt{\makecell[l]{> !TRUE \\{[1]} FALSE}}\\
\hline
\texttt{x \& y} & Congiunzione & \texttt{\makecell[l]{> TRUE \& FALSE \\{[1]} FALSE}}\\
\hline
\texttt{x | y} & Disgiunzione Inclusiva & \texttt{\makecell[l]{> TRUE | FALSE \\{[1]} TRUE}}\\
\hline
\end{tabular}
\end{table}

Questi operatori sono anche definiti \href{https://it.wikipedia.org/wiki/Espressione_booleana}{operatori booleani} e seguono le comuni definizioni degli operatori logici. In particolare abbiamo che:

\begin{itemize}
\tightlist
\item
  Nel caso della \textbf{congiunzione logica} \texttt{\&}, affinchè la proposizione sia vera è necessario che entrambe le relazioni siano vere. Negli altri casi la proposizione sarà valutarta falsa (vedi Tabella \ref{tab:and-operator}).
\end{itemize}

\begin{table}[!h]

\caption{\label{tab:and-operator}Congiunzione '\&'}
\centering
\begin{tabular}[t]{>{}l|>{}l|>{}l}
\hline
x & y & x \textbackslash{}\& y\\
\hline
TRUE & TRUE & TRUE\\
\hline
TRUE & FALSE & FALSE\\
\hline
FALSE & TRUE & FALSE\\
\hline
FALSE & FALSE & FALSE\\
\hline
\end{tabular}
\end{table}

\begin{itemize}
\tightlist
\item
  Nel caso della \textbf{disgiunzione inclusiva logica} \texttt{\textbar{}}, affinchè la proposizione sia vera è necessario che almeno una relaziona sia vera. La proposizione sarà valutarta falsa solo quando entrambe le relazioni sono false (vedi Tabella \ref{tab:or-operator}).
\end{itemize}

\begin{table}[!h]

\caption{\label{tab:or-operator}Disgiunzione inclusiva '|'}
\centering
\begin{tabular}[t]{>{}l|>{}l|>{}l}
\hline
x & y & x | y\\
\hline
TRUE & TRUE & TRUE\\
\hline
TRUE & FALSE & TRUE\\
\hline
FALSE & TRUE & TRUE\\
\hline
FALSE & FALSE & FALSE\\
\hline
\end{tabular}
\end{table}

\begin{design}[Disgiunzione esclusiva]

Per completezza ricordiamo che tra gli operatori logici esiste anche la \textbf{disgiunzione esclusiva}. La proposizione sarà valutata falsa se entrambe le relazioni sono vere oppure false. Affinchè la proposizione sia valutata vera una sola delle relazioni deve essere vera mentre l'altra deve essere falsa.

In R la disgiunzione esclusiva tra due ralazioni (x e y) è indicata con la funzione \texttt{xor(x,\ y)}. Tuttavia tale funzione è raramente usata.

\begin{longtable}[]{@{}lll@{}}
\caption{Disgiunzione esclusiva `xor(x, y)'}\tabularnewline
\toprule
x & y & xor(x, y)\tabularnewline
\midrule
\endfirsthead
\toprule
x & y & xor(x, y)\tabularnewline
\midrule
\endhead
TRUE & TRUE & FALSE\tabularnewline
TRUE & FALSE & TRUE\tabularnewline
FALSE & TRUE & TRUE\tabularnewline
FALSE & FALSE & FALSE\tabularnewline
\bottomrule
\end{longtable}

\end{design}

\hypertarget{ordine-valutazione-relazioni}{%
\subsection{Ordine valutazione relazioni}\label{ordine-valutazione-relazioni}}

Nel valutare le veridicità delle proposizioni R esegue le operazioni nel seguente ordine:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  operatori matematici (e.g., \texttt{\^{}}, \texttt{*}, \texttt{/}, \texttt{+}, \texttt{-}, etc.)
\item
  operatori relazionali (e.g., \texttt{\textless{}}, \texttt{\textgreater{}}, \texttt{\textless{}=}, \texttt{\textgreater{}=}, \texttt{==}, \texttt{!=})
\item
  operatori logici (e.g., \texttt{!}, \texttt{\&}, \texttt{\textbar{}})
\end{enumerate}

La lista completa dell'ordine di esecuzione delle operazioni è riportata al seguente link \url{https://stat.ethz.ch/R-manual/R-devel/library/base/html/Syntax.html}. Ricordiamo che, in caso di dubbi riguardanti l'ordine di esecuzione delle operazioni, la cosa migliore è utilizzare le parentesi tonde \texttt{()} per disambiguare ogni possibile fraintendimento.

\begin{warning}[L'operatore '\%in\%']

Nota che l'operatore \texttt{\%in\%} che abbiamo precedentemente indicato tra gli operatori relazionali in realtà è un operatore speciale. In particolare, non segue le stesse regole degli altri operatori relazionlali per quanto riguarda l'ordine di esecuzione.

La soluzione migliore? Usa le parentesi!

\end{warning}

\hypertarget{esercizi-1}{%
\subsection*{Esercizi}\label{esercizi-1}}
\addcontentsline{toc}{subsection}{Esercizi}

Esegui i seguenti esercizi utilizzando gli operatori relazionali e logici (\href{https://github.com/psicostat/Introduction2R/blob/master/exercises/chapter-03-first-comands.R}{soluzioni}):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Definisici due relazioni false e due vere che ti permettano di valutare i risultati di tutti i possibili incroci che puoi ottenere con gli operatori logici \texttt{\&} e \texttt{\textbar{}}.
\item
  Definisci una proposizione che ti permetta di valutare se un numero è pari. Definisci un'altra proposizione per i nueri dispari (tip: cosa ti ricorda \texttt{\%\%}?).
\item
  Definisci una proposizione per valutare la seguente condizione (ricordati di testare tutti i possibili scenari) ``\emph{x è un numero compreso tra -4 e -2 oppure è un numero compreso tra 2 e 4}''.
\item
  Esegui le seguenti operazioni \texttt{4\ \^{}\ 3\ \%in\%\ c(2,3,4)} e \texttt{4\ *\ 3\ \%in\%\ c(2,3,4)}. Cosa osservi nell'ordine di esecuzione degli operatori?
\end{enumerate}

\hypertarget{objects-functions}{%
\chapter{Due Compagni Inseparabili}\label{objects-functions}}

In questo capitolo introdurremmo i concetti di oggetti e funzioni, due elementi alla base di R (e di ogni linguaggio di programmazione). Potremmo pensare agli oggetti in R come a delle variabili che ci permettono di mantenere in memoria dei valori (e.g., i risultati dei nostri calcoli o i nostri dati). Le funzioni in R, invece, sono analoghe a delle funzioni matematiche che, ricevuti degli oggetti in input, compiono delle azioni e restituiscono dei nuovi oggetti in output.

Questa è una iper-semplificazione (e pure tecnicamente non corretta) che ci permettere però di capire come, partendo dai nostri dati o valori iniziali, possiamo manipolarli applicando delle funzioni per ottenere, attraverso differenti step, i risultati desiderati (e.g., analisi statistiche o grafici e tabelle).

Qui valuteremo gli aspetti fondamentali riguardanti l'utilizzo degli oggetti e delle funzioni che saranno successivamente approfonditi rispettivamente nel corso della seconda e della terza sezione del libro (TODO).

\hypertarget{objects-section}{%
\section{Oggetti}\label{objects-section}}

Quando eseguiamo un commando in R, il risultato ottenuto viene immediatamente mostrato in \emph{Console}. Tale risultato, tuttavia, non viene salvato in memoria e quindi non potrà essere riutilizzato in nessuna operazione futura. Condurre delle analisi in questo modo sarebbe estremamente complicato ed inefficiente. La soluzione più ovvia è quella di salvare in memoria i nostri risultati intermedi per poterli poi riutilizzare nel corso delle nostre analisi. Si definisce questo processo come \emph{assegnare} un valore ad un oggetto.

\hypertarget{assegnare-e-richiamare-un-oggetto}{%
\subsection{Assegnare e Richiamare un oggetto}\label{assegnare-e-richiamare-un-oggetto}}

Per assegnare il valore numerico 5 all'oggetto \texttt{x} è necessario eseguire il seguente comando:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{5}
\end{Highlighting}
\end{Shaded}

La funzione \texttt{\textless{}-} ci permette di assegnare i valori che si trovano alla sua destra all'oggetto il cui nome è definito alla sinistra. Abbiamo pertanto il seguente pattern: \texttt{\textless{}nome-oggetto\textgreater{}\ \textless{}-\ \textless{}valore-assegnato\textgreater{}}.Notate come in \emph{Console} appaia solo il comando appena eseguito ma non venga mostrato alcun risultato.

Per utilizzare il valore contenuto nell'oggetto sarà ora sufficiente richiamare nel proprio codice il nome dell'oggetto desiderato.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{+}\StringTok{ }\DecValTok{3}
\CommentTok{## [1] 8}
\end{Highlighting}
\end{Shaded}

E' inoltre possibile ``aggiornare'' o ``sostituire'' il valore contenuto in un oggetto. Ad esempio:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Aggiornare un valore}
\NormalTok{x <-}\StringTok{ }\NormalTok{x}\OperatorTok{*}\DecValTok{10}
\NormalTok{x}
\CommentTok{## [1] 50}

\CommentTok{# Sostituire un valore}
\NormalTok{x <-}\StringTok{ "Hello World!"}
\NormalTok{x}
\CommentTok{## [1] "Hello World!"}
\end{Highlighting}
\end{Shaded}

Nel primo caso, abbiamo utilizzato il vecchio valore contenuto in \texttt{x} per calcolare il nuovo risultato che è stato assegnato a \texttt{x}. Nel secondo caso, abbiamo sostituito il vecchio valore di \texttt{x} con un nuovo valore (nell'esempio una stringa di caratteri).

\begin{design}[Assegnare valori '<-' vs '=']

Esistono due operatori principali che sono usati per assegnare un valore ad un oggetto: l'operatore \texttt{\textless{}-} e l'operatore \texttt{=}. Entrambi sono validi e spesso la scelta tra i due diventa solo una questione di stile personale.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x_}\DecValTok{1}\NormalTok{ <-}\StringTok{ }\DecValTok{45}
\NormalTok{x_}\DecValTok{2}\NormalTok{ =}\StringTok{ }\DecValTok{45}

\NormalTok{x_}\DecValTok{1} \OperatorTok{==}\StringTok{ }\NormalTok{x_}\DecValTok{2} 
\CommentTok{## [1] TRUE}
\end{Highlighting}
\end{Shaded}

Esistono, tuttavia, alcune buone ragioni per preferire l'uso di \texttt{\textless{}-} rispetto a \texttt{=} (attenti a non confonderlo con l'operatore relazionale \texttt{==}). L'operazione di assegnazione è un'operazione che implica una direzionalità, il chè è reso esplicito dal simbolo \texttt{\textless{}-} mentre il simbolo \texttt{=} non evidenzia questo aspetto e anzi richiama la relazione di uguaglianza in matematica.

La decisione su quale operatore adottare è comunque libera, ma ricorda che una buona norma nella programmazione riguarda la \emph{consistenza}: una volta presa una decisione è bene mantenerla per facilitare la comprensione del codice.

\end{design}

\hypertarget{objects-names}{%
\subsection{Nomi degli oggetti}\label{objects-names}}

La scelta dei nomi degli oggetti sembra un aspetto secondario ma invece ha una grande importanza per facilitare la chiarezza e la comprensione dei codici.

Ci sono alcune regole che discriminano nomi validi da nomi non validi. Il nome di un oggetto:

\begin{itemize}
\tightlist
\item
  deve iniziare con una lettera e può contenere lettere, numeri, underscore (\texttt{\_}), o punti (\texttt{.}).
\item
  potrebbe anche iniziare con un punto (\texttt{.}) ma in tal caso non può essere seguito da un numero.
\item
  non deve contenere caratteri speciali come \texttt{\#}, \texttt{\&}, \texttt{\$}, \texttt{?}, etc.
\item
  non deve essere una parola riservata ovvero quelle parole che sono utilizzate da R con un significato speciale (e.g, \texttt{TRUE}, \texttt{FALSE}, etc.; esegui il comando \texttt{?reserved} per la lista di tutte le parole riservate in R).
\end{itemize}

\begin{warning}[CaSe-SeNsItIvE]

Nota come R sia \textbf{Case-Sensitive}, ovvero distingua tra lettere minuscole e maiuscole. Nel seguente esempio i due nomi sono considerate diversi e pertanto non avviene una sovrascrizione ma due differenti oggetti sono creati:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{My_name <-}\StringTok{ "Monty"}
\NormalTok{my_name <-}\StringTok{ "Python"}

\NormalTok{My_name}
\CommentTok{## [1] "Monty"}
\NormalTok{my_name}
\CommentTok{## [1] "Python"}
\end{Highlighting}
\end{Shaded}

\end{warning}

Inoltre, il nome ideale di un oggetto dovrebbe essere:

\begin{itemize}
\tightlist
\item
  \textbf{auto-descrittivo}: dal solo nome dovrebbe essere possibile intuire il contenuto dell'oggetto. Un nome generico quale \texttt{x} o \texttt{y} ci sarebbero di poco aiuto poichè potrebbero contenere qualsiasi informazione. Invece un nome come \texttt{weight} o \texttt{gender} ci suggerirebbe chiaramente il contenuto dell'oggetto (e.g., il peso o il gender dei partecipanti del nostro studio).
\item
  \textbf{della giusta lunghezza}: non deve essere ne troppo breve (evitare sigle incomprensibili) ma neppure troppo lunghi. La lunghezza corretta è quella che permette al nome di esssere sufficientemente informativo senza aggiungere inutili dettagli. In genere sono sufficienti 2 o 3 parole.
\end{itemize}

\begin{design}[CamelCase vs snake\_case]

Spesso più parole sono usate per ottenere un nome sufficientemente chiaro. Dato che però non è possibile includere spazi in un nome, nasce il problema di come unire più parole senza che il nome diventi incomprensibile, ad esempio \texttt{mediatestcontrollo}.

Esistono diverse convenzioni tra cui:

\begin{itemize}
\tightlist
\item
  \textbf{CamelCase}. L'inizio di una nuova parole viene indicata con l'uso della prima lettera maiuscola. Ad esempio \texttt{mediaTestControllo}.
\item
  \textbf{snake\_case}. L'inizio di una nuova parola viene indicata con l'uso carattere \texttt{\_}. Ad esempio \texttt{media\_test\_controllo}.
\item
  una variante al calssico \textbf{snake\_case} riguarda l'uso del \texttt{.}, ad esempio \texttt{media.test.controllo}. Questo approccio in genere è evitato poichè in molti linguaggi di progtrammazione (ed anche in R in alcune condizioni) il carattere \texttt{.} è un carattere speciale.
\end{itemize}

In genere viene raccomandato di seguire la convenzione \textbf{snake\_case}. Tuttavia, la decisione su quale convenzione adottare è libera, ma ricorda ancora che una buona norma nella programmazione riguarda la \emph{consistenza}: una volta presa una decisione è bene mantenerla per facilitare la comprensione del codice.

\end{design}

\hypertarget{tipologie-dati-e-strutture-dati}{%
\subsection{Tipologie Dati e Strutture Dati}\label{tipologie-dati-e-strutture-dati}}

Per lavorare in modo ottimale in R, è fondamentale conoscere bene e distinuere chiaramente quali sono le tipologie di dati e le strutture degli oggetti usati.

In R abbiamo 4 principali tipologie di dati, ovvero tipologie di valori che possono essere utilizzati:

\begin{itemize}
\tightlist
\item
  \texttt{character} - \emph{Stringhe di caratteri} i cui valori alfannumerici vengono delimitati dalle doppie vigolette \texttt{"Hello\ world!"} o virgolette singole \texttt{\textquotesingle{}Hello\ world!\textquotesingle{}}.
\item
  \texttt{double} - \emph{Valori reali} con o senza cifre decimali ad esempio \texttt{27} o \texttt{93.46}.
\item
  \texttt{integer} - \emph{Valori interi} definiti apponendo la lettera \texttt{L} al numero desiderato, ad esempio \texttt{58L}.
\item
  \texttt{logical} - \emph{Valori logici} \texttt{TRUE} e \texttt{FALSE} usati nelle operazioni logiche.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof}\NormalTok{(}\StringTok{"Psicostat"}\NormalTok{)}
\CommentTok{## [1] "character"}
\KeywordTok{typeof}\NormalTok{(}\FloatTok{24.04}\NormalTok{)}
\CommentTok{## [1] "double"}
\KeywordTok{typeof}\NormalTok{(1993L)}
\CommentTok{## [1] "integer"}
\KeywordTok{typeof}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)}
\CommentTok{## [1] "logical"}
\end{Highlighting}
\end{Shaded}

In R abbiamo inoltre differenti tipologie di oggetti, ovvero diverse strutture in cui possono essere organizzati i dati:

\begin{itemize}
\tightlist
\item
  \textbf{Vettori}
\item
  \textbf{Matrici}
\item
  \textbf{Dataframe}
\item
  \textbf{Liste}
\end{itemize}

Approfondiremo la loro definizione, le loro caratteristiche ed il loro utilizzo nel corso di tutta la seconda sezione di questo libro TODO.

\hypertarget{functions-def}{%
\section{Funzioni}\label{functions-def}}

Possiamo pensare alle funzioni in R in modo analogo alle classiche funzioni matematiche. Dati dei valori in input, le funzioni eseguono dei specifici calcoli e restituiscono in output il risultato ottenuto.

\includegraphics[width=0.95\textwidth,height=\textheight]{images/functions-graph.png}

Abbiamo già incontrato le nostre prime funzioni per eseguire specifiche operazioni matematiche nel Capitolo \ref{math-operators} come ad esempio \texttt{sqrt()} o \texttt{abs()} usate per ottenere ripettivamente la radice quadrata o il valore assoluto di un numero. Ovviamente le funzioni in R non sono limitate ai soli calcoli matematici ma possono eseguire qualsiasi genere di compito come ad esempio creare grafici e tabelle o manipolare dei dati o dei file. Tuttavia il concetto rimane lo stesso: ricevuti degli oggetti in input, le funzioni compiono determinate azioni e restituiscono dei nuovi oggetti in output.

In realtà incontreremo delle funzioni che non richiedono input o non produrre degli output. Ad esempio \texttt{getwd()} non richiede input oppure la funzione \texttt{rm()} non produce output. Tuttavia questo accade nella minoranza dei casi.

Per eseguire una funzione in R è necessario digitare il nome della funzione ed indicare tra parentesi i valori che vogliamo assegnare agli \textbf{argomenti} della funzione, ovvero i nostri input, separati da virgole. Generalmente si utilizza quindi la seguente sintassi:

\texttt{\textless{}nome-funzione\textgreater{}(\textless{}nome-arg1\textgreater{}\ =\ \textless{}valore-arg1\textgreater{},\ \textless{}nome-arg2\textgreater{}\ =\ \textless{}valore-arg2\textgreater{},...)}

{}

Ad esempio per creare una sequenza di valori con incrementi di 1 posso usare la funzione \texttt{seq()}, i cui argomenti sono \texttt{from} e \texttt{to} ed indicano rispettivamente il valore iniziale ed il valore massimo della sequenza.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# creo una sequenza di valori da 0 a 10 con incrementi di 1}
\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{, }\DataTypeTok{to =} \DecValTok{10}\NormalTok{)}
\CommentTok{##  [1]  0  1  2  3  4  5  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}

\hypertarget{function-arguments}{%
\subsection{Argomenti di una Funzione}\label{function-arguments}}

Nel definire gli argomenti di una funzione non è necessario specificare il nome degli argomenti. Ad esempio il comando precedente può essere eseguito anche specificando solamente i valori.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# creo una sequenza di valori da 0 a 10 con incrementi di 1}
\KeywordTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\CommentTok{##  [1]  0  1  2  3  4  5  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}

Tuttavia, questo rende più difficile la lettura e la comprensione del codice poichè non è chiaro a quali argomenti si riferiscono i valori. L'ordine con cui vengono definiti i valori in questo caso è iportante, poichè R assume rispetti l'ordine prestabilito degli argomenti. Osserva come invertendo invertendo i valori ovviamente otteniamo risultati differenti da quelli precedenti, ma questo non avviene quando il nome dell'argomento è specificato.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# inverto i valori senza i nomi degli argomenti}
\KeywordTok{seq}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{0}\NormalTok{)}
\CommentTok{##  [1] 10  9  8  7  6  5  4  3  2  1  0}

\CommentTok{# inverto i valori con i nomi degli argomenti}
\KeywordTok{seq}\NormalTok{(}\DataTypeTok{to =} \DecValTok{10}\NormalTok{, }\DataTypeTok{from =} \DecValTok{0}\NormalTok{)}
\CommentTok{##  [1]  0  1  2  3  4  5  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}

Vediamo inoltre come le funzioni possano avere molteplici argomenti, ma che non sia necessario specificare il valore per ognuno di essi. Molti argomenti, infatti, hanno già dei valori prestabiliti di \emph{default} e non richiedo quindi di essere specificati almeno che ovviamente non si vogliano utilizzare impostazioni diverse da quelle di \emph{default}. Oppure lo specificare un dato argomento rispetto ad un altro può definire il comportamento stesso della funzione.

Ad esempio la funzione \texttt{seq()} possiede anche gli argomenti \texttt{by} e \texttt{length.out} che prima non erano stati specificati. \texttt{by} permette di definire l'incremento per ogni elemento successivo della sequenza mentre \texttt{length.out} permette di definire il numero di elementi della sequenza. Vediamo come allo specificare dell'uno o dell'altro agromento (o di entrambi) il comportamento della funzione vari.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{,  }\DataTypeTok{to =} \DecValTok{10}\NormalTok{, }\DataTypeTok{by =} \DecValTok{5}\NormalTok{)}
\CommentTok{## [1]  0  5 10}
\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{,  }\DataTypeTok{to =} \DecValTok{10}\NormalTok{, }\DataTypeTok{length.out =} \DecValTok{5}\NormalTok{)}
\CommentTok{## [1]  0.0  2.5  5.0  7.5 10.0}
\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{,  }\DataTypeTok{to =} \DecValTok{10}\NormalTok{, }\DataTypeTok{length.out =} \DecValTok{5}\NormalTok{, }\DataTypeTok{by =} \DecValTok{4}\NormalTok{)}
\CommentTok{## Error in seq.default(from = 0, to = 10, length.out = 5, by = 4): too many arguments}
\end{Highlighting}
\end{Shaded}

E' pertanto cosigliabile esplicitare sempre gli argomenti di una funzione per rendere chiaro a che cosa si riferiscono i valori indicati. Questo è utlile anche per evitare eventuali comportamenti non voluti delle funzioni ad individuare più facilmente possibili errori.

Gli argomenti di una funzione, inoltre, richiedono specifiche tipologie e strutture di dati e sta a noi assicuraci che i dati siano forniti nel modo corretto. Vediamo ad esempio come la funzione \texttt{mean()} che calcola la media di un insieme di valori, richieda come input un vettore di valori numerici. Approfondiremo il concetto di vettori nel Capitolo TODO, al momento ci basta sapere che possiamo usare la funzione \texttt{c()} per combinare più valori in un unico vettore.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Calcolo la media dei seguenti valori (numerici)}
\KeywordTok{mean}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{12}\NormalTok{)) }\CommentTok{# c() combina più valori in un unico vettore}
\CommentTok{## [1] 9}

\KeywordTok{mean}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{12}\NormalTok{)}
\CommentTok{## [1] 10}
\end{Highlighting}
\end{Shaded}

Notiamo come nel primo caso il risultato sia corretto mentre nel secondo è sbagliato. Questo perchè \texttt{mean()} richiede come primo argomento il vettore su cui calcolare la media. Nel primo caso abbiamo correttamente specificato il vettore di valori usando la funzione \texttt{c()}. Nel secondo caso invece, il primo argomento risulta essere solo il valore \texttt{10} ed R calcola la media di \texttt{10} ovvero \texttt{10}. Gli altri valori sono passati ad altri argomenti che non alterano il comportameto ma neppure ci segnalano di questo importante errore.

Nel seguente esempio, possiamo vedere come \texttt{mean()} richieda che i valori siano numerici. Seppur \texttt{"1"} \texttt{"2"}, e \texttt{"3"} siano dei numeri, l'utilizzo delle doppie virgolette li rende delle stringhe di caratteri e non dei valori numerici e giustamente R non può eseguire una media su dei caratteri.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Calcolo la media dei seguenti valori (caratteri)}
\KeywordTok{mean}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"1"}\NormalTok{, }\StringTok{"2"}\NormalTok{, }\StringTok{"3"}\NormalTok{))}
\CommentTok{## Warning in mean.default(c("1", "2", "3")): argument is not numeric or logical:}
\CommentTok{## returning NA}
\CommentTok{## [1] NA}
\end{Highlighting}
\end{Shaded}

Capiamo quindi che per usare correttamente le funzioni è fondamentale conoscerne gli argomenti e rispettare le tipologie e strutture di dati richieste.

\hypertarget{help-i-need-somebodyhelp}{%
\subsection{Help! I need Somebody\ldots Help!}\label{help-i-need-somebodyhelp}}

Conoscere tutte le funzioni e tutti i loro argomenti è impossibile. Per fortuna R ci viene in soccorso fornendoci per ogni funzione la sua documentazione. Qui vengono fornite tutte le informazioni riguardanti la finalità della funzione, la descrizione dei suoi argomenti, i dettagli riguardanti i suoi possibili utilizzi.

Per accedere alla documentazione possiamo utilizzare il comando \texttt{?\textless{}nome-funzione\textgreater{}} oppure \texttt{help(\textless{}nome-funzione\textgreater{})}. Ad esempio:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?seq}
\KeywordTok{help}\NormalTok{(seq)}
\end{Highlighting}
\end{Shaded}

Una pagina si aprirà nel pannello ``Help'' in basso a destra con la documentazione della funzione in modo simile a quanto rappresentato in Figura \ref{fig:help-page}.

\begin{figure}

{\centering \includegraphics[width=0.85\linewidth]{images/help-seq} 

}

\caption{Help-page della funzione seq()}\label{fig:help-page}
\end{figure}

Il formato e le informazioni presenti nella pagina seguono delle norme comuni ma non obbligatorie. Infatti, non necessariamente vengono usati sempre tutti i campi e comunque all'autore delle funzioni è lasciato un certo grado di libertà nel personalizzare la documentazione. Tra i campi principali e più comunemente usati abbiamo:

\begin{itemize}
\tightlist
\item
  \textbf{Tiolo} - Titolo esplicativo della finalità della funzione\\
\item
  \textbf{Description} - Descrizione coincisa della funzione
\item
  \textbf{Usage} - Viene mostrata la struttura della funzione con i suoi argomenti e valori di default
\item
  \textbf{Arguments} - Elenco con la descrizione dettagliata di tutti gli argomenti. Qui troviamo per ogni argomento sia le opzioni utilizzabili ed il loro effetto, che la tipologia di valori richiesti
\item
  \textbf{Details} - Descrizione dettagliata della funzione considerando i casi di utilizzo ed eventuali note tecniche
\item
  \textbf{Value} - Descrizione dell'output dalla funzione. Qui troviamo sia la descrizione della struttura dei dati dell'output che la descrizione dei suei elementi utile per interpretare ed utilizzare i rsultati ottenuti
\item
  \textbf{See Also} - Eventuali link ad altre funzioni simili o in relazione con la nostra funzione
\item
  \textbf{Examples} - Esempi di uso della funzione
\end{itemize}

\hypertarget{ricerca-per-parola}{%
\subsubsection*{Ricerca per Parola}\label{ricerca-per-parola}}
\addcontentsline{toc}{subsubsection}{Ricerca per Parola}

Quando non si conosce esattamente il nome di una funzione o si vuole cercare tutte le funzioni e pagine che includono una certa parola, è possibile utilizzare il comando \texttt{??\textless{}parola\textgreater{}} oppure \texttt{help.search(\textless{}parola\textgreater{})}.

R eseguirà una ricerca tra tutta la documentazione disponibile è fornirà un elenco delle pagine che contengono la parola desiderata nel titolo o tra le keywords.

\begin{trick}[Autocompletamento with 'Tab']

La natura dei programmatori è essere pigri e smemorati. Per fortuna ogni \emph{code editor} che si rispetti (i.e., programma per la scrittura di codici) possiede delle utli funzioni di autocompletamento e suggerimento dei comandi che semplificano la scrittura di codici.

In Rstudio, i suggerimenti compaino automaticamente durante la scrittura di un comando oppure possono essere richiamati premendo il tasto \texttt{Tab} in alto a sinistra della tastiera ( \includegraphics[width=0.05\textwidth,height=\textheight]{images/Tab.png} ). Comparirà una finestra con possibili soluzioni di autocompletamento del nome della funzione. Utilizzando le frecce della tastiera possiamo evidenziare lq funzione voluta e premere \texttt{Invio} per autocompletare il comando. Nota come accanto al nome della funzione appare anche un piccolo riquadro giallo con la descrizione della funzione.

\includegraphics[width=0.95\textwidth,height=\textheight]{images/autocomplete-function.png}

Per inserire gli argomenti della funzione possiamo fare affidamento nuovamente ai suggerimenti e alla funzione di autocompletamento. Sarà sufficiente premere nuovamente il tasto \texttt{Tab} e questa volta comparirà una lista degli argomenti con la relativa descrizione. Sarà quindi sufficiente selezionare con le frecce l'argomento desiderato e premere \texttt{Invio}.

\includegraphics[width=0.95\textwidth,height=\textheight]{images/autocomplete-arguments.png}

Notate come la funzione di autocompletamento non sia utilizzata solo per le funzioni ma anche per i nomi degli oggetti. Questo ci consentirà di richiamare velocemente oggetti precedentemente creati evitando di digitare l'intero nome.

\includegraphics[width=0.95\textwidth,height=\textheight]{images/autocomplete-objects.png}

\end{trick}

\hypertarget{working-environment}{%
\chapter{Ambiente di Lavoro}\label{working-environment}}

In queso capitolo introdurremo alcuni concetti molto importanti che riguardano l'ambiente di lavoro in R o RStudio. In particolare parleremo dell'\emph{environment}, della \emph{working directory} e dell'utilizzo dei pacchetti.

\hypertarget{environment}{%
\section{Environment}\label{environment}}

Nel Capitolo \ref{objects-section}, abbiamo visto come sia possibile assegnare dei valori a degli oggetti. Questi oggetti vengono creati nel nostro ambiente di lavoro (o meglio \emph{Environment}) e potranno essere utilizzati in seguito.

Il nostro Enviroment raccoglie quindi tutti gli oggetti che vengono creati durante la nostra sessione di lavoro. E' possibile valutare gli oggetti attualmente presenti osservando il pannello \emph{Environment} in alto a destra (vedi Figura \ref{fig:environment2}) oppure utilizzadno il comando \texttt{ls()}, ovvero \emph{list objects}.

\begin{figure}

{\centering \includegraphics[width=0.6\linewidth]{images/environment} 

}

\caption{*Environment* - Elenco degli oggetti e variabili presenti nel'ambiente di lavoro}\label{fig:environment2}
\end{figure}

All'inizio della sessione di lavoro il nostro Environment sarà vuoto (vedi Figura \ref{fig:environment-empty}). Il comando \texttt{ls()} non restituirà alcun oggeto ma per indicare l'assenza di oggerri userà la risposta \texttt{character(0)}, ovvero un vettore di tipo caratteri di lunghezza zero (vedi Capitolo TODO).

\begin{figure}

{\centering \includegraphics[width=0.6\linewidth]{images/environment-empty} 

}

\caption{*Environment* vuoto ad inizio sessione di lavoro}\label{fig:environment-empty}
\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Environment vuoto}
\KeywordTok{ls}\NormalTok{()}
\CommentTok{## character(0)}
\end{Highlighting}
\end{Shaded}

\hypertarget{aggiungere-oggetti-allenvironment}{%
\subsection{Aggiungere Oggetti all'Environment}\label{aggiungere-oggetti-allenvironment}}

Una volta creati degli oggetti, questi saranno presenti nel nostro Environment e il comando \texttt{ls()} restituirà un vettore di caretteri in cui vengono elencati tutti i loro nomi.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Creo oggetti}
\NormalTok{x <-}\StringTok{  }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{8}\NormalTok{)}
\NormalTok{y <-}\StringTok{  }\DecValTok{27}
\NormalTok{word <-}\StringTok{ "Hello Word!"}

\CommentTok{# Lista nomi oggetti nell'Environment}
\KeywordTok{ls}\NormalTok{()}
\CommentTok{## [1] "word" "x"    "y"}
\end{Highlighting}
\end{Shaded}

Nel pannello in alto a destra (vedi Figura \ref{fig:environment-object}), possiamo trovare un elenco degli oggetti attualmente presenti nel nostro Environment. Insieme al nome vengono riportate anche alcune utili inforamzioni a seconda del tipo di oggetto. Vediamo come nel nostro esempio, nel caso di variabili con un singolo valore (e.g., \texttt{word} e \texttt{y}) venganno presentati direttamente gli stessi valori. Mentre, nel caso di vettori (e.g., \texttt{x}) vengano fornite anche informazioni riguardanti la tipologia di vettore e la sua dimensione (vedi Capitolo TODO), nell'esempio abbiimao un vettore numerico (\texttt{num}) di 4 elementi (\texttt{{[}1:4{]}}).

\begin{figure}

{\centering \includegraphics[width=0.6\linewidth]{images/environment-objects} 

}

\caption{*Environment* contenente gli oggetti creati}\label{fig:environment-object}
\end{figure}

\hypertarget{rimuovere-oggetti-dallenvironment}{%
\subsection{Rimuovere Oggetti dall'Environment}\label{rimuovere-oggetti-dallenvironment}}

Per rimuovere un oggetto dal proprio environment è possibile utilizzare il comando \texttt{remove()} oppure la sua abbreviazione \texttt{rm()}, indicando tra parentesi il nome dell'oggetto che si intende rimuovere. E' possibile indicare più di un oggetto separando i loro nomi con la virgola.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Rimuovo un oggetto}
\KeywordTok{rm}\NormalTok{(word)}
\KeywordTok{ls}\NormalTok{()}
\CommentTok{## [1] "x" "y"}

\CommentTok{# Rimuovo più oggetti contemporaneamente}
\KeywordTok{rm}\NormalTok{(x,y)}
\KeywordTok{ls}\NormalTok{()}
\CommentTok{## character(0)}
\end{Highlighting}
\end{Shaded}

\begin{trick}[rm(list=ls())]

Qualora fosse necessario eliminare tutti gli oggetti attualmete presenti nel nosto ambiente di lavoro è possibile ricorrere alla formula \texttt{rm(list=ls())}. In questo modo si avrà la certezza di pulire l'ambiente da ogni oggetto e di ripristinarlo alle condizioni iniziali della sessione.

\end{trick}

\begin{design}[Mantenere Ordinato l'Environment]

Avere cura di mantenre il proprio Environment ordinato ed essere consapevoli degli oggetti attualmente presenti è importante. Questo ci permette di evitare di compiere due errori comuni.

\begin{itemize}
\tightlist
\item
  \textbf{Utilizzare oggetti non ancora creati}. In questo caso l'errore è facilemente individuabile dat che sarà lo stesso R ad avvisarci che \emph{``object `' not found''}. In questo caso dovremmo semplicemente eseguire il comando per creare l'oggetto richieto.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{oggetto_non_esistente}
\CommentTok{## Error in eval(expr, envir, enclos): object 'oggetto_non_esistente' not found}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \textbf{Utilizzare oggetti con ``\emph{vecchi}'' valori}. Se non si ha cura di mantenere ordinato il proprio ambiente di lavoro potrebbe accadere che diversi oggetti vengano creati durante successive sessioni di lavoro. A questo punto si corre il rischio di perdere il controllo rispetto al vero contenuto degli oggetti e potremmo quindi utilizzare degli oggetti pensando che contengano un certo valore, quando invece si riferisono a tutt'altro. Questo comporta che qualsiasi nostro risultato perda di significato. Bisogna prestare molta attenzione perchè R non potrà avvisarci di questo errore (per lui sono solo numeri), siamo noi che dobbiamo essere consapevoli del fatto che i comandi eseguiti abbiano senso oppure no.
\end{itemize}

Per mantere un Environmet ordinato vi consigliamo innanzitutto di non salvare automaticamente il vostro \emph{workspace} quando terminate una sessione di lavoro. E' possibile settare tale opzione nelle impostazioni generali di R selezionando \emph{``Never''} alla voce \emph{``save workspace to .RData on exit''} come riportato nella Figura seguente.

\includegraphics[width=0.75\textwidth,height=\textheight]{images/save-rdata.png}

Questo vi permetterà di iniziare ogni nuova sessione di lavoro in un Environment vuoto, evitando che vecchi oggetti si accumulino nel corso delle diverse sesssioni di lavoro. Durante le vostre sessioni, inoltre, sarà utile eseguire il comando \texttt{rm(list=ls())} quando inizierete un nuovo compito in modo da eliminare tutti i vecchi oggetti.

\hypertarget{environment-una-memoria-a-breve-termine}{%
\subsubsection*{Environment una Memoria a Breve Termine}\label{environment-una-memoria-a-breve-termine}}
\addcontentsline{toc}{subsubsection}{Environment una Memoria a Breve Termine}

Notiamo quindi come l'Environment sia qualcosa di transitorio. Gli oggetti vengono salvati nella memoria primaria del computer (RAM, possiamo pensarla in modo analogo alla memoria a breve termine dei modelli cognitivi) e verranno cancellati al comando \texttt{rm(list=ls())} o al termine di ogni sessione di lavoro.

Il fatto di partire ogni volta da un Environment vuoto, vi costringerà a raccogliere tutti i passi delle vostre analisi all'interno di uno script in modo ordinato evitando di fare affidamento su vecchi oggetti. Tutti gli oggetti necessari durante le analisi, infattii, dovranno essere ricreati ad ogni sessione, garantendo la riproducibilità e correttezza del lavro (almeno dal punto di vista di programmazione). Idealmente dovrebbe essere posibile, in una sessione di lavoro, partire da un Environment vuoto ed eseguire in ordine tutti i comandi contenuti in uno script fino ad ottenere i risultati desiderati.

E' facile intuire come in certe situazioni questa non sia la soluzione più efficiente. Alcuni comandi, infatti, potrebbero richiedere molti minuti (o anche giorni) per essere eseguiti. In questi casi sarebbe conveniente, pertanto, salvare i risultati ottenuti per poterli utilizzare anche in sessioni successive, senza la necessità di dover eseguire nuovamente tutti i comadi. Vedremo nel Capitolo TODO come sarà possibile salvare permanentemente gli oggetti creati nella memoria secondaria del computer (hard-disk, nella nostra analogia la memoria a lungo termine) e come caricarli in una successiva sessione di lavoro.

\end{design}

\hypertarget{working-directory}{%
\section{Working Directory}\label{working-directory}}

Il concetto di \emph{working directory} è molto importante ma spesso poco conosciuto. La \emph{working directory} è la posizione all'interno del computer in cui ci troviamo durante la nostra sessione di lavoro e da cui eseguiamo i nostri comandi.

\hypertarget{organizzazione-computer}{%
\subsection{Organizzazione Computer}\label{organizzazione-computer}}

L'idea intuitiva che abbiamo comunemente del funzionamento del computer è fuorviante. Spesso si pensa che il Desktop rispecchi l'organizzazione del nostro intero computer e che tutte le azioni siano gestite attraverso l'interfaccia punta-e-clicca a cui ormai siamo abituati dai moderni sistemi operativi.

Senza entrare nel dettaglio, è più corretto pensare all'organizzazione del cumputer come ad un insieme di cartelle e sottocartelle che contengono tutti i nostri file e al funzionamento del computer come ad un insieme di processi (o comandi) che vengono eseguiti. Gli stessi programmi che installiamo non sono altro che delle cartelle in cui sono contenuti tutti gli script che determinano il loro funzionamento. Anche il Desktop non è altro che una semplice cartella mentre quello che vediamo noi è un programma definito dal sistema operativo che visualizza il contenuto di quella cartella sul nostro schermo e ci permette di interfacciarci con il mouse.

Tutto quello che è presente nel nostro computer, compresi i nostri file, i programmi e lo stesso sistema operativo in uso, tutto è organizzato in un articolato sistema di cartelle e sottocartelle. Approsimativamente possiamo pensare all'organizzazione del nostro computer in modo simile alla Figura \ref{fig:file-system} (da: \url{https://en.wikipedia.org/wiki/Operating_system}).

\begin{figure}

{\centering \includegraphics[width=0.35\linewidth]{images/File-System} 

}

\caption{Organizzazione Computer (da Wikipedia vedi link nel testo)}\label{fig:file-system}
\end{figure}

Ai livelli più bassi troviamo tutti i file di sistema ai quali gli utenti possono accedere solo con speciali autorizzazioni. Al livello superiore troviamo tutte i file riguardanti i programmi e applicazioni installati che in genere sono utilizzabili da più utenti sullo stesso computer. Infine troviamo tutte le cartelle e file che riguardano lo specifico utente.

\hypertarget{absolute-path-e-relative-path}{%
\subsection{Absolute Path e Relative Path}\label{absolute-path-e-relative-path}}

Questo ampio preambolo riguardante l'organizzazione in cartelle e sottocartelle, ci serve perchè è la struttura che il computer utilizza per orientarsi tra tutti file quando esegue dei comandi attraverso un'interfaccia a riga di comando (e.g., R). Se vogliamo ad esempio caricare dei dati da uno specifico file in R devo fornire il \emph{path} (o indirizzo) corretto che mi indichi esattamente la posizione del file all'interno della struttura di cartelle del computer. Ad esempio, immaginiamo di avere dei dati \texttt{My-data.Rda} salvato nella cartella \texttt{Introduction2R} nel proprio Desktop.

\begin{verbatim}
Desktop
 |
 |-  Introduction2R
 |    |
 |    |- Dati
 |    |   |- My-data.Rda
\end{verbatim}

Per indicare la posizione del File potrei utilizzare un:

\begin{itemize}
\tightlist
\item
  \textbf{absolute path} - la posizione \emph{``assoluta''} del file rispetto alla \emph{root directory} del sistema ovvero la cartella principale dell'intero computer.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Mac}
\StringTok{"/Users/<username>/Desktop/Introduction2R/Dati/My-data.Rda"}

\CommentTok{# Windows Vista}
\StringTok{"c:\textbackslash{}Users\textbackslash{}<username>\textbackslash{}Desktop\textbackslash{}Introduction2R\textbackslash{}Dati\textbackslash{}My-data.Rda"}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \textbf{relative path} - la posizione del file rispetto alla nostra attuale posizione nel computer da cui stiamo eseguendo il comando, ovvero rispetto alla \textbf{working directory} della nostra sessione di lavoro. In questo riprendendo il precedente esempio se la nostra working directory fosse la cartella \texttt{Desktop/Introduction2R} avremmo i seguenti relative path:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Mac}
\StringTok{"Dati/My-data.Rda"}

\CommentTok{# Windows Vista}
\StringTok{"Dati\textbackslash{}My-data.Rda"}
\end{Highlighting}
\end{Shaded}

Nota come sia preferibile l'utilizzo dei relative path poichè gli absolute path sono unici per il singolo computer di riferimento e non possono essere quindi utilizzati su altri computer.

\begin{warning}["Error: No such file or directory"]

Qualora si utilizzasse un relative path per indicare la posizione di un file, è importante che la working directory attualment in uso sia effettivamente quella prevista. Se ci trovassimo in una divesa cartella, ovviamente il ``relative path'' indicato non sarebbe più valido e R ci mostrerebbe un messaggio di errore.

Riprendendo l'esempio precedente, supponiamo che la nostra attuale working directory sia \texttt{Desktop} invece di \texttt{Desktop/Introduction2R}. Eseguendo il comadno \texttt{load()} per caricare i dati utilizzando il relative path ora non più valido ottengo:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{load}\NormalTok{(}\StringTok{"Dati/My-data.Rda"}\NormalTok{)}
\CommentTok{## Warning in readChar(con, 5L, useBytes = TRUE): cannot open compressed file}
\CommentTok{## 'Dati/My-data.Rda', probable reason 'No such file or directory'}
\CommentTok{## Error in readChar(con, 5L, useBytes = TRUE): cannot open the connection}
\end{Highlighting}
\end{Shaded}

Il messaggio di errore mi indica che R non è stato in grado di trovare il file seguendo le mie indicazioni. E' come se chiedessi al computer di aprire il frigo ma attualmente si trovasse in camera, devo prima dargli le indicazioni per raggiungere la cucina altrimenti mi risponderebbe \emph{``frigo non trovato''}. Risulta pertanto fondamentale essere sempre consapevoli di quale sia l'attuale working directory in cui si sta svolgendo la sessione di lavoro.

Ovviamente otterrei lo stesso errore anche usando un absolute path se questo contenesse degli errori.

\end{warning}

\begin{design}[The Garden of Forking Paths]

Come avrai notato dagli esempi precedenti, sia la struttura in cui vengono organizzati i file nel computer sia la sintassi utilizzata per indicare i path è differente in base al sistema operativo utilizzato.

\hypertarget{mac-os-e-linux}{%
\subsubsection*{Mac OS e Linux}\label{mac-os-e-linux}}
\addcontentsline{toc}{subsubsection}{Mac OS e Linux}

\begin{itemize}
\tightlist
\item
  Il carattere utilizzato per separare le cartelle nella definizione del path è \texttt{"/"}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"Introduction2R/Dati/My-data.Rda"}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  La root-directory viene indicata iniziando il path con il carattere \texttt{"/"}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"/Users/<username>/Desktop/Introduction2R/Dati/My-data.Rda"}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  La cartella \emph{home} dell'utente (ovvero \texttt{/Users/\textless{}username\textgreater{}/}) viene indicata iniziando il path con il carattere \texttt{"\textasciitilde{}"}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"~/Desktop/Introduction2R/Dati/My-data.Rda"}
\end{Highlighting}
\end{Shaded}

\hypertarget{windows-1}{%
\subsubsection*{Windows}\label{windows-1}}
\addcontentsline{toc}{subsubsection}{Windows}

\begin{itemize}
\tightlist
\item
  Il carattere utilizzato per separare le cartelle nella definizione del path è \texttt{"\textbackslash{}"}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"Introduction2R\textbackslash{}Dati\textbackslash{}My-data.Rda"}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  La root-directory viene indicata con \texttt{"c:\textbackslash{}"}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"c:\textbackslash{}Users\textbackslash{}<username>\textbackslash{}Desktop\textbackslash{}Introduction2R\textbackslash{}Dati\textbackslash{}My-data.Rda"}
\end{Highlighting}
\end{Shaded}

\end{design}

\hypertarget{working-directory-in-r}{%
\subsection{Working Directory in R}\label{working-directory-in-r}}

Vediamo ora i comandi utilizzati in R per valutare e cambiare la working directory nella propria sessione di lavoro.

\begin{tip}[One "/" to Rule Them All]

Nota negli esempi successivi, come in R il caratere \texttt{"/"} sia sempre utilizzato per separare le cartelle nella definizione del path indipendentemente dal sistema operativo.

\end{tip}

\hypertarget{attuale-working-directory}{%
\subsubsection*{Attuale Working Directory}\label{attuale-working-directory}}
\addcontentsline{toc}{subsubsection}{Attuale Working Directory}

In R è possibile valutare l'attuale working directory utilizzando il comando \texttt{getwd()} che restituirà l'absolute path dell'attuale posizione.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getwd}\NormalTok{()}
\CommentTok{## [1] "/Users/<username>/Desktop/Introduction2R"}
\end{Highlighting}
\end{Shaded}

In alternativa, l'attuale working directory è anche riportata in alto a sinistra della Console come mostrato in Figura \ref{fig:current-wd}.

\begin{figure}

{\centering \includegraphics[width=0.95\linewidth]{images/current-wd} 

}

\caption{Workig directory dell'attuale sessione di lavoro}\label{fig:current-wd}
\end{figure}

Premendo la freccia al suo fianco il pannello \emph{Files} in basso a destra sarà reindirizzato direttamento alla workig directory dell'attuale sessione di lavoro. In questo modo sarà facile navigare tra i file e cartelle presenti al suo interno (vedi Figura \ref{fig:current-folder}).

\begin{figure}

{\centering \includegraphics[width=0.65\linewidth]{images/current-folder} 

}

\caption{Workig directory dell'attuale sessione di lavoro}\label{fig:current-folder}
\end{figure}

\hypertarget{cambiare-working-directory}{%
\subsubsection*{Cambiare Working Directory}\label{cambiare-working-directory}}
\addcontentsline{toc}{subsubsection}{Cambiare Working Directory}

Per cambiare la working directory è possibile utilizzare il comando \texttt{setwd()} indicando il path (absolute o relative) della nuova working directory. Nota come, nel caso in cui venga indicato un relative path, questo dovrà indicare la posizione della nuova working directory rispetto alla vecchia working directory.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getwd}\NormalTok{()}
\CommentTok{## [1] "/Users/<username>/Desktop/Introduction2R"}

\KeywordTok{setwd}\NormalTok{(}\StringTok{"Dati/"}\NormalTok{)}

\KeywordTok{getwd}\NormalTok{()}
\CommentTok{## [1] "/Users/<username>/Desktop/Introduction2R/Dati"}
\end{Highlighting}
\end{Shaded}

In alternativa è possibile selezionare l'opzione \emph{``Choose Directory''} dal menù \emph{``Session''} \textgreater{} \emph{``Set Working Directory''} come mostrato in Figura \ref{fig:set-wd}. Verrà quindi richiesto di selezionare la working directory desiderata e preme ``\emph{Open}''.

\begin{figure}

{\centering \includegraphics[width=0.95\linewidth]{images/set-wd} 

}

\caption{Definire la working directory}\label{fig:set-wd}
\end{figure}

\begin{trick}[Show me the Path]

Nota come sia possibile nel digitare il path sfruttare l'autocompletamento. All'interno delle virgolette \texttt{""} premi il tasto \texttt{Tab} per visualizzare i suggerimenti dei path relativi alla attuale working directory.

\includegraphics[width=0.75\textwidth,height=\textheight]{images/path-autocomplete.png}

E' possibile inoltre utilizzare i caratteri speciali \texttt{"./"} e \texttt{"../"} per indicare rispettivamente l'attuale working directory e la cartella del livello superiore (i.e., \emph{parent folder}) che include l'attuale working directory. \texttt{"../"} ci permette quindi di navigare a ritroso dalla nostra attuale posizione tra le cartelle del computer.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getwd}\NormalTok{()}
\CommentTok{## [1] "/Users/<username>/Desktop/Introduction2R"}

\KeywordTok{setwd}\NormalTok{(}\StringTok{"../"}\NormalTok{)}

\KeywordTok{getwd}\NormalTok{()}
\CommentTok{## [1] "/Users/<username>/Desktop/"}
\end{Highlighting}
\end{Shaded}

\end{trick}

\hypertarget{packages}{%
\section{R-packages}\label{packages}}

Uno dei grandi punti di forza di R è quella di poter estendere le proprie funzioni di base in modo semplice ed intuitivo utilizzando nuovi pacchetti. Al momento esistono oltre \textbf{17'000} pachetti disponibili gratuitamente sul CRAN (la repository ufficiale di R). Questi pacchetti sono stati sviluppati dall'immensa comunity di R per svolgere ogni sorta di compito. Si potrebbe dire quindi che in R ogni cosa sia possibile, basta trovare il giusto pacchetto (oppure crearlo!).

Quando abbiamo installato R in automatico sono stati installati una serie di pacchetti che costituiscono la \textbf{system library}, ovvero tutti quei pacchetti di base che permettono il fuzionamento di R. Tuttavia, gli altri pacchetti non sono disponibili da subito. Per utilizzare le funzioni di altri pacchetti, è necessario seguire una procedura in due step come rappresentato in Figura \ref{fig:packages-process}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Scaricare ed installare i pacchetti sul nostro computer}. I pacchetti sono disponibili gratuitamente online nella reopsitory del CRAN, una sorta di archivio. Vengono quindi scaricati ed installati nella nostra \emph{library}, ovvero la raccolta di tutti i pacchetti di R disponibili sul nostro computer.
\item
  \textbf{Caricare il paccheto nella sessione di lavoro}. Anche se il paccheto è installato nella nostra library non siamo ancora pronti per utilizzare le sue funzioni. Sarà necessario prima caricare il pacchetto nella nostra sessione di lavoro. Solo ora le funzionni del pacchetto saranno effetivamente disponibili per essere usate.
\end{enumerate}

\begin{figure}

{\centering \includegraphics[width=0.95\linewidth]{images/packages-process} 

}

\caption{Utilizzare i paccheti in R}\label{fig:packages-process}
\end{figure}

Questo procedimento in due step potrebbe sembrare poco intuitivo. \emph{``Perchè dover caricare qualcosa che è già installato?''} La risposta è molto semplice ci serve per mantenere efficiente e sotto controllo la nostra sessione di lavoro. Infatti non avremo mai bisogno di tutti i pacchetti installati ma a seconda dei compiti da eseguire utilizzeremo di volta in volta solo alcuni pacchetti specifici. Se tutti i pacchetti fossero caricati automaticamente ogni volta sarebbe un inutile spreco di memoria e si creerebbero facilmente dei conflitti. Ovvero, alcune funzioni di diversi pacchetti potrebbero avere lo stesso nome ma scopi diversi. Sarebbe quindi molto facile ottenere errori o comunque risultati non validi.

Vediamo ora come eseguire queste operazioni in R.

\hypertarget{install.packages}{%
\subsection{install.packages()}\label{install.packages}}

Per installare dei pacchetti dal CRAN nella nostra library è possibile eseguire il comando \texttt{install.packages()} indicando tra parentesi il nome del pacchetto desiderato.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Un ottimo pacchetto per le analisi statistiche di John Fox}
\CommentTok{# un grandissimo statistico...per gli amici Jonny la volpe ;)}
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"car"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In alternativa è possibile utilizzare il pulsante \emph{``Install''} nella barra in alto a sinistra del pannello Packages ( vedi Figura \ref{fig:packages-install}), indicando successivamente il nome del pacchetto desiderato.

\begin{figure}

{\centering \includegraphics[width=0.65\linewidth]{images/packages-install} 

}

\caption{Installare paccektti tramite interfacci RStudio}\label{fig:packages-install}
\end{figure}

Nota come installare un pacchetto potrebbe comportare l'installazione di più pacchetti. Questo perchè verranno automaticamente installate anche le \emph{dependencies} del pacchetto, ovverro, tutti i pacchetti usati internamente dal pacchetto di interesse che quindi necessari per il suo corretto funzionaemnto (come in un gioco di matrioske).

Una volta installato il pacchetto, questo comarirà nella library ovvero la lista dei pacchetti disponibili mostrata nel pannello Packages (vedi Figura \ref{fig:library-car}).

\begin{figure}

{\centering \includegraphics[width=0.65\linewidth]{images/library-car} 

}

\caption{Il pacchetto car è ora disponibile nella library}\label{fig:library-car}
\end{figure}

\begin{design}[Binary or Source Version?]

Nell'installare dei pacchetti, potrebbe accadere che R presenti un messaggio simile al seguente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{There are binary versions available but the}
\NormalTok{  source versions are later}\OperatorTok{:}
\StringTok{           }\NormalTok{binary source needs_compilation}
\NormalTok{devtools   }\DecValTok{1}\NormalTok{.}\FloatTok{13.4}  \DecValTok{2}\NormalTok{.}\FloatTok{0.1}             \OtherTok{FALSE}
\NormalTok{    [... una lista di vari pacchetti...]}

\NormalTok{Do you want to install from sources the packages which need compilation?}
\end{Highlighting}
\end{Shaded}

In breve, la risposta da dare è \textbf{NO} (\texttt{"n"}). Ma che cosa ci sta effetivamente chiedendo R? Esistono diversi modi in cui un pacchetto è disponibile, tra i principali abbiamo:

\begin{itemize}
\tightlist
\item
  \textbf{Versione Binary} - pronta all'uso e semplice da installare
\item
  \textbf{Versione Source} - richiede una particolare procedura per essere installata detta compilazione
\end{itemize}

In genere quindi, è sempre preferibile installare la versione \emph{Binary}. Tuttavia, in questo caso R ci avverte che, per alcuni pacchetti, gli aggiornameni più recenti sono disponibili solo nella versione \emph{Source} e ci chiede quindi se installarli attraverso la procedura di compilazione.

E' preferibile rispondere \emph{``no''}, installando così la versione \emph{Binary} pronta all'uso anche se meno aggiornata. Qualora fosse richiesto obbligatoriamente di installare un pacchetto nella version \emph{Source} (perchè ci servono gli ultimi aggiornamenti o perchè non disponibile altrimenti) dovremmo avere prima installato \textbf{R tools} (vedi \emph{``Approfondimento: R Tools''} nel Capitolo \ref{install-r}), che ci fornirà gli strumenti necessari per compilare i pacchetti.

Per una discussione dettagliata vedi \url{https://community.rstudio.com/t/meaning-of-common-message-when-install-a-package-there-are-binary-versions-available-but-the-source-versions-are-later/2431} e \url{https://r-pkgs.org/package-structure-state.html}

\end{design}

\hypertarget{library}{%
\subsection{library()}\label{library}}

Per utilizzare le funzioni di un pacchetto già presente nella notra library, dobbiamo ora caricarlo nella nostra sessione di lavoro. Per fare ciò, posssiamo utilizzare il comando \texttt{library()} indicando tra parentesi il nome del pacchetto richiesto.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(car)}
\end{Highlighting}
\end{Shaded}

In alternativa è possibile spuntare il riquadro alla sinistra del nome del pacchetto dal pannello Packages come mostrato in Figura \ref{fig:load-package}. Nota tuttavia come questa procedura sia sconsigliata. Infatti, ogni azione punta-e-clicca dovrebbe essere eseguita ad ogni sessione mentre l'utilizzo di comandi inclusi nello script garantisce la loro esecuzione automatica.

\begin{figure}

{\centering \includegraphics[width=0.65\linewidth]{images/load-package} 

}

\caption{Caricare un pacchetto nella sessione di lavoro}\label{fig:load-package}
\end{figure}

Ora siamo finalmente pronti per utilizzare le funzioni del pacchetto nella nostra sessione di lavro.

\begin{trick}[package::function()]

Esiste un piccolo trucco per utilizzare la funzione di uno specifico pacchetto senza dover caricare il pacchetto nella propria sessione. Per fare questo è possibile usare la sintassi:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{<}\NormalTok{nome}\OperatorTok{-}\NormalTok{pacchetto}\OperatorTok{>}\ErrorTok{::<}\NormalTok{nome}\OperatorTok{-}\NormalTok{funzione}\OperatorTok{>}\NormalTok{()}

\CommentTok{# Esempio con la funzione Anova del pacchetto car}
\NormalTok{car}\OperatorTok{::}\KeywordTok{Anova}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

L'utilizzo dei \texttt{::} ci permette di richiamare direttamente la funzione desiderata. La differennza tra l'uso di \texttt{library()} e l'uso di \texttt{::} riguarda aspetti abbastanza avanzati di R (per un approfondimento vedi \url{https://r-pkgs.org/namespace.html}). In estrema sintesi, possiamo dire che in alcuni casi è preferibile non caricare un'intero pacchetto se di questo abbiamo bisogno di un'unica funzione.

\end{trick}

\hypertarget{aggiornare-e-rimuovere-pacchetti}{%
\subsection{Aggiornare e Rimuovere Pacchetti}\label{aggiornare-e-rimuovere-pacchetti}}

Anche i pacchettti come ogni altro software vengono aggiornati nel corso del tempo fornendo nuove funzionalità e risolvendo eventuli problemi. Per aggiornare i pacchetti alla versione più recente è possibile eseguire il comando \texttt{update.packages()} senza inidare nulla tra le parentesi.

In alternativa è possibile premere il pulsante \emph{``Update''} nella barra in alto a sinistra del pannello Packages ( vedi Figura \ref{fig:library-version}), indicando successivamente i pachetti che si desidera aggiornare. Nota come nella lista dei pacchetti venga riportata l'attuale versione alla voce \emph{``Version''}.

\begin{figure}

{\centering \includegraphics[width=0.65\linewidth]{images/library-version} 

}

\caption{Aggiornare i pacchetti}\label{fig:library-version}
\end{figure}

Nel caso in cui si vogli invece rimuover uno specifico pacchetto, è possibile eseguire il comando \texttt{remove.packages()} indicando tra le parentesi il nome del pacchetto.

In alternativa è possibile premere il pulsante \texttt{x} alla destra del paccehettto nel pannello Packages come mostrao in Figura \ref{fig:library-remove}.

\begin{figure}

{\centering \includegraphics[width=0.65\linewidth]{images/library-remove} 

}

\caption{Rimuovere un pacchetto}\label{fig:library-remove}
\end{figure}

\hypertarget{documentazione-pacchetti}{%
\subsection{Documentazione Pacchetti}\label{documentazione-pacchetti}}

Ogni pacchetto include la documentazione delle proprie funzioni e delle \emph{vignette} ovvero dei brevi tutorial che mostrano degli esempi di applicazione e utilizzo del pacchetto.

\begin{itemize}
\item
  \textbf{Documentazione funzione} - Per accedere alla documentazione di una funzione è sufficiente utilizzare il comando \texttt{?\textless{}nome-funzione\textgreater{}} oppure \texttt{help(\textless{}nome-funzione\textgreater{})}. Ricorda è necessario avere prima caricato il pacchetto altrimenti la funzione non risulta ancora disponibile. In alternativa si potrebbe estendere la ricerca utilizzando il comando \texttt{??}.
\item
  \textbf{Vignette} - Per ottenere la lista di tutte le vignette di un determinato pacchetto è possibile utilizzare il comando \texttt{browseVignettes(package\ =\ \textless{}nome-pacchetto\textgreater{})\textquotesingle{}}. Mentre, per accedere ad una specifica vignetta, si utilizza il comando \texttt{vignette("\textless{}name-vignetta\textgreater{}")}.
\item
  \textbf{Documentazione intero pacchetto} - Premendo il nome del pacchetto dal pannello Packages in basso a destra, è possibile accedere alla lista di tutte le informazioni relative al pacchetto come riportato in Figura \ref{fig:package-documentation}. Vengono prima forniti i link per le vignette ed altri file relativi alle caratteristiche del pacchetto. Successivamente sono presentate in ordine alfabetico tutte le funzioni.
\end{itemize}

\begin{figure}

{\centering \includegraphics[width=0.65\linewidth]{images/package-documentation} 

}

\caption{Documetazione del pacchetto car}\label{fig:package-documentation}
\end{figure}

Ricordate tuttavia che in ogni caso la più grande risorsa di informazioni è come sempre google. Spesso i pacchetti più importanti hanno addirittura un proprio sito in cui raccolgono molto materiale utile. Ma comunque in ogni caso in internet sono sempre disponibili moltissimi tutorial ed esempi.

\begin{design}[Github]

Il CRAN non è l'unica risorsa da cui è possibile installare dei pacchetti di R tuttavia è quella ufficiale e garantisce un certo standard e stabilità dei pacchetti presenti. In internet esistono molte altre repository che raccolgono paccetti di R (e software in generale) tra cui una delle più popolari è certamente GitHub (\url{https://github.com/}).

Github viene utilizzato come piattaforma di sviluppo per molti pacchetti di R ed è quindi possibile trovarve le ultime versioni di sviluppo dei pacchetti con gli aggirnamenti più recenti o anche nuovi pacchetti non ancora disponibili sul CRAN. Va sottolineato tuttavia, come quete siano appunto delle versioni di sviluppo e quindi potrebbero presentare maggiori problemi. Inoltre per installare i pacchetti in questo modo, è richiesta l'installzione di \textbf{R tools} (vedi \emph{``Approfondimento: R Tools''} nel Capitolo \ref{install-r}).

Per installare un pacchetto direttamente da Github è posibile utilizzare il comando \texttt{install\_github()} del pacchetto \texttt{devtools}, indicanto tra parentesi la l'url della repository desiderata.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"devtools"}\NormalTok{)}

\CommentTok{# ggplot2 il miglior pacchetto per grafici}
\NormalTok{devtools}\OperatorTok{::}\KeywordTok{install_github}\NormalTok{(}\StringTok{"https://github.com/tidyverse/ggplot2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\end{design}

\hypertarget{working-session}{%
\chapter{Sessione di Lavoro}\label{working-session}}

In questo capitolo, discuteremo di alcuni aspetti generali delle sessioni di lavoro in R. Descriveremo delle buone abitudini riguardanti l'organizzazione degli scripts e l'uso degli \emph{RStudio Projects} per essere ordinati ed efficaci nel proprio lavoro. Infine approfondiremo l'uso dei messaggi di R ed in particolare come comportarsi in caso di errori.

\hypertarget{organizzazione-script}{%
\section{Organizzazione Script}\label{organizzazione-script}}

Abbiamo visto che idealmente tutti i passaggi delle nostre analisi devono essere raccolti in modo ordinato all'interno di uno script. Eseguendo in ordine linea per linea i comandi, dovrebbe essere possibile svolgere tutte le analisi fino ad ottenere i risultati desiderati.

Vediamo ora una serie di buone regole per organizzare in modo ordinato il codice all'interno di uno script e facilitare la sua lettura.

\hypertarget{creare-delle-sezioni}{%
\subsection{Creare delle Sezioni}\label{creare-delle-sezioni}}

Per mantenere chiara l'oreganizzazione degli script e facilitare la sua comprensione, è utile suddividere il codice in sezioni dove vengono eseguiti i diversi step delle analisi. In RStudio è possibile creare una sezione aggiungendo al termine di una linea di commento i caratteri \texttt{\#\#\#\#} o \texttt{-\/-\/-\/-}. Il testo del commento verrà considerao il titolo della sezione e comparirà una piccola freccia a lato del numero di riga. E' possibile utilizzare a piacere i caratteri \texttt{\#} o \texttt{-} per creare lo stile desiderato, l'importante è che la linea si concluda con almeno quattro caratteri identici.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Sezione 1 ####}

\CommentTok{# Sezione 2 ----}

\CommentTok{#----    Sezione 3    ----}

\CommentTok{####   Sezione non valida   --##}
\end{Highlighting}
\end{Shaded}

A titolo del tutto esemplificativo prendiamo in esempio la divisione in sezioni utilizzata nello script in Figura \ref{fig:script-template}.

\begin{figure}

{\centering \includegraphics[width=0.85\linewidth]{images/script-template} 

}

\caption{Esempio di suddivisione in sezioni di uno script}\label{fig:script-template}
\end{figure}

\begin{itemize}
\tightlist
\item
  \textbf{Titolo} - Un titolo esplicativo del contenuto dello script. E' possibile utilizzare altri caratteri all'interno dei commenti per creare l'effetto desiderato.
\item
  \textbf{Intorduzione} - Descrizione e utili informazioni che riguardano sia l'obbiettivo del lavoro che l'esecuzione del codice (e.g., dove sono disponibili i dati, eventuali specifiche tecniche). Potrebbe essere utile anche indicare l'autore e la data del lavoro.
\item
  \textbf{Setting} - Sezione fondamentale in cui si predispone l'abiente di lavoro. Le operazioni da svolgere sono:

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    \texttt{rm(list\ =\ ls())} per pulire l'Environment da eventuali oggetti in modo da eseguire lo script partendo da un ambiente vuoto (vedi Capitolo \ref{environment}).
  \item
    \texttt{setwd()} per settare la working directory per assicuraci che i comandi siano eseguiti dalla correttta posizione nel nostro computer (vedi Capitolo \ref{working-directory}).
  \item
    \texttt{library()} per caricare i pacchetti utilizzati nel corso delle analisi (vedi Capitolo \ref{packages}).
  \end{enumerate}
\item
  \textbf{Caricare e Pulire i Dati} - Generica sezione in cui eseguire l'importazione e pulizia dei dati.
\item
  \textbf{Codifica e Scoring dei Dati} - Generica sezione in cui eseguire la codifica ed eventuale scoring dei dati.
\item
  \textbf{Analisi Descrittive} - Generica sezione in cui eseguire le analisi descrittive.
\item
  \textbf{Analisi Inferenziali} - Generica sezione in cui eseguire le analisi inferenziali
\end{itemize}

Oltre che a mantenere ordinato e chiaro il codice, suddividere il proprio script in sezioni ci permette anche di navigare facilmente tra le diverse parti del codice. Possiamo infatti sfruttare l'indice che automaticamente viene creato. L'indice è consultabile premendo il tasto in alto a destra dello script da cui successivamente selezionare la sezione desiderata (vedi Figura \ref{fig:toc-side}).

\begin{figure}

{\centering \includegraphics[width=0.85\linewidth]{images/toc-side} 

}

\caption{Indice in alto per navigazione sezioni}\label{fig:toc-side}
\end{figure}

In alternativa, è possibile utilizzare il menù in basso a sinistra dello script (vedi Figura \ref{fig:toc-bottom}).

\begin{figure}

{\centering \includegraphics[width=0.85\linewidth]{images/toc-bottom} 

}

\caption{Menù in basso per navigazione sezioni}\label{fig:toc-bottom}
\end{figure}

Infine, un altro vantaggio è quello di poter compattare o espandere le sezioni di codice all'interno dell'editor, utilizzando le frecce a lato del numero di riga (vedi Figura \ref{fig:section-closed}).

\begin{figure}

{\centering \includegraphics[width=0.85\linewidth]{images/section-closed} 

}

\caption{Compattare ed espandere le sezioni di codice}\label{fig:section-closed}
\end{figure}

\hypertarget{sintassi}{%
\subsection{Sintassi}\label{sintassi}}

Elenchiamo qui altre buone norme nella scrittura del codice che ne facilitano la comprensione.

\hypertarget{commenti}{%
\subsubsection*{Commenti}\label{commenti}}
\addcontentsline{toc}{subsubsection}{Commenti}

L'uso dei commenti è molto importante, ci permette di documentare le varie parti del codice e chiarire eventuli comandi difficili da capire. Tuttavia, non è necessario commentare ogni singola riga di codice ed anzi è meglio evitare di commentare laddove i comandi sono facilemtne interpetabili semplicemnte leggendo il codice.

La capacità di scrivere commenti utili ed eviare quelli rindondanti si impara con l'esperienza. In generale un commento non dovrebbe indicare \emph{``che cosa''} ma piuttosto il \emph{``perchè''} di quella parte di codice. Infatti il cosa è facilmente interpretabile dal codice stesso mentre il perchè potrebbe essere meno ovvio e soprattutto più utile per la comprensione dell'intero script. Ad esempio:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{10} \CommentTok{# assegno a x il valore 10}
\NormalTok{x <-}\StringTok{ }\DecValTok{10} \CommentTok{# definisco massimo numero risposte}
\end{Highlighting}
\end{Shaded}

Il primo commento è inutile poichè è facilmente comprensibile dal codice stesso, mentre il secondo commento è motlo utile perchè chiarisce il significato della variabile e mi faciliterà nella comprensione del codice.

\hypertarget{nomi-oggetti}{%
\subsubsection*{Nomi Oggetti}\label{nomi-oggetti}}
\addcontentsline{toc}{subsubsection}{Nomi Oggetti}

Abbiamo visto nel Capitolo \ref{objects-names} le regole che discriminano nomi validi da nomi non validi e le convenzioni da seguire nella definizione di un nome. Ricordiamo qui le caratterisiche che un nome deve avere per facilitare la comprensione del codice. Il nome di un oggetto deve essere:

\begin{itemize}
\tightlist
\item
  \textbf{auto-descrittivo} - Dal solo nome dovrebbe essere possibile intuire il contenuto dell'oggetto. E' meglio quindi evitare nomi generici (quali \texttt{x} o \texttt{y}) ed utilizzare invece nomi che chiaramente descrivano il contenuto dell'oggetto.
\item
  \textbf{della giusta lunghezza} - Non deve essere ne troppo breve (evitare sigle incomprensibili) ma neppure troppo lunghi. In genere sono sufficienti 2 o 3 parole per descrivere chiaramente un oggetto.
\end{itemize}

E' inoltre importante essere \textbf{consistenti} nella scelta dello stile con cui si nominano le variabili. In genere è preferibile usare lo \textbf{snake\_case} rispetto al \textbf{CamelCase}, ma la scelta è comunque libera. Tuttavia, una volta presa una decisione, è bene mantenerla per facilitare la comprensione del codice.

\hypertarget{esplicitare-argomenti}{%
\subsubsection*{Esplicitare Argomenti}\label{esplicitare-argomenti}}
\addcontentsline{toc}{subsubsection}{Esplicitare Argomenti}

Abbiamo visto nel Capitolo \ref{function-arguments} l'importanza di esplicitare il nome degli argomenti quando vengono utilizzati nelle funzioni. Specificando a che cosa si riferiscono i vari valori facilitiamo la lettura e la comprensione del codice. Ad esempio:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Potrebbe non essere chiaro se intendiamo una sequennza tra 0 e 10 di lunghezza 2 o a intervalli di 2. Specificando gli argomenti evitiamo incomprensioni e possibili errori.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{, }\DataTypeTok{to =} \DecValTok{10}\NormalTok{, }\DataTypeTok{by =} \DecValTok{2}\NormalTok{)}
\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{, }\DataTypeTok{to =} \DecValTok{10}\NormalTok{, }\DataTypeTok{length.out =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{spazi-indentazione-ed-allineamento}{%
\subsubsection*{Spazi, Indentazione ed allineamento}\label{spazi-indentazione-ed-allineamento}}
\addcontentsline{toc}{subsubsection}{Spazi, Indentazione ed allineamento}

Al contrario di molti altri software, R non impone regole severe nell'utilizzo di spazi, indentazioni ed allineamenti ed in genere è molto permissivo per quanto riguarda la sintassi del codice. Tuttavia è importante ricordare che:

\begin{quote}
Good coding style is like using correct punctuation. You can manage without it, but it sure makes things easier to read. Hadley Wickham
\end{quote}

Prendiamo ad esempio le seguenti linee di codice, che includono delle funzioni avanzate di R:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Stile 1}
\NormalTok{k=}\DecValTok{10}\NormalTok{;}\ControlFlowTok{if}\NormalTok{(k}\OperatorTok{<}\DecValTok{5}\NormalTok{)\{x<-}\DecValTok{5}\OperatorTok{:}\DecValTok{15}\NormalTok{\}}\ControlFlowTok{else}\NormalTok{\{x<-}\KeywordTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{16}\NormalTok{,}\DecValTok{4}\NormalTok{)\};y=}\DecValTok{7}\OperatorTok{*}\DecValTok{2-12}\NormalTok{;}\KeywordTok{mean}\NormalTok{(x}\OperatorTok{/}\NormalTok{y)}
\CommentTok{## [1] 4}

\CommentTok{# Stile 2}
\NormalTok{k <-}\StringTok{  }\DecValTok{10}

\ControlFlowTok{if}\NormalTok{ (k }\OperatorTok{<}\StringTok{ }\DecValTok{5}\NormalTok{)\{}
\NormalTok{  x <-}\StringTok{ }\DecValTok{5}\OperatorTok{:}\DecValTok{15}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{  x<-}\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{, }\DataTypeTok{to =} \DecValTok{16}\NormalTok{, }\DataTypeTok{by =} \DecValTok{4}\NormalTok{)}
\NormalTok{\}}

\NormalTok{y <-}\StringTok{ }\DecValTok{7} \OperatorTok{*}\StringTok{ }\DecValTok{2} \OperatorTok{-}\StringTok{ }\DecValTok{12}

\KeywordTok{mean}\NormalTok{(x }\OperatorTok{/}\StringTok{ }\NormalTok{y)}
\CommentTok{## [1] 4}
\end{Highlighting}
\end{Shaded}

Come puoi notare otteniamo in entrambi i casi gli stessi risultati, per R non c'è alcuna differenza. Tuttavia, l'uso di spazi, una corretta indentazione ed un appropriato allineamento facilita la lettura e comprensione del codice.

In genere sono valide le seguenti regole:

\begin{itemize}
\tightlist
\item
  Aggiungi degli \textbf{spazi} intorno agli operatori (\texttt{+}, \texttt{-}, \texttt{\textless{}-}, etc.) per separargli dagli argomenti ad eccezione di \texttt{:}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Good}
\DecValTok{35} \OperatorTok{/}\StringTok{ }\DecValTok{5} \OperatorTok{+}\StringTok{ }\DecValTok{7}
\NormalTok{x <-}\StringTok{ }\DecValTok{0}\OperatorTok{:}\DecValTok{10}

\CommentTok{# Bad}
\DecValTok{35}\OperatorTok{/}\DecValTok{5}\OperatorTok{+}\DecValTok{7}
\NormalTok{x<-}\DecValTok{0} \OperatorTok{:}\StringTok{ }\DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Nelle funzioni aggiungi degli \textbf{spazi} intorno al simbolo \texttt{=} che separa il nome degli argomenti e il loro valore. Aggiungi uno spazio dopo ogni virogola ma non separare il nome della funzione dalla parentesi sinistra.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Good}
\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{, }\DataTypeTok{to =} \DecValTok{10}\NormalTok{, }\DataTypeTok{by =} \DecValTok{2}\NormalTok{)}

\CommentTok{# Bad}
\KeywordTok{seq}\NormalTok{ (}\DataTypeTok{from=}\DecValTok{0}\NormalTok{,}\DataTypeTok{to=}\DecValTok{10}\NormalTok{,}\DataTypeTok{by=}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Usa la corretta \textbf{indentazione} per i blocchi di codice posti all'interno delle parentesi graffe. Il livello di indentazione deve rispecchiare la struttura di annidamento del codice.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Good}
\ControlFlowTok{for}\NormalTok{ (...) \{       }\CommentTok{# loop più esterno}
\NormalTok{  ...}
  \ControlFlowTok{for}\NormalTok{ (...) \{     }\CommentTok{# loop interno}
\NormalTok{    ...}
    \ControlFlowTok{if}\NormalTok{ (...) \{    }\CommentTok{# isruzione condizionale}
\NormalTok{      ...}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}

\CommentTok{# Bad}
\ControlFlowTok{for}\NormalTok{ (...) \{       }\CommentTok{# loop più esterno}
\NormalTok{...}
\ControlFlowTok{for}\NormalTok{ (...) \{     }\CommentTok{# loop interno}
\NormalTok{...}
\ControlFlowTok{if}\NormalTok{ (...) \{    }\CommentTok{# isruzione condizionale}
\NormalTok{...}
\NormalTok{\}}
\NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \textbf{Allinea} gli argomenti di una funzione se questi spaziano più righe.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Good}
\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ ...,}
           \DataTypeTok{name =}\NormalTok{ ...,}
           \DataTypeTok{age =}\NormalTok{ ...,}
           \DataTypeTok{sex =}\NormalTok{ ...)}

\CommentTok{# Bad}
\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ ..., }\DataTypeTok{name =}\NormalTok{ ...,}
\DataTypeTok{age =}\NormalTok{ ..., }\DataTypeTok{sex =}\NormalTok{ ...)}
\end{Highlighting}
\end{Shaded}

\begin{design}[Tutta una Questione di Stile]

Potete trovare ulteriori regole e consigli riguardanti lo stile nella scrittura di codici al seguente link \url{https://irudnyts.github.io/r-coding-style-guide/}.

\end{design}

\hypertarget{r-projects}{%
\section{R projects}\label{r-projects}}

TODO

\hypertarget{piuxf9-di-uno-script}{%
\subsection{Più di uno script}\label{piuxf9-di-uno-script}}

\begin{itemize}
\item
  idea di organizzare in vairi script, cartelle
\item
  working directory tutto in funzione alla cartella
\end{itemize}

\hypertarget{messages-warnings-e-errors}{%
\section{Messages, Warnings e Errors}\label{messages-warnings-e-errors}}

R utilizza la console per comunicare con noi durante le nostre sessioni di lavoro. Oltre a fornirci i risultati dei nostri comandi, R ci segnala anche altre utili informazioni attraverso diverse tipologie di messaggi. In particolare abbiamo:

\begin{itemize}
\tightlist
\item
  \textbf{Messages}: dei semplici messaggi che ci possono aggiornare ad esempio sullo stato di avanzamento di un dato compito oppure fornire suggerimenti sull'uso di una determinata funzione o pacchetto (spesso vengono mostrati quando viene caricato un pacchetto).
\item
  \textbf{Warnings}: questi messaggi sono utlizzati da R per dirci che c'è stato qualche cosa di strano che ha messo in allerta R. R ci avvisa che, sebbene il comando sia stato eseguito ed abbiamo ottenuto un risultato, ci sono stati dei comportamenti inusuali o magari eventuali correzioni apportate in automatico. Nel caso di warnings non ci dobbiamo allramre, è importante controllare che i comandi siano corretti e che abbiamo effetivamente ottenuto il risultato desiderato. Una volta sicuri dei risultati possiamo procedere tranquillamente.
\item
  \textbf{Errors}: R ci avvisa di eventuali errori e problemi che non permettono di eseguire il comando. in questo caso non otterremo nnessun risultato ma sarà necessario capire e risolvere il problema per poi rieseguire nuovamente il comando e procedere.
\end{itemize}

Notiamo quindi come non tutti i messaggi che R ci manda sono dei messaggi di errore. E' quindi importante non spaventarsi ma leggere con attenzione i messaggi, molte volte si tratta semplicemente di avvertimenti o suggerimenti.

Tuttavia gli errori rappresentano sempre il maggiore dei problemi perchè non è possibile procedere nel lavoro senza averli prima risolti. E' importante ricordare che i messaggi di errore non sono delle critiche che R ci rivolge perchè sbagliamo. Al contrario, sono delle richieste di aiuto fatte da R perchè non sa come comportarsi. Per quanto super potente, R è un seplice programma che non può interpretare le nostre richieste ma si basa sull'uso dei comandi che seguono una rigida sintassi. A volte è sufficiente una virgola mancante o un charattere al posto di un numero per mandare in confusione R e richiedere il nostro intervento risolutore.

\hypertarget{risolvere-gli-errori}{%
\subsection{Risolvere gli Errori}\label{risolvere-gli-errori}}

Quando si approccia la scrittura di codice, anche molto semplice, la cosa che sicuramente capiterà più spesso sarà riscontrare messaggi di \textbf{errore} e quindi trovare il modo per risolverli.

\begin{quote}
Qualche programmatore esperto direbbe che l'essenza stessa di programmare è in realtà risolvere gli errori che il codice produce.
\end{quote}

L'\textbf{errore non è quindi un difetto o un imprevisto}, ma parte integrante della scrittura del codice. L'importante è capire come gestirlo.

Abbiamo tutti le immagini in testa di programmatori da film che scrivono codice alla velocità della luce, quando nella realtà dobbiamo spesso affrontare \textbf{bug}, \textbf{errori di output} o altri problemi vari. Una serie di skills utili da imparare sono:

\begin{itemize}
\tightlist
\item
  Comprendere a fondo gli \textbf{errori} (non banale)
\item
  Sapere \textbf{come e dove cercare una soluzione} (ancora meno banale)
\item
  In caso non si trovi una soluzione direttamente, chiedere aiuto in modo efficace
\end{itemize}

\hypertarget{comprendere-gli-errori}{%
\subsubsection*{Comprendere gli errori}\label{comprendere-gli-errori}}
\addcontentsline{toc}{subsubsection}{Comprendere gli errori}

Leggere con attenzione i messaggi di errore è molto importante. R è solitamente abbastanza esplicito nel farci capire il problema. Ad esempio usare una funzione di un pacchetto che non è stato caricato di solito fornisce un messaggio del tipo \texttt{Error\ in\ funzione\ :\ could\ not\ find\ function\ "funzione"}.

Tuttavia, in altre situazioni i messaggi potrebbero non essere altrettanto chiari. Seppur esplicito R è anche molto sintetico e quindi l'utilzzo di un linguaggio molto specifico (e almeno inizialmente poco familiare), potrebbe rendere difficile capire il loro significato o addirittura renderli del tutto incomprensibili. Man mano che diventerete più esperti in R, diventerà sempre più semplice ed immmediato capire quale sia il problema e anche come risolverlo. Ma nel caso non si conosca la soluzione è necessario cercarla in altro modo.

\hypertarget{problema-google-soluzione}{%
\subsubsection*{Problema + Google = Soluzione}\label{problema-google-soluzione}}
\addcontentsline{toc}{subsubsection}{Problema + Google = Soluzione}

In qualsiasi situazione Google è il nostro miglior amico.

Cercando infatti il messaggio di errore/warning su Google, al 99\% avremo altre persone che hanno avuto lo stesso problema e probabilmente anche una soluzione.

\begin{tip}[Ricerca su Google]

Il modo migliore per cercare è copiare e incollare su Google direttamente l'output di errore di R come ad esempio \texttt{Error\ in\ funzione\ :\ could\ not\ find\ function\ "funzione"} piuttosto che descrivere a parole il problema. I messaggi di errore sono standard per tutti, la tua descrizione invece no.

\end{tip}

Cercando in questo modo vedrete che molti dei risultati saranno esattamente riferiti al vostro errore:

\includegraphics{images/stack_question.png}

\hypertarget{chiedere-una-soluzione}{%
\subsubsection*{Chiedere una soluzione}\label{chiedere-una-soluzione}}
\addcontentsline{toc}{subsubsection}{Chiedere una soluzione}

Se invece il vostro probelma non è un messaggio di errore ma un utilizzo specifico di R allora il consiglio è di usare una ricerca del tipo: \texttt{argomento\ +\ breve\ descrizione\ problema\ +\ R}. Nelle sezioni successive vedrete nel dettaglio altri aspetti della programmazione ma se volete ad esempio calcolare la \textbf{media} in R potrete scrivere \texttt{compute\ mean\ in\ R}.
Mi raccomando, fate tutte le ricerche in \textbf{inglese} perchè le possibilità di trovare una soluzione sono molto più alte.

Dopo qualche ricerca, vi renderete conto che il sito che vedrete più spesso si chiama \href{https://stackoverflow.com/}{\textbf{Stack Overflow}}. Questo è una manna dal cielo per tutti i programmatori, a qualsiasi livello di expertise. E' una community dove tramite domande e risposte, si impara a risolvere i vari problemi ed anche a trovare nuovi modi di fare la stessa cosa. E' veramente utile oltre che un ottimo modo per imparare.

L'ultimo punto di questa piccola guida alla ricerca di soluzioni, riguarda il fatto di dover non solo cercare ma anche chiedere. Dopo aver cercato vari post di persone che richiedevano aiuto per un problema noterete che le domande e le risposte hanno sempre una struttura simile. Questo non è solo un fatto stilistico ma anzi è molto utile per uniformare e rendere chiara la domanda ma sopratutto la risposta, in uno spirito di condivisione. C'è anche una \href{https://stackoverflow.com/help/how-to-ask}{guida dedicata} per scrivere la domanda perfetta.

In generale\footnote{Fonte: \href{https://codeblog.jonskeet.uk/2010/08/29/writing-the-perfect-question/}{Writing the perfect question - Jon Skeet}}:

\begin{itemize}
\tightlist
\item
  Titolo: un super riassunto del problema
\item
  Contesto: linguaggio (es. R), quale sistema operativo (es. Windows)
\item
  Descrizione del problema/richiesta: in modo chiaro e semplice ma non troppo generico
\item
  Codice ed eventuali dati per capire il problema
\end{itemize}

L'ultimo punto di questa lista è forse il più importante e si chiama in gergo tecnico \href{https://community.rstudio.com/t/faq-whats-a-reproducible-example-reprex-and-how-do-i-create-one/5219}{\textbf{REPREX}} (\textbf{Rep}roducible \textbf{Ex}ample). E' un tema leggermente più avanzato ma l'idea di fondo è quella di fornire tutte le informazioni possibili per poter riprodurre (e quindi eventualmente trovare una soluzione) il codice di qualcuno nel proprio computer.

Se vi dico ``R non mi fa creare un nuovo oggetto, quale è l'errore?'' è diverso da dire ``il comando \texttt{oggetto\ -\textgreater{}\ 10} mi da questo errore \texttt{Error\ in\ 10\ \textless{}-\ oggetto\ :\ invalid\ (do\_set)\ left-hand\ side\ to\ assignment}, come posso risolvere?''

\begin{trick}[reprex]

Ci sono anche diversi pacchetti in R che rendono automatico creare questi esempi di codice da poter condividere, come il pacchetto \href{https://www.tidyverse.org/help/}{\texttt{reprex}}.

\end{trick}

\hypertarget{part-struttura-dati}{%
\part*{Struttura Dati}\label{part-struttura-dati}}
\addcontentsline{toc}{part}{Struttura Dati}

\hypertarget{introduzione-1}{%
\chapter*{Introduzione}\label{introduzione-1}}
\addcontentsline{toc}{chapter}{Introduzione}

In questa sezione verranno introdotte le principali tipologie di oggetti usati in R . Ovvero le principali strutture in cui possono essere organizzati i dati: Vettori, Matrici, Dataframe e Liste.

Per ognuna di esse descriveremo le loro caretteristiche e vedremo come crearle, modificarle e manipolarle a seconda delle necessità

I capitoli sono così organizzati:

\begin{itemize}
\tightlist
\item
  \textbf{Capitolo \ref{vector} - Vettori}. Impareremo le caratterisiche e l'uso dei vettori soffermandoci anche sulle diverse tipologie di dati.
\item
  \textbf{Capitolo \ref{factors} - Fattori}. Impareremo le caratterisiche e l'uso dei fattori un particolare tipo di vettori usati per le variabili categoriali ed ordinali.
\end{itemize}

\hypertarget{vector}{%
\chapter{Vettori}\label{vector}}

I vettori sono la struttura dati più semplice tra quelle presenti in R. Un vettore non è altro che un insieme di elementi disposti in uno specifico ordine e possiamo quindi immaginarlo in modo simile a quanto rappresentato in Figura \ref{fig:vector}.

\begin{figure}

{\centering \includegraphics[width=0.65\linewidth]{images/vector} 

}

\caption{Rappresentazione della struttura di un vettore di lunghezza *n*}\label{fig:vector}
\end{figure}

Due caratteristiche importanti di un vettore sono:

\begin{itemize}
\tightlist
\item
  la \textbf{lunghezza} - il numero di elementi da cui è formato il vettore
\item
  la \textbf{tipologia} - la tipologia di dati da cui è formato il vettore. Un vettore infatti deve esssere formato da \textbf{elementi tutti dello stesso tipo} e pertanto esistono diversi vettori a seconda della tipologia di dati da cui è formato (valori numerici, valori interi, valori logici, valori carattere).
\end{itemize}

E' fondamentale inoltre sottolineare come ogni \textbf{elemento} di un vettore sia caratterizzato da:

\begin{itemize}
\tightlist
\item
  un \textbf{valore} - ovvero il valore dell'elemento che può essere di qualsiasi tipo ad esempio un numero o una serie di caratteri.
\item
  un \textbf{indice di posizione} - ovvero un numero intero positivo che identifica la sua posizione all'interno del vettore.
\end{itemize}

Notiamo quindi come i vettori \(x\) e \(y\) così definiti:
\[
x = [1, 3, 5];\ \ \ y = [3, 1, 5],
\]
sebbene includano gli stessi elementi, non sono identici poichè differiscono per la loro disposizione. Tutto questo ci serve solo per ribadire come l'ordine degli elementi sia fondamentale per la valutazione di un vettore.

Vedimao ora come creare dei vettori in R e come compiere le comuni operazini di selezione e manipolazione di vettori. Successivamente approfondiremo le caratteristiche dei vettori valutandone le diverse tipologie.

\hypertarget{creazione}{%
\section{Creazione}\label{creazione}}

In realtà abbiamo già incontrato dei vettori nei precedenti capitoli poichè anche le variabili con un singolo valore altro non sono che un vettore di lunghezza 1. Tuttavia, per creare dei vettori di più elementi dobbiamo utilizzare il comando \texttt{c()}, ovvero \emph{``combine''}, indicando tra le parentesi i valori degli elementi nella sucessione desiderata e separati da una virgola. Avremo quindi la seguente sintassi:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nome_vettore <-}\StringTok{ }\KeywordTok{c}\NormalTok{(x_}\DecValTok{1}\NormalTok{, x_}\DecValTok{2}\NormalTok{, x_}\DecValTok{3}\NormalTok{, ..., x_n)}
\end{Highlighting}
\end{Shaded}

Nota come gli elementi di un vettore debbano essere tutti della stessa tipologia ad esempio valori numerici o valori carattere.

\begin{design}[Sequenze - ':', seq() e rep() ]

In altrentativa è possibile utilizzare qualsiasi funzione che restituisca come output una sequenza di valori sotto forma di vettore. Tra le funzioni più usate per creare delle sequenze abbiammo:

\begin{itemize}
\tightlist
\item
  \texttt{\textless{}from\textgreater{}:\textless{}to\textgreater{}} - Genera una sequenza di valori numerici crescenti (o decrescenti) dal primo valore indicato (\texttt{\textless{}from\textgreater{}}) al secondo valore indicato (\texttt{\textless{}to\textgreater{}}) a step di 1 (o -1 ).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# sequenza crescente}
\DecValTok{1}\OperatorTok{:}\DecValTok{5}
\CommentTok{## [1] 1 2 3 4 5}

\CommentTok{# sequenza decrescente}
\DecValTok{2}\OperatorTok{:-}\DecValTok{2}
\CommentTok{## [1]  2  1  0 -1 -2}

\CommentTok{# sequenza con valori decimali}
\FloatTok{5.3}\OperatorTok{:}\DecValTok{10}
\CommentTok{## [1] 5.3 6.3 7.3 8.3 9.3}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{seq(from\ =\ ,\ to\ =\ ,\ by\ =\ ,\ length.out\ =\ )} - Genera una sequenza regolare di valori numerici compresi tra \texttt{from} e \texttt{to} con incrementi indicati da \texttt{by}, oppure di lunghezza conplessiva indicata da \texttt{length.out} (vedi \texttt{?seq()} per maggiori dettagli).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# sequenza a incrementi di 2}
\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{, }\DataTypeTok{to =} \DecValTok{10}\NormalTok{, }\DataTypeTok{by =} \DecValTok{2}\NormalTok{)}
\CommentTok{## [1]  0  2  4  6  8 10}

\CommentTok{# sequenza di 5 elementi}
\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{, }\DataTypeTok{to =} \DecValTok{1}\NormalTok{, }\DataTypeTok{length.out =} \DecValTok{5}\NormalTok{)}
\CommentTok{## [1] 0.00 0.25 0.50 0.75 1.00}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{rep(x,\ times\ =\ ,\ each\ =\ )} - Genera una sequenza di valori ripetendo i valori contenuti in \texttt{x}. I valori di \texttt{x} posssono essere ripetuti nello stesso ordine più volte specificando \texttt{times} oppure ripetuti ciascuno più volte specificando \texttt{each} (vedi \texttt{?rep()} per maggiori dettagli).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# sequenza a incrementi di 2}
\KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"foo"}\NormalTok{, }\StringTok{"bar"}\NormalTok{), }\DataTypeTok{times =} \DecValTok{3}\NormalTok{)}
\CommentTok{## [1] "foo" "bar" "foo" "bar" "foo" "bar"}

\CommentTok{# sequenza di 5 elementi}
\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DataTypeTok{each =} \DecValTok{2}\NormalTok{)}
\CommentTok{## [1] 1 1 2 2 3 3}
\end{Highlighting}
\end{Shaded}

\end{design}

\hypertarget{esercizi-2}{%
\subsection*{Esercizi}\label{esercizi-2}}
\addcontentsline{toc}{subsection}{Esercizi}

Famigliarizza con la creazione di vettori (\href{https://github.com/psicostat/Introduction2R/blob/master/exercises/chapter-07-vectors.R}{soluzioni}):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Crea il vettore \texttt{x} contenente i numeri 4, 6, 12, 34, 8
\item
  Crea il vettore \texttt{y} contenente tutti i numeri pari compresi tra 1 e 25 (\texttt{?seq()})
\item
  Crea il vettore \texttt{z} contenente tutti i primi 10 multipli di 7 partendo da 13 (\texttt{?seq()})
\item
  Crea il vettore \texttt{s} in cui le lettere \texttt{"A"},\texttt{"B"} e \texttt{"C"} vengono ripetute nel medesimo ordine 4 volte (\texttt{?rep()})
\item
  Crea il vettore \texttt{t} in cui le letter \texttt{"A"},\texttt{"B"} e \texttt{"C"} vengono ripetute ognuna 4 volte (\texttt{?rep()})
\item
  Genera il seguente output in modo pigro, ovvero scrivendo meno codice possibile ;)
\end{enumerate}

\begin{verbatim}
## [1] "foo" "foo" "bar" "bar" "foo" "foo" "bar" "bar"
\end{verbatim}

\hypertarget{selezione-elementi}{%
\section{Selezione Elementi}\label{selezione-elementi}}

Una volta creato un vettore potrebbe essere necessario selezionare uno o più dei suoi elementi. In R per selezionare gli elementi di un vettore si utilizzano le \textbf{parentesi quadre} \texttt{{[}{]}} dopo il nome del vettore, indicando al loro interno \textbf{l'indice di posizione} degli elementi desiderati:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nome_vettore[}\OperatorTok{<}\NormalTok{indice}\OperatorTok{-}\NormalTok{posizione}\OperatorTok{>}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Attenzione, non devo quindi indicare il valore dell'elemento desiderato ma il suo indice di posizione. Ad esempio:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# dato il vettore}
\NormalTok{my_numbers <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{8}\NormalTok{)}

\CommentTok{# per selezionare il valore 4 utilizzo il suo indice di posizione ovvero 2}
\NormalTok{my_numbers[}\DecValTok{2}\NormalTok{]}
\CommentTok{## [1] 4}

\CommentTok{# Se utilizzassi il suo valore (ovvero 4) }
\CommentTok{# otterrei l'elemento che occupa la 4° posizione}
\NormalTok{my_numbers[}\DecValTok{4}\NormalTok{]}
\CommentTok{## [1] 8}
\end{Highlighting}
\end{Shaded}

Per selezionare più elementi è necessario indicare tra le parentesi quadre tutti gli indici di posizione degli elementi desiderati. Nota come non sia possibile fornire semplicemente i singoli indici numerici ma questi devono essere raccolti in un vettore, ad esempio usando la funzione \texttt{c()}. Praticamente usiamo un vetore di indici per selezionare gli elemeni desiderati dal nostro vettore iniziale.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# ERRATA selezione più valori }
\NormalTok{my_numbers[}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{]}
\CommentTok{## Error in my_numbers[1, 2, 3]: incorrect number of dimensions}

\CommentTok{# CORRETTA selezione più valori}
\NormalTok{my_numbers[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)]}
\CommentTok{## [1] 2 4 6}
\NormalTok{my_numbers[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\CommentTok{## [1] 2 4 6}
\end{Highlighting}
\end{Shaded}

\begin{tip}[Selezionare non è Modificare]

Nota come l'operazione di selezione non modifichi l'oggetto iniziale. Pertanto è necessario salvare il risultato della selezione se si desidera mantenere le modifiche.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_words <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"foo"}\NormalTok{, }\StringTok{"bar"}\NormalTok{, }\StringTok{"baz"}\NormalTok{, }\StringTok{"qux"}\NormalTok{)}

\CommentTok{# Seleziono i primi 2 elementi}
\NormalTok{my_words[}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{]}
\CommentTok{## [1] "foo" "bar"}

\CommentTok{# Ho ancora tutti gli elementi nell'oggetto my_words}
\NormalTok{my_words}
\CommentTok{## [1] "foo" "bar" "baz" "qux"}

\CommentTok{# Salvo i risultati}
\NormalTok{my_words <-}\StringTok{ }\NormalTok{my_words[}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{]}
\NormalTok{my_words}
\CommentTok{## [1] "foo" "bar"}
\end{Highlighting}
\end{Shaded}

\end{tip}

\begin{warning}[Casi Estremi nella Selezione]

Cosa accade se utiliziamo un indice di posizione maggiore del numero di elementi del nostro vettore?

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Il mio vettore}
\NormalTok{my_numbers <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{8}\NormalTok{)}

\NormalTok{my_numbers[}\DecValTok{10}\NormalTok{]}
\CommentTok{## [1] NA}
\end{Highlighting}
\end{Shaded}

R non restituisce un errore ma il valore \texttt{NA} ovvero \emph{Not Available}, per indicare che nessun valore è disponibile.

Osserviamo infine anche altri comportamenti particolari o possibili errori nella selezione di elementi.

\begin{itemize}
\tightlist
\item
  L'indice di posizione deve essere un valore numerico e non un carattere.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# ERRATA selezione più valori }
\NormalTok{my_numbers[}\StringTok{"3"}\NormalTok{]}
\CommentTok{## [1] NA}

\CommentTok{# CORRETTA selezione più valori}
\NormalTok{my_numbers[}\DecValTok{3}\NormalTok{]}
\CommentTok{## [1] 6}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  I numeri decimali vengono ignorati e non ``arrotondati''
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_numbers[}\FloatTok{2.2}\NormalTok{]}
\CommentTok{## [1] 4}
\NormalTok{my_numbers[}\FloatTok{2.8}\NormalTok{]}
\CommentTok{## [1] 4}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Utilizzando il valore 0 ottengo un vettore vuoto
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_numbers[}\DecValTok{0}\NormalTok{]}
\CommentTok{## numeric(0)}
\end{Highlighting}
\end{Shaded}

\end{warning}

\hypertarget{utilizzi-avanzati-selezione}{%
\subsection{Utilizzi Avanzati Selezione}\label{utilizzi-avanzati-selezione}}

Vediamo ora alcuni utilizzi avanzati della selezione di elementi di un vettore. In particolare impareremo a:

\begin{itemize}
\tightlist
\item
  utilizzare gli operatori relazionali e logici per selezionare gli elementi di un vettore
\item
  modificare l'ordine degli elementi
\item
  creare nuove combinazioni
\item
  sostituire degli elementi
\item
  eliminare degli elementi
\end{itemize}

\hypertarget{operatori-relazionali-e-logici}{%
\subsubsection*{Operatori Relazionali e Logici}\label{operatori-relazionali-e-logici}}
\addcontentsline{toc}{subsubsection}{Operatori Relazionali e Logici}

Un'utile funzione è quella di selezionare tra gli elementi di un vetore quelli che rispetano una certa condizione. Per fare questo dobbiamo specificare all'interno delle parentesi quadre la proposizione di interesse utilizzando gli operatori relazionali e logici (vedi Capitolo \ref{operators-rel-log}).

Possiamo ad esempio selezionare da un vettore numerico tutti gli elementi maggiori di un certo valore, oppure selezionare da un vettore di caratteri tutti gli elementi uguali ad una data stringa.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Vettore numerico - seleziono elemeni maggiori di 0}
\NormalTok{my_numbers <-}\StringTok{ }\DecValTok{-5}\OperatorTok{:}\DecValTok{5}
\NormalTok{my_numbers[my_numbers }\OperatorTok{>=}\StringTok{ }\DecValTok{0}\NormalTok{]}
\CommentTok{## [1] 0 1 2 3 4 5}

\CommentTok{# Vettore caratteri - seleziono elemeni uguali a "bar"}
\NormalTok{my_words <-}\StringTok{ }\KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"foo"}\NormalTok{, }\StringTok{"bar"}\NormalTok{), }\DataTypeTok{times =} \DecValTok{4}\NormalTok{)}
\NormalTok{my_words[my_words }\OperatorTok{==}\StringTok{ "bar"}\NormalTok{]}
\CommentTok{## [1] "bar" "bar" "bar" "bar"}
\end{Highlighting}
\end{Shaded}

Per capire meglio questa operazione è importante notare come nello stesso comando ci siano in realtà due passaggi distinti:

\begin{itemize}
\tightlist
\item
  \textbf{Vettore logico} (vedi Capitolo TODO) - quando un vettore è valutato in una proposizione, R restituisce un nuovo vettore che contiene per ogni elemento del vettore iniziale la risposta (\texttt{TRUE} o \texttt{FALSE}) alla nostra proposizione.
\item
  \textbf{Selezione} - utilizziamo il vettore logico ottenuto per selezionare gli elementi dal vettore iniziale. Gli elementi associati al valore \texttt{TRUE} sono selezionati mentre quelli associati al valore \texttt{FALSE} sono scartati.
\end{itemize}

Rendiamo espliciti questi due passaggi nel seguente codice:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Vettore logico}
\NormalTok{condition <-}\StringTok{ }\NormalTok{my_words }\OperatorTok{==}\StringTok{ "bar"}
\NormalTok{condition}
\CommentTok{## [1] FALSE  TRUE FALSE  TRUE FALSE  TRUE FALSE  TRUE}

\CommentTok{# Selezione}
\NormalTok{my_words[condition]}
\CommentTok{## [1] "bar" "bar" "bar" "bar"}
\end{Highlighting}
\end{Shaded}

\hypertarget{ordinare-gli-elementi}{%
\subsubsection*{Ordinare gli Elementi}\label{ordinare-gli-elementi}}
\addcontentsline{toc}{subsubsection}{Ordinare gli Elementi}

Gli indici di posizione possono essere utilizzati per ordinare gli elementi di un vettore a seconda delle necessità.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{messy_vector <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{7}\NormalTok{,}\DecValTok{3}\NormalTok{)}

\CommentTok{# Altero l'ordine degli elementi}
\NormalTok{messy_vector[}\KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{1}\NormalTok{)]}
\CommentTok{## [1] 3 1 7 5}

\CommentTok{# Ordino gli elementi per valori crescenti}
\NormalTok{messy_vector[}\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{)]}
\CommentTok{## [1] 1 3 5 7}
\end{Highlighting}
\end{Shaded}

\begin{trick}[sort() vs order()]

Per ordinare gli elementi di un vettore in ordine crescente o decrescente (sia alfabetico che numerico), è possibile utilizzare la funzione \texttt{sort()} specificando l'argomento \texttt{decreasing}. Vedi l'help page della funzione per ulteriori informazioni (\texttt{?sort()}).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Ordine alfabetico}
\NormalTok{my_letters <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"cb"}\NormalTok{, }\StringTok{"bc"}\NormalTok{, }\StringTok{"ab"}\NormalTok{, }\StringTok{"ba"}\NormalTok{, }\StringTok{"cb"}\NormalTok{, }\StringTok{"ab"}\NormalTok{)}
\KeywordTok{sort}\NormalTok{(my_letters)}
\CommentTok{## [1] "ab" "ab" "ba" "bc" "cb" "cb"}

\CommentTok{# ordine decrescente}
\KeywordTok{sort}\NormalTok{(messy_vector, }\DataTypeTok{decreasing =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{## [1] 7 5 3 1}
\end{Highlighting}
\end{Shaded}

Nota come esista anche la funzione \texttt{order()} ma questa sia un false-friend perchè non ci fornisce direttamente un vettore con gli elementi ordinati ma bensì gli indici di posizione per riordinare gli elementi (\texttt{?order()}). Vediamo nel seguente esempio come utilizzare questa funzione:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Indici di posizione per riordinare gli elementi}
\KeywordTok{order}\NormalTok{(messy_vector)}
\CommentTok{## [1] 2 4 1 3}
\CommentTok{# Riordino il vettore usando gli indici di posizione}
\NormalTok{messy_vector[}\KeywordTok{order}\NormalTok{(messy_vector)]}
\CommentTok{## [1] 1 3 5 7}
\end{Highlighting}
\end{Shaded}

\end{trick}

\hypertarget{combinazioni-di-elementi}{%
\subsubsection*{Combinazioni di Elementi}\label{combinazioni-di-elementi}}
\addcontentsline{toc}{subsubsection}{Combinazioni di Elementi}

Gli stessi indici di posizione possono essere richiamati più volte per ripetere gli elementi nelle combinazioni desiderate formando un nuovo vettore.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_numbers <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{5}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{7}\NormalTok{,}\DecValTok{8}\NormalTok{)}
\CommentTok{# Ottengo un nuovo vettore con la combinazioen desiderata}
\NormalTok{my_numbers[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{)]}
\CommentTok{## [1] 5 6 6 7 7 7 8}
\end{Highlighting}
\end{Shaded}

\hypertarget{modificare-gli-elementi}{%
\subsubsection*{Modificare gli Elementi}\label{modificare-gli-elementi}}
\addcontentsline{toc}{subsubsection}{Modificare gli Elementi}

Un importante utilizzo degli indici riguarda la modifica di un elemento di un vettore. Per sostituire un vecchio valore con un nuovo valore, posso utilizzare la funzione \emph{assign} (\texttt{\textless{}-} o \texttt{=}) come nell'esempio:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_names <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Andrea"}\NormalTok{, }\StringTok{"Bianca"}\NormalTok{, }\StringTok{"Carlo"}\NormalTok{)}

\CommentTok{# Modifico il  nome "Bianca" in "Beatrice"}
\NormalTok{my_names[}\DecValTok{2}\NormalTok{] <-}\StringTok{ "Beatrice"}
\NormalTok{my_names}
\CommentTok{## [1] "Andrea"   "Beatrice" "Carlo"}
\end{Highlighting}
\end{Shaded}

Per sostituire il valore viene indicato alla sinistra dell'operatore \emph{assign} il valore che si vuole modificare e alla destra il nuovo valore. Nota come questa operazione possa essere usata per aggiungere anche nuovi elementi al vettore.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_names[}\DecValTok{4}\NormalTok{]}
\CommentTok{## [1] NA}

\CommentTok{# Aggiungo il nome "Daniela"}
\NormalTok{my_names[}\DecValTok{4}\NormalTok{] <-}\StringTok{ "Daniela"}
\NormalTok{my_names}
\CommentTok{## [1] "Andrea"   "Beatrice" "Carlo"    "Daniela"}
\end{Highlighting}
\end{Shaded}

\hypertarget{eliminare-gli-elementi}{%
\subsubsection*{Eliminare gli Elementi}\label{eliminare-gli-elementi}}
\addcontentsline{toc}{subsubsection}{Eliminare gli Elementi}

Per \textbf{eliminare degli elementi} da un vettore, si indicano all'interno delle parentesi quadre gli indici di posizione degli elementi da eliminare preceduti dall'operatore \texttt{-} (\emph{meno}). Nel caso di più elementi è anche possibile indicare il meno solo prima del comando \texttt{c()}, ad esempio il comando \texttt{x{[}c(-2,-4){]}} diviene \texttt{x{[}-c(2,4){]}}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_words <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"foo"}\NormalTok{, }\StringTok{"bar"}\NormalTok{, }\StringTok{"baz"}\NormalTok{, }\StringTok{"qux"}\NormalTok{)}

\CommentTok{# Elimino "bar"}
\NormalTok{my_words[}\OperatorTok{-}\DecValTok{2}\NormalTok{]}
\CommentTok{## [1] "foo" "baz" "qux"}

\CommentTok{# Elimino "foo" e "baz"}
\NormalTok{my_words[}\OperatorTok{-}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{)]    }\CommentTok{# oppure my_words[c(-1, -3)]}
\CommentTok{## [1] "bar" "qux"}
\end{Highlighting}
\end{Shaded}

Nota come l'operazione di eliminazione sia comunque un'operazione di selezione. Pertanto è necessario salvare il risultato ottenuto se si desidera mantenere le modifiche.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Elimino "foo" e "baz"}
\NormalTok{my_words[}\OperatorTok{-}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{)]}
\CommentTok{## [1] "bar" "qux"}

\CommentTok{# Ho ancora tutti gli elementi nell'oggetto my_words}
\NormalTok{my_words}
\CommentTok{## [1] "foo" "bar" "baz" "qux"}

\CommentTok{# Salvo i risultati}
\NormalTok{my_words <-}\StringTok{ }\NormalTok{my_words[}\OperatorTok{-}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{)]}
\NormalTok{my_words}
\CommentTok{## [1] "bar" "qux"}
\end{Highlighting}
\end{Shaded}

\hypertarget{esercizi-3}{%
\subsection*{Esercizi}\label{esercizi-3}}
\addcontentsline{toc}{subsection}{Esercizi}

Esegui i seguenti esercizi (\href{https://github.com/psicostat/Introduction2R/blob/master/exercises/chapter-07-vectors.R}{soluzioni}):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Del vettore \texttt{x} seleziona il 2°, 3° e 5° elemento
\item
  Del vettore \texttt{x} seleziona i valori 34 e 4
\item
  Dato il vettore \texttt{my\_vector\ =\ c(2,4,6,8)} commenta il risultato del comando \texttt{my\_vector{[}my\_vector{]}}
\item
  Del vettore \texttt{y} seleziona tutti i valori minori di 13 o maggiori di 19
\item
  Del vettore \texttt{z} seleziona tutti i valori compresi tra 24 e 50
\item
  Del vettore \texttt{s} seleziona tutti gli elementi uguali ad \texttt{"A"}
\item
  Del vettore \texttt{t} seleziona tutti gli elementi diversi da \texttt{"B"}
\item
  Crea un nuovo vettore \texttt{u} identico a \texttt{s} ma dove le \texttt{"A"} sono sostituite con la lettera \texttt{"U"}
\item
  Elimina dal vettore \texttt{z} i valori 28 e 42
\end{enumerate}

\hypertarget{vector-functions}{%
\section{Funzioni ed Operazioni}\label{vector-functions}}

Vediamo ora alcune utili funzioni e comuni operazioni che è possibile svolgere con i vettori (vedi Tabella \ref{tab:table-vector-operators}).

\begin{table}[!h]

\caption{\label{tab:table-vector-operators}Funzioni e  operazioni con vettori}
\centering
\begin{tabular}[t]{l|l}
\hline
Funzione & Descrizione\\
\hline
\texttt{nuovo\_vettore <- c(vettore1, vettore2)} & Unire più vettori in un unico vettore\\
\hline
\texttt{length(nome\_vettore)} & Valutare il numero di elementi contenuti in un vettore\\
\hline
\texttt{vettore1 + vettore2} & Somma di due vettori\\
\hline
\texttt{vettore1 - vettore2} & Differenza tra due vettori\\
\hline
\texttt{vettore1 * vettore2} & Prodotto tra due vettori\\
\hline
\texttt{vettore1 / vettore2} & Rapporto tra due vettori\\
\hline
\end{tabular}
\end{table}

Nota che l'esecuzione di operazioni matematiche (e.g., \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/} etc.) è possibile sia rispetto ad un singolo valore sia rispetto ad un altro vettore:

\begin{itemize}
\tightlist
\item
  \textbf{Singolo valore} - l'operazione sarà svolta per ogni elemento del vettore rispetto al singolo valore fornito.
\item
  \textbf{Altro vettore} - l'operazione sarà svolta per ogni coppia di elementi dei due vettori. E' quindi necessario che i due vettori abbiano la \textbf{stessa lunghezza}, ovvero lo stesso numero di elementi.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{5}
\NormalTok{y <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{5}

\CommentTok{# Sommo un valore singolo}
\NormalTok{x }\OperatorTok{+}\StringTok{ }\DecValTok{10}
\CommentTok{## [1] 11 12 13 14 15}

\CommentTok{# Somma di vettori (elemento per elemento)}
\NormalTok{x }\OperatorTok{+}\StringTok{ }\NormalTok{y}
\CommentTok{## [1]  2  4  6  8 10}
\end{Highlighting}
\end{Shaded}

\begin{warning}[Vettori di Diversa Lunghezza]

Qualora i vettori differiscano per la loro lunghezza, R ci presenterà un warning avvisandoci del problema ma eseguirà comunque l'operazione utilizzando più volte il vettore più corto.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{+}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\CommentTok{## Warning in x + c(1, 2): longer object length is not a multiple of shorter object}
\CommentTok{## length}
\CommentTok{## [1] 2 4 4 6 6}
\end{Highlighting}
\end{Shaded}

Tuttavia, compiere operazioni tra vettori di diversa lunghezza (anche se multipli) dovrebbe essere evitato poichè è facile causa di errori ed incomprensioni.

\end{warning}

\begin{design}[Vectorized Operations]

In R la maggior parte degli operatori sono \emph{vettorizzati}, ovvero calcolano direttamente il risultato per ogni elemento di un vettore. Questo è un grandissimo vantaggio poichè ci permette di essere molto efficienti e coincisi nel codice.

Senza vettorizzazione, ogni operazione tra due vettori richiederebbe di specificare l'operazione per ogni elemento del vettore. Nel precedente esempio della somma tra \texttt{x} e \texttt{y} avremmo dovuto usare il seguente codice:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{z <-}\StringTok{ }\KeywordTok{numeric}\NormalTok{(}\KeywordTok{length}\NormalTok{(x))}
\ControlFlowTok{for}\NormalTok{(i }\ControlFlowTok{in} \KeywordTok{seq_along}\NormalTok{(x)) \{}
\NormalTok{      z[i] <-}\StringTok{ }\NormalTok{x[i] }\OperatorTok{+}\StringTok{ }\NormalTok{y[i]}
\NormalTok{\}}
\NormalTok{z}
\CommentTok{## [1]  2  4  6  8 10}
\end{Highlighting}
\end{Shaded}

Nota come questo sia valido anche per gli \textbf{operatori relazionali e logici}. Infatti valutando una proposizione rispetto ad un vettore, otterremmo una risposta per ogni elemento del vettore

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_values <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{8}

\CommentTok{# Valori compresi tra 4 e 7}
\NormalTok{my_values }\OperatorTok{>=}\StringTok{ }\DecValTok{4} \OperatorTok{&}\StringTok{ }\NormalTok{my_values }\OperatorTok{<=}\StringTok{ }\DecValTok{7}
\CommentTok{## [1] FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE}
\end{Highlighting}
\end{Shaded}

\end{design}

\hypertarget{esercizi-4}{%
\subsection*{Esercizi}\label{esercizi-4}}
\addcontentsline{toc}{subsection}{Esercizi}

Esegui i seguenti esercizi (\href{https://github.com/psicostat/Introduction2R/blob/master/exercises/chapter-07-vectors.R}{soluzioni}):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Crea il vettore \texttt{j} unendo i vettori \texttt{x} ed \texttt{z}.
\item
  Elimina gli ultimi tre elementi del vettore \texttt{j} e controlla che i vettori \texttt{j} e \texttt{y} abbiano la stessa lunghezza.
\item
  Calcola la somma tra i vettori \texttt{j} e \texttt{y}.
\item
  Moltiplica il vettore z per una costante \texttt{k=3}.
\item
  Calcola il prodotto tra i primi 10 elementi del vettore \texttt{y} ed il vettore \texttt{z}.
\end{enumerate}

\hypertarget{data-type}{%
\section{Data Type}\label{data-type}}

Abbiamo visto come sia necessario che in un vettore tutti gli elementi siano della stessa tipologia. Avremo quindi diversi tipi di vettori a seconda della tiopologia di dati che contengono.

In R abbiamo 4 principali tipologie di dati, ovvero tipologie di valori che possono essere utilizzati:

\begin{itemize}
\tightlist
\item
  \texttt{character} - \emph{Stringhe di caratteri} i cui valori alfannumerici vengono delimitati dalle doppie vigolette \texttt{"Hello\ world!"} o virgolette singole \texttt{\textquotesingle{}Hello\ world!\textquotesingle{}}.
\item
  \texttt{double} - \emph{Valori reali} con o senza cifre decimali ad esempio \texttt{27} o \texttt{93.46}.
\item
  \texttt{integer} - \emph{Valori interi} definiti apponendo la lettera \texttt{L} al numero desiderato, ad esempio \texttt{58L}.
\item
  \texttt{logical} - \emph{Valori logici} \texttt{TRUE} e \texttt{FALSE} usati nelle operazioni logiche.
\end{itemize}

Possiamo verificare la tipologia di un valore utlizzando la funzione \texttt{typeof()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof}\NormalTok{(}\StringTok{"foo"}\NormalTok{) }
\CommentTok{## [1] "character"}

\KeywordTok{typeof}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\CommentTok{## [1] "double"}

\KeywordTok{typeof}\NormalTok{(2021L) }\CommentTok{# nota la lettera L}
\CommentTok{## [1] "integer"}

\KeywordTok{typeof}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)}
\CommentTok{## [1] "logical"}
\end{Highlighting}
\end{Shaded}

Esistono molte altre tipologie di dati tra cui \texttt{complex} (per rappresentare i numeri complessi del tipo \(x + yi\)) e \texttt{Raw} (usati per rappresenttare i valori come bytes) che però riguardano usi poco comuni o comunque molto avanzati di R e pertanto non verranno trattati.

\begin{design}[Tutta una Questione di Bit]

Questa distinzione tra le varie tipologie di dati deriva dalla modalità con cui il computer rappresenta internamente i diversi valori. Sappiamo infatti che il computer non possiede caratteri ma solamente bits, ovvero successioni di 0 e 1 ad esempio 01000011.

Senza scendere nel dettaglio, per ottimizzare l'uso della memoria i diversi valori vengono \emph{``mappati''} utilizzando i bits in modo differente a seconda delle tipologie di dati. Pertanto in R il valore \texttt{24} sarà rappresentato diversamente a seconda che sia definitio come una stringa di caratteri (\texttt{"24"}), un numero intero (\texttt{24L}) o un numero double (\texttt{24}).

\hypertarget{integer-vs-double}{%
\subsubsection*{Integer vs Double}\label{integer-vs-double}}
\addcontentsline{toc}{subsubsection}{Integer vs Double}

In particolare un aspetto poco intuitivo riguarda la differenza tra valori \texttt{double} e \texttt{integer}. Mentre i valori interi possono essere rappresentati con precisione dal computer, non tutti i valori reali posssono essere rappresentati esattamente utilizzando il numero massimo di 64 bit. In questi casi i loro valori vengonno quindi approsimati e, sebbene questo venga fatto con molta precisione, a volte potrebbe portare a dei risultati inaspettati. Nota infatti come nell'esempio seguente non otteniamo zero, ma osserviamo un piccolo errore dovuto all'approsimazione dei valori \texttt{double}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_value <-}\StringTok{ }\KeywordTok{sqrt}\NormalTok{(}\DecValTok{2}\NormalTok{)}\OperatorTok{^}\DecValTok{2} \CommentTok{# dovrei ottenere 2}
\NormalTok{my_value }\OperatorTok{-}\StringTok{ }\DecValTok{2}          \CommentTok{# dovrei ottenre 0}
\CommentTok{## [1] 4.440892e-16}
\end{Highlighting}
\end{Shaded}

E' importante tenere a mente questo problema nei test di ugualianza dove l'utilizzo dell'operatore \texttt{==} potrebbe generare delle risposte inaspettate. In genere viene quindi preferita la funzione \texttt{all.equal()} che prevede un certo margine di tolleranza (vedi \texttt{?all.equal()} per ulteriori dettagli).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_value }\OperatorTok{==}\StringTok{ }\DecValTok{2}          \CommentTok{# Problema di approsimazione }
\CommentTok{## [1] FALSE}
\KeywordTok{all.equal}\NormalTok{(my_value, }\DecValTok{2}\NormalTok{) }\CommentTok{# Test con tolleranza}
\CommentTok{## [1] TRUE}
\end{Highlighting}
\end{Shaded}

Ricorda infine che i computer hanno un limite rispetto al massimo valore e minimo valore che possono rappresentare sia per quanto riguarda i valori interi che i valori reali. Per approfondire vedi \url{https://stat.ethz.ch/pipermail/r-help/2012-January/300250.html}.

\end{design}

Vediamo ora i diversi tipi di vettori a seconda della tipologia di dati utilizzati.

\hypertarget{character}{%
\subsection{Character}\label{character}}

I vettori formati da stringhe di caratteri sono definiti vettori di caratteri. Per valutare la tipologia di un oggetto possiamo utilizzare la funzione \texttt{class()}, mentre ricordiamo che la funzionne \texttt{typeof()} valuta la tipologia di dati. In questo caso otteniamo per entrambi il valore \texttt{character}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_words<-}\KeywordTok{c}\NormalTok{(}\StringTok{"Foo"}\NormalTok{,}\StringTok{"Bar"}\NormalTok{,}\StringTok{"foo"}\NormalTok{,}\StringTok{"bar"}\NormalTok{)}

\KeywordTok{class}\NormalTok{(my_words) }\CommentTok{# tipologia oggetto}
\CommentTok{## [1] "character"}

\KeywordTok{typeof}\NormalTok{(my_words) }\CommentTok{# tipologia dati}
\CommentTok{## [1] "character"}
\end{Highlighting}
\end{Shaded}

Non è possibile eseguire operazioni aritmetiche con vettori di caratteri ma solo valutare relazioni di uguaglianza o disuguaglianza ripetto ad un'altra stringa.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_words }\OperatorTok{+}\StringTok{ "foo"}
\CommentTok{## Error in my_words + "foo": non-numeric argument to binary operator}

\NormalTok{my_words }\OperatorTok{==}\StringTok{ "foo"}
\CommentTok{## [1] FALSE FALSE  TRUE FALSE}
\end{Highlighting}
\end{Shaded}

\hypertarget{numeric}{%
\subsection{Numeric}\label{numeric}}

In R, se non altrimenti specificato, ogni valore numerico viene rappresentato come un \texttt{double} indipendentemente che abbia o meno valori decimali. I vettori formati da valori double sono definiti vettori numerici. In R la tipologia del vettore è indicata con \texttt{numeric} mentre i dati sono \texttt{double}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_values <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{5}\NormalTok{)}
\KeywordTok{class}\NormalTok{(my_values)  }\CommentTok{# tipologia oggetto}
\CommentTok{## [1] "numeric"}

\KeywordTok{typeof}\NormalTok{(my_values) }\CommentTok{# tipologia dati}
\CommentTok{## [1] "double"}
\end{Highlighting}
\end{Shaded}

I vettori numerici sono utilizzati per compiere qualsiasi tipo di operazioni matematiche o logico-relazionali.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_values }\OperatorTok{+}\StringTok{ }\DecValTok{10}
\CommentTok{## [1] 11 12 13 14 15}

\NormalTok{my_values }\OperatorTok{<=}\StringTok{ }\DecValTok{3}
\CommentTok{## [1]  TRUE  TRUE  TRUE FALSE FALSE}
\end{Highlighting}
\end{Shaded}

\hypertarget{integer}{%
\subsection{Integer}\label{integer}}

In R per specificare che un valore è un numero intero viene aggiunta la lettera \texttt{L} immediatamente dopo il numero. I vettori formati da valori interi sono definiti vettori di valori interi. In R la tipologia del vettore è indicata con \texttt{integer} allo stesso modo dei dati.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_integers <-}\StringTok{ }\KeywordTok{c}\NormalTok{(1L,2L,3L,4L,5L)}
\KeywordTok{class}\NormalTok{(my_integers)  }\CommentTok{# tipologia oggetto}
\CommentTok{## [1] "integer"}

\KeywordTok{typeof}\NormalTok{(my_integers) }\CommentTok{# tipologia dati}
\CommentTok{## [1] "integer"}
\end{Highlighting}
\end{Shaded}

Come per i vettori numerici, i vettori di valori interi possono esssere utilizzati per compiere qualsiasi tipo di operazioni matematiche o logico-relazionali. Nota tuttavia che operazioni tra integer e doubles restituiranno dei doubles ed anche nel caso di operazioni tra integers il risultato potrebbe non essere un integer.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.integer}\NormalTok{(5L }\OperatorTok{*}\StringTok{ }\DecValTok{5}\NormalTok{)   }\CommentTok{# integer e double}
\CommentTok{## [1] FALSE}

\KeywordTok{is.integer}\NormalTok{(5L }\OperatorTok{*}\StringTok{ }\NormalTok{5L)  }\CommentTok{# integer e integer}
\CommentTok{## [1] TRUE}

\KeywordTok{is.integer}\NormalTok{(5L }\OperatorTok{/}\StringTok{ }\NormalTok{5L)  }\CommentTok{# integer e integer}
\CommentTok{## [1] FALSE}
\end{Highlighting}
\end{Shaded}

\hypertarget{logical}{%
\subsection{Logical}\label{logical}}

I vettori formati da valori logici (\texttt{TRUE} e \texttt{FALSE}) sono definiti vettori logici. In R la tipologia del vettore è indicata con \texttt{logical} allo stesso modo dei dati.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_logical <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{)}
\KeywordTok{class}\NormalTok{(my_logical)  }\CommentTok{# tipologia oggetto}
\CommentTok{## [1] "logical"}

\KeywordTok{typeof}\NormalTok{(my_logical) }\CommentTok{# tipologia dati}
\CommentTok{## [1] "logical"}
\end{Highlighting}
\end{Shaded}

I vettori di valori logici possono esssere utilizzati con gli operatori logici.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_logical }\OperatorTok{&}\StringTok{ }\KeywordTok{c}\NormalTok{(}\OtherTok{FALSE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{, }\OtherTok{TRUE}\NormalTok{)}
\CommentTok{## [1] FALSE FALSE  TRUE}

\NormalTok{my_logical }\OperatorTok{&}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{)}
\CommentTok{## [1] FALSE FALSE  TRUE}
\end{Highlighting}
\end{Shaded}

Tuttavia ricordiamo che ai valori \texttt{TRUE} e \texttt{FALSE} sono associati rispettivamente i valori numerici 1 e 0 (o più precisamente i valori interi \texttt{1L} e \texttt{0L}). Pertanto è possibile eseguire anche operazioni matematiche dove verrano automaticamente considerati i rispettivi valori numerici. Ovviamente il risultato ottenuto sarà un valore numerico e non logico.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{TRUE} \OperatorTok{*}\StringTok{ }\DecValTok{10}
\CommentTok{## [1] 10}

\OtherTok{FALSE} \OperatorTok{*}\StringTok{ }\DecValTok{10}
\CommentTok{## [1] 0}
\end{Highlighting}
\end{Shaded}

\begin{trick}[sum() e mean()]

Utilizzando le funzioni \texttt{sum()} e \texttt{mean()} con un vettore logico, possiamo valutare rispettivamente il numero totale e la percentuale di elementi che hanno soddisfatto una certa condizione logica.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_values <-}\StringTok{ }\KeywordTok{rnorm}\NormalTok{(}\DecValTok{50}\NormalTok{)  }\CommentTok{# genero dei numeri casuali }

\KeywordTok{sum}\NormalTok{(my_values }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{)      }\CommentTok{# totale numeri positivi}
\CommentTok{## [1] 31}

\KeywordTok{mean}\NormalTok{(my_values }\OperatorTok{>}\StringTok{ }\DecValTok{0}\NormalTok{)      }\CommentTok{# percentuale numeri positivi}
\CommentTok{## [1] 0.62}
\end{Highlighting}
\end{Shaded}

\end{trick}

\begin{design}[is.* adn as.* Function Families]

Esistono due famiglie di funzioni che permettono rispettivamene di testare e di modificare la tipologia dei dati.

\hypertarget{is.-family}{%
\subsubsection*{is.* Family}\label{is.-family}}
\addcontentsline{toc}{subsubsection}{is.* Family}

Per testare se un certo valore (o un vettore di valori) appartiene ad una specifica tipologia di dati, possimao utilizzare una tra le seguenti funzioni:

\begin{itemize}
\tightlist
\item
  \texttt{is.vector()} - valuta se un oggetto è un generico vettore di qualsiasi tipo
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.vector}\NormalTok{(}\StringTok{"2021"}\NormalTok{)   }\CommentTok{# TRUE}
\KeywordTok{is.vector}\NormalTok{(}\DecValTok{2021}\NormalTok{)     }\CommentTok{# TRUE}
\KeywordTok{is.vector}\NormalTok{(2021L)    }\CommentTok{# TRUE}
\KeywordTok{is.vector}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)     }\CommentTok{# TRUE}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{is.character()} - valuta se l'oggetto è una stringa
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.character}\NormalTok{(}\StringTok{"2021"}\NormalTok{) }\CommentTok{# TRUE}
\KeywordTok{is.character}\NormalTok{(}\DecValTok{2021}\NormalTok{)   }\CommentTok{# FALSE}
\KeywordTok{is.character}\NormalTok{(2021L)  }\CommentTok{# FALSE}
\KeywordTok{is.character}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)   }\CommentTok{# FALSE}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{is.numeric()} - valuta se l'oggetto è un valore numerico indipendentemente che sia un double o un integer
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.numeric}\NormalTok{(}\StringTok{"2021"}\NormalTok{)   }\CommentTok{# FALSE}
\KeywordTok{is.numeric}\NormalTok{(}\DecValTok{2021}\NormalTok{)     }\CommentTok{# TRUE}
\KeywordTok{is.numeric}\NormalTok{(2021L)    }\CommentTok{# TRUE}
\KeywordTok{is.numeric}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)     }\CommentTok{# FALSE}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{is.double()} - valuta se l'oggetto è un valore \texttt{double}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.double}\NormalTok{(}\StringTok{"2021"}\NormalTok{)    }\CommentTok{# FALSE}
\KeywordTok{is.double}\NormalTok{(}\DecValTok{2021}\NormalTok{)      }\CommentTok{# TRUE}
\KeywordTok{is.double}\NormalTok{(2021L)     }\CommentTok{# FALSE}
\KeywordTok{is.double}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)      }\CommentTok{# FALSE}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{is.integer()} - valuta se l'oggetto è un valore intero
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.integer}\NormalTok{(}\StringTok{"2021"}\NormalTok{)   }\CommentTok{# FALSE}
\KeywordTok{is.integer}\NormalTok{(}\DecValTok{2021}\NormalTok{)     }\CommentTok{# FALSE}
\KeywordTok{is.integer}\NormalTok{(2021L)    }\CommentTok{# TRUE}
\KeywordTok{is.integer}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)     }\CommentTok{# FALSE}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{is.logical()} - valuta se l'oggetto è un valore logico
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.logical}\NormalTok{(}\StringTok{"2021"}\NormalTok{)   }\CommentTok{# FALSE}
\KeywordTok{is.logical}\NormalTok{(}\DecValTok{2021}\NormalTok{)     }\CommentTok{# FALSE}
\KeywordTok{is.logical}\NormalTok{(2021L)    }\CommentTok{# FALSE}
\KeywordTok{is.logical}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)     }\CommentTok{# TRUE}
\end{Highlighting}
\end{Shaded}

\hypertarget{as.-family}{%
\subsubsection*{as.* Family}\label{as.-family}}
\addcontentsline{toc}{subsubsection}{as.* Family}

Per modificare la tipologia di un certo valore (o un vettore di valori), possimao utilizzare una tra le seguenti funzioni:

\begin{itemize}
\tightlist
\item
  \texttt{as.character()} - trasforma l'oggetto in una stringa
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.character}\NormalTok{(}\DecValTok{2021}\NormalTok{)}
\CommentTok{## [1] "2021"}
\KeywordTok{as.character}\NormalTok{(2021L)}
\CommentTok{## [1] "2021"}
\KeywordTok{as.character}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)}
\CommentTok{## [1] "TRUE"}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{as.numeric()} - trasforma l'oggetto in un \texttt{double}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.numeric}\NormalTok{(}\StringTok{"foo"}\NormalTok{)  }\CommentTok{# Non valido con stringhe di caratteri}
\CommentTok{## Warning: NAs introduced by coercion}
\CommentTok{## [1] NA}
\KeywordTok{as.numeric}\NormalTok{(}\StringTok{"2021"}\NormalTok{) }\CommentTok{# Valido per stinghe di cifre}
\CommentTok{## [1] 2021}
\KeywordTok{as.numeric}\NormalTok{(2021L)}
\CommentTok{## [1] 2021}
\KeywordTok{as.numeric}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)}
\CommentTok{## [1] 1}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{as.double()} - trasforma l'oggetto in un \texttt{double}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.double}\NormalTok{(}\StringTok{"2021"}\NormalTok{) }\CommentTok{# Valido per stinghe di cifre}
\CommentTok{## [1] 2021}
\KeywordTok{as.double}\NormalTok{(2021L)}
\CommentTok{## [1] 2021}
\KeywordTok{as.double}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)}
\CommentTok{## [1] 1}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{as.integer()} - trasforma l'oggetto in un \texttt{integer}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.integer}\NormalTok{(}\StringTok{"2021"}\NormalTok{) }\CommentTok{# Valido per stinghe di cifre}
\CommentTok{## [1] 2021}
\KeywordTok{as.integer}\NormalTok{(}\FloatTok{2021.6}\NormalTok{) }\CommentTok{# Tronca la parte decimale}
\CommentTok{## [1] 2021}
\KeywordTok{as.integer}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)}
\CommentTok{## [1] 1}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{as.logical()} - trasforma un oggetto numerico in un valore logico qualsiasi valore diverso da 0 viene considerato \texttt{TRUE}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.logical}\NormalTok{(}\StringTok{"2021"}\NormalTok{) }\CommentTok{# Non valido per le stringhe}
\CommentTok{## [1] NA}
\KeywordTok{as.logical}\NormalTok{(}\DecValTok{0}\NormalTok{)}
\CommentTok{## [1] FALSE}
\KeywordTok{as.logical}\NormalTok{(}\FloatTok{0.5}\NormalTok{)}
\CommentTok{## [1] TRUE}
\KeywordTok{as.logical}\NormalTok{(2021L)}
\CommentTok{## [1] TRUE}
\end{Highlighting}
\end{Shaded}

\end{design}

\hypertarget{valori-speciali}{%
\subsection{Valori speciali}\label{valori-speciali}}

Vediamo infine alcuni valori speciali utilizzatti in R con dei particolari significati e che richiedono specifici accorgimenti quando vengono manipolati:

\begin{itemize}
\tightlist
\item
  \texttt{NULL}- rappresenta l'oggetto nullo, ovvero l'assenza di un oggetto. Spesso viene restituito dalle funzioni quano il loro output è indefinito.
\item
  \texttt{NA} - rappresenta un dato mancate (\emph{Not Available}). E' un valore costante di lunghezza 1 che può essere utlizzato per qualsiasi tipologia di dati.
\item
  \texttt{NaN} - indica un risulato matematico che non può essere rappresentato come un valore numerico (\emph{Not A Number}). E' un valore costante di lunghezza 1 che può essere utlizzato come valore numerico (non intero).
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\DecValTok{0}\OperatorTok{/}\DecValTok{0}
\CommentTok{## [1] NaN}
\KeywordTok{sqrt}\NormalTok{(}\OperatorTok{-}\DecValTok{1}\NormalTok{)}
\CommentTok{## Warning in sqrt(-1): NaNs produced}
\CommentTok{## [1] NaN}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{Inf} (o \texttt{-Inf}) - indica un risultato matematico inifinito (o infinito negativo). E' anche utilizzato per rappresentare numeri estremamente grandi.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{pi}\OperatorTok{^}\DecValTok{650}
\CommentTok{## [1] Inf}

\OperatorTok{-}\NormalTok{pi}\OperatorTok{/}\DecValTok{0}
\CommentTok{## [1] -Inf}
\end{Highlighting}
\end{Shaded}

E' importante essere consapevoli delle caratteristiche di questi valori poichè presentano dei comportamenti peculiari che, se non corretamente gestiti, possono generare conseguenti errori nei codici. Descriviamo ora alcune delle carateristiche più importanti.

\hypertarget{lunghezza-elementi}{%
\subsubsection*{Lunghezza Elementi}\label{lunghezza-elementi}}
\addcontentsline{toc}{subsubsection}{Lunghezza Elementi}

Notiamo innanzitutto come mentre \texttt{NULL} sia effettivamente un oggetto nullo, ovvero privo di dimensione, \texttt{NA} sia uno speciale valore che rappresenta la presenza di un dato mancate. Pertanto \texttt{NA}, a differenza di \texttt{NULL}, è effettivamente un valore di lunghezza 1.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Il valore NULL è un oggetto nullo}
\NormalTok{values_NULL <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\OtherTok{NULL}\NormalTok{)}
\KeywordTok{length}\NormalTok{(values_NULL)}
\CommentTok{## [1] 5}
\NormalTok{values_NULL }\CommentTok{# NULL non è presente}
\CommentTok{## [1] 1 2 3 4 5}

\CommentTok{# Il valore NA è un oggetto che testimonia un'assenza}
\NormalTok{values_NA <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\OtherTok{NA}\NormalTok{)}
\KeywordTok{length}\NormalTok{(values_NA)}
\CommentTok{## [1] 6}
\NormalTok{values_NA   }\CommentTok{# NA è presente}
\CommentTok{## [1]  1  2  3  4  5 NA}
\end{Highlighting}
\end{Shaded}

Allo stesso modo, anche i valori \texttt{NaN} e \texttt{Inf} sono effettivamente dei valori di lunghezza 1 usati per testimoniare speciali risultati numerici.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\OtherTok{NaN}\NormalTok{))}
\CommentTok{## [1] 6}
\KeywordTok{length}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, }\OtherTok{Inf}\NormalTok{))}
\CommentTok{## [1] 6}
\end{Highlighting}
\end{Shaded}

\hypertarget{propagazione-valori}{%
\subsubsection*{Propagazione Valori}\label{propagazione-valori}}
\addcontentsline{toc}{subsubsection}{Propagazione Valori}

Altra importante caratteristica è quella che viene definita \emph{propagazione} dei valori ovvero le operazioni che includono questi speciali valori resituiscono a loro volta lo stesso speciale. Ciò significa che questi valori si propagheranno di risultato in risultato all'interno del nostro codice se non opportunamente gestiti.

\begin{itemize}
\tightlist
\item
  \texttt{NULL}- osserviamo come se il valore \texttt{NULL} viene utilizzato in una qualsiasi operazione matematica il risultato sarà un vettore numerico vuoto di dimensione 0, il quale può essere interpretato in modo simile (seppur non identico) al valore \texttt{NULL}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res_NULL <-}\StringTok{ }\OtherTok{NULL} \OperatorTok{*}\StringTok{ }\DecValTok{3}
\KeywordTok{length}\NormalTok{(res_NULL)}
\CommentTok{## [1] 0}
\NormalTok{res_NULL}
\CommentTok{## numeric(0)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{NA} - quando \texttt{NA} viene utilizzato in una qualsiasi operazione matematica il risultato sarà nuovamene un \texttt{NA}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{NA} \OperatorTok{*}\StringTok{ }\DecValTok{3}
\CommentTok{## [1] NA}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{NaN} - quando \texttt{NaN} viene utilizzato in una qualsiasi operazione matematica il risultato sarà nuovamene un \texttt{NaN}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{NaN} \OperatorTok{*}\StringTok{ }\DecValTok{3}
\CommentTok{## [1] NaN}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{Inf} (o \texttt{-Inf}) - qualora \texttt{Inf} (o \texttt{-Inf}) siano utilizzati in un'operazione matematica il risultato seguirà le comuni regole delle operazioni tra infiti.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{Inf} \OperatorTok{-}\StringTok{ }\DecValTok{3}     \CommentTok{# Inf}

\OtherTok{Inf} \OperatorTok{*}\StringTok{ }\DecValTok{-3}    \CommentTok{# - Inf}

\OtherTok{Inf} \OperatorTok{+}\StringTok{ }\OtherTok{Inf}   \CommentTok{# Inf}

\OtherTok{Inf} \OperatorTok{+}\StringTok{ }\OperatorTok{-}\OtherTok{Inf}  \CommentTok{# NaN}

\OtherTok{Inf} \OperatorTok{*}\StringTok{ }\OperatorTok{-}\OtherTok{Inf}  \CommentTok{# -Inf}

\OtherTok{Inf} \OperatorTok{/}\StringTok{ }\OtherTok{Inf}   \CommentTok{# NaN}
\end{Highlighting}
\end{Shaded}

\hypertarget{testare-valori}{%
\subsubsection*{Testare Valori}\label{testare-valori}}
\addcontentsline{toc}{subsubsection}{Testare Valori}

E' importante ricordare come per testare l apresenza di uno di questi valori speciali siano presenti delle funzioni specifiche della famiglia \texttt{is.*}. Non deve mai essere utlizzato il comune operatore di uguaglianza \texttt{==} poichè non fornisce i risultai corretti.

\begin{itemize}
\tightlist
\item
  \texttt{is.null}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{NULL} \OperatorTok{==}\StringTok{ }\OtherTok{NULL}     \CommentTok{# logical(0)}
\KeywordTok{is.null}\NormalTok{(}\OtherTok{NULL}\NormalTok{)    }\CommentTok{# TRUE}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{is.na}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{NA} \OperatorTok{==}\StringTok{ }\OtherTok{NA}    \CommentTok{# NA}
\KeywordTok{is.na}\NormalTok{(}\OtherTok{NA}\NormalTok{)   }\CommentTok{# TRUE}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{is.nan}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{NaN} \OperatorTok{==}\StringTok{ }\OtherTok{NaN}  \CommentTok{# NA}
\KeywordTok{is.nan}\NormalTok{(}\OtherTok{NaN}\NormalTok{) }\CommentTok{# TRUE}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{Inf}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{Inf} \OperatorTok{==}\StringTok{ }\OtherTok{Inf}       \CommentTok{# TRUE considero anche il segno}
\KeywordTok{is.infinite}\NormalTok{(}\OtherTok{Inf}\NormalTok{) }\CommentTok{# TRUE sia per Inf che -Inf}
\end{Highlighting}
\end{Shaded}

\hypertarget{operatori-logici-1}{%
\subsubsection*{Operatori Logici}\label{operatori-logici-1}}
\addcontentsline{toc}{subsubsection}{Operatori Logici}

Un particolare comportamento riguarda i risultati ottenute con gli operatori logici dove la \emph{propagazione} del valore non segue sempre le attese. Osserviamo i diversi casi:

\begin{itemize}
\tightlist
\item
  \texttt{NULL}- ottenimo come da attese un vettore logico vuoto di dimensione 0
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{TRUE} \OperatorTok{&}\StringTok{ }\OtherTok{NULL}  \CommentTok{# logical(0)}
\OtherTok{TRUE} \OperatorTok{|}\StringTok{ }\OtherTok{NULL}  \CommentTok{# logical(0)}

\OtherTok{FALSE} \OperatorTok{&}\StringTok{ }\OtherTok{NULL} \CommentTok{# logical(0)}
\OtherTok{FALSE} \OperatorTok{|}\StringTok{ }\OtherTok{NULL} \CommentTok{# logical(0)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{NA} - non otteniamo come da attese sempre il valore \texttt{NA} ma in alcune condizioni la proposizione sara \texttt{TRUE} o \texttt{FALSE}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{TRUE} \OperatorTok{&}\StringTok{ }\OtherTok{NA}  \CommentTok{# NA}
\OtherTok{TRUE} \OperatorTok{|}\StringTok{ }\OtherTok{NA}  \CommentTok{# TRUE}

\OtherTok{FALSE} \OperatorTok{&}\StringTok{ }\OtherTok{NA} \CommentTok{# FALSE}
\OtherTok{FALSE} \OperatorTok{|}\StringTok{ }\OtherTok{NA} \CommentTok{# NA}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{NaN} - otteniamo gli stessi risultati del caso precedente utilizzando il valore \texttt{NA}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{TRUE} \OperatorTok{&}\StringTok{ }\OtherTok{NaN}  \CommentTok{# NA}
\OtherTok{TRUE} \OperatorTok{|}\StringTok{ }\OtherTok{NaN}  \CommentTok{# TRUE}

\OtherTok{FALSE} \OperatorTok{&}\StringTok{ }\OtherTok{NaN} \CommentTok{# FALSE}
\OtherTok{FALSE} \OperatorTok{|}\StringTok{ }\OtherTok{NaN} \CommentTok{# NA}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{Inf} - essendo un valore numerico diverso da zero otteniamo i rissultati secondo le attese
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{TRUE} \OperatorTok{&}\StringTok{ }\OtherTok{Inf}  \CommentTok{# TRUE}
\OtherTok{TRUE} \OperatorTok{|}\StringTok{ }\OtherTok{Inf}  \CommentTok{# TRUE}

\OtherTok{FALSE} \OperatorTok{&}\StringTok{ }\OtherTok{Inf} \CommentTok{# FALSE}
\OtherTok{FALSE} \OperatorTok{|}\StringTok{ }\OtherTok{Inf} \CommentTok{# TRUE}
\end{Highlighting}
\end{Shaded}

\begin{tip}[A Logical Solution]

Un comportamento tanto strano per quanto riguarda l'utilizzo del valore \texttt{NA} con gli operatori logici può essere spiegato dal fatto che il valore \texttt{NA} in realtà sia un valore logico che indica la mancanza di una risposta.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.logical}\NormalTok{(}\OtherTok{NA}\NormalTok{)}
\CommentTok{## [1] TRUE}
\end{Highlighting}
\end{Shaded}

Pertanto le proposizioni vengono correttamente seguendo le comuni regole. Nel caso di \texttt{TRUE\ \textbar{}\ NA} la proposizione è giudicata \texttt{TRUE} perchè con l'operatore di disgiunzione è sufficiente che una delle due parti sia vera avvinchè la proposizione sia vera. Nel caso di \texttt{FALSE\ \&\ NA}, invece, la proposizione è giudicata \texttt{FALSE} perchè con l'operatore di congiunzione è sufficiente che una delle due parti sia falsa avvinchè la proposizione sia falsa. LA non risposta indicata da \texttt{NA} i questi casi è ininfluente, mentre determina il risultato nei restanti casi quando la seconda parte della proposizione deve essere necessariamente valutata. A questo punto gli operatori restituiscono \texttt{NA} poichè incapaci di determinare la risposta.

Per quanto riguarda il caso del valore \texttt{NaN} è sufficinete ricordare che tale valore sia comunque un valore numerico di cui però non è possibile identificare il valore.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{is.numeric}\NormalTok{(}\OtherTok{NaN}\NormalTok{)}
\CommentTok{## [1] TRUE}
\end{Highlighting}
\end{Shaded}

Tutti i valori numerici sono considerati validi nelle operazioni logiche, dove qualsiais numero diveros da zero è valutato \texttt{TRUE}. Pertanto viene seguito lo stesso ragionamento precedente, quando non è necessario valutare entrambe le parti della proposizione viene fornita una risposta, mentre si ottiene \texttt{NA} negli altri casi quando R è obbligato a valutare entrambe la parti ma è incapace di fornire una risspossta poichè non può determinare il valore di \texttt{NaN}.

\end{tip}

\begin{design}[L'importanza dei Dati Mancanti]

Lavorare in presenza di dati mancanti accadrà nella maggior parte dei casi. Molte delle funzioni presenti in R hanno già delle opzioni per rimuovere automaticamete eventuali dati mancanti così da poter ottenre correttamete i risultati.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_sample <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{8}\NormalTok{, }\OtherTok{NA}\NormalTok{)}
\KeywordTok{mean}\NormalTok{(my_sample)}
\CommentTok{## [1] NA}
\KeywordTok{mean}\NormalTok{(my_sample, }\DataTypeTok{na.rm =} \OtherTok{TRUE}\NormalTok{)}
\CommentTok{## [1] 5}
\end{Highlighting}
\end{Shaded}

Tuttavia, è importante non avvalersi in modo automatico di tali opzioni ma avere cura di valutare attentamente la presenza di dati mancanti. Questo ci permetterà di indagare possibili pattern riguardanti i dati mancanti e valutare la loro possibile influenza sui nostri risultati e la validità elle conclusioni.

Inoltre sarà fondamentale controllare sempre l'effittiva dimensione del campione utilizzato nelle vari analisi. Ad esempio se non valutato attentamente potremmo non ottenere il numero effettivo di valori su cui è stata calcolata precedentemente la media.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{length}\NormalTok{(my_sample)    }\CommentTok{# NA incluso}
\CommentTok{## [1] 5}
\KeywordTok{length}\NormalTok{(my_sample[}\OperatorTok{!}\KeywordTok{is.na}\NormalTok{(my_sample)]) }\CommentTok{# NA escluso}
\CommentTok{## [1] 4}
\end{Highlighting}
\end{Shaded}

\end{design}

\hypertarget{factors}{%
\chapter{Fattori}\label{factors}}

Working in progress.

\begin{itemize}
\tightlist
\item
  attributes
\item
  named vectors
\item
  factors, ordered factors
\end{itemize}

I fattori sono utilizzati per definire delle variabili categoriali, sono indicati in R con \texttt{Factor}. Per creare una variabile categoriale in R si utilizza la funzione:

\texttt{nome\_variabile\textless{}-factor(c(...,\ data,\ ...),\ levels=c(...))}

L'opzione \texttt{levels=c(...)} è usata per specificare quali sono i possibili livelli della variabile categoriale. E' possibile modificare o aggiungere nuovi livelli della variabile anche in un secondo momento utilizzando la funzione:

\texttt{levels(nome\_fattore)\textless{}-\ c(...,\ nuovi\_livelli,\ ...)}

\textbf{Nota}: nel creare un fattore R associa ad ogni livello un valore in ordine crescente e assegna agli elementi del vettore il loro volore numerico a seconda del proprio livello. Pertanto se un fattore è trasformato in un vettore numerico vengono restituiti tali valori numerici e non i livelli anche nel caso fossero dei numeri. Prendiamo per esempio la variabile \texttt{anni\_istruzione}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{anni_istruzione<-}\KeywordTok{factor}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{11}\NormalTok{,}\DecValTok{8}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{8}\NormalTok{,}\DecValTok{11}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{11}\NormalTok{,}\DecValTok{8}\NormalTok{))}
\NormalTok{anni_istruzione}
\CommentTok{## [1] 11 8  4  8  11 4  11 8 }
\CommentTok{## Levels: 4 8 11}
\KeywordTok{as.numeric}\NormalTok{(anni_istruzione)}
\CommentTok{## [1] 3 2 1 2 3 1 3 2}
\end{Highlighting}
\end{Shaded}

Per riottenere gli estti valori numerici è necessario eseguire:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.numeric}\NormalTok{(}\KeywordTok{as.character}\NormalTok{(anni_istruzione))}
\CommentTok{## [1] 11  8  4  8 11  4 11  8}
\end{Highlighting}
\end{Shaded}

\hypertarget{esercizi-5}{%
\subsection*{Esercizi}\label{esercizi-5}}
\addcontentsline{toc}{subsection}{Esercizi}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Crea la variabile categoriale \texttt{sex} così definita:
\end{enumerate}

\begin{verbatim}
## [1] M F M F M F F F M
## Levels: F M
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Rinomina i livelli della variabile \texttt{sex} rispettivamente in \texttt{"donne"} e \texttt{"uomini"}.
\item
  Crea la variabile categoriale \texttt{intervento} così definita:
\end{enumerate}

\begin{verbatim}
## [1] CBT         Psicanalisi CBT         Psicanalisi CBT         Psicanalisi
## [7] Controllo   Controllo   CBT        
## Levels: CBT Controllo Psicanalisi
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Correggi nella variabile \texttt{intervento} la 7° e 8° osservazione con la voce \texttt{Farmaci}.
\item
  Aggiungi alla variabile \texttt{intervento} le seguenti nuove osservazioni:
\end{enumerate}

\begin{verbatim}
## [1] "Farmaci"   "Controllo" "Farmaci"
\end{verbatim}

\hypertarget{matrix}{%
\chapter{Matrici}\label{matrix}}

Le matrici sono una struttura di dati \textbf{bidimensionale}, dove gli elementi sono disposti secondo righe e colonne. Possiamo quindi immaginare una matrice generica di \emph{m} righe e \emph{n} colonne in modo simile a quanto rappresentato in Figura \ref{fig:matrix}.

\begin{figure}

{\centering \includegraphics[width=0.75\linewidth]{images/matrix} 

}

\caption{Rappresentazione della struttura di una matrice di *m* colonne e *n* righe}\label{fig:matrix}
\end{figure}

Due caratteristiche importanti di una matrice sono:

\begin{itemize}
\tightlist
\item
  la \textbf{dimensione} - il numero di \textbf{righe} e di \textbf{colonne} da cui è formata la matrice
\item
  la \textbf{tipologia} - la tipologia di dati che sono contenuti nella matrice. Infatti, in modo analogo a quanto visto con i vettori, una matrice deve esssere formata da \textbf{elementi tutti dello stesso tipo}. Pertanto esistono diverse tipologie di matrici a seconda del tipo di dati da cui è formata, in particolare abbiamo matrici numeriche, di valori logici e di caratteri (vedi Capitolo TODO).
\end{itemize}

E' fondamentale inoltre sottolineare come ogni \textbf{elemento} di una matrice sia caratterizzato da:

\begin{itemize}
\tightlist
\item
  un \textbf{valore} - ovvero il valore dell'elemento che può essere di qualsiasi tipo ad esempio un numero o una serie di caratteri.
\item
  un \textbf{indice di posizione} - ovvero una \textbf{coppia di valori (\emph{i}, \emph{j})} interi positivi che indicando rispettivamente \textbf{l'indice di riga} e \textbf{l'indice di colonna} e che permettono di identificare univocamente l'elemento all'interno della matrice.
\end{itemize}

Ad esempio, data una matrice \(X\) di dimensione \(3\times4\) (i.e., 3 righe e 4 colonne) così definita:
\[
 X = 
\begin{bmatrix}
3 & 12 & 7 & 20\\
16 & 5 & 9 & 13\\
10 & 1 & 14 & 19
\end{bmatrix},
\]
abbiamo che \(x_{2, 3} = 9\) mentre \(x_{3, 2} = 1\). Questo ci serve solo per ribadire il corretto uso degli indici, dove per un generico elemento \(x_{i, j}\), il valore \emph{i} è l'indice di riga mentre il valore \emph{j} è l'indice di colonna. \textbf{Prima si indicano le righe poi le colonne}.

Vediamo ora come creare delle matrici in R e come compiere le comuni operazini di selezione. Successivamente vedremo diverse manipolazioni e operazioni con le matrici. Infine estenderemo brevemente il concetto di matrici a dimensioni maggiori di due atttraverso l'uso degli \textbf{array}.

\hypertarget{creazione-1}{%
\section{Creazione}\label{creazione-1}}

Il comando usato per creare una matrice in R è \texttt{matrix()} e contiene diversi argomenti:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nome_matrice <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(data, }\DataTypeTok{nrow =}\NormalTok{ , }\DataTypeTok{ncol =}\NormalTok{ , }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{data} - un \textbf{vettore di valori} utilizzati per popolare la matrice
\item
  \texttt{nrow} e \texttt{ncol} - sono rispettivamente il numero di righe e il numero di colonne della matrice
\item
  \texttt{byrow} - indica se la matrice deve essere popolata per riga oppure per colonna. Il valore di default è \texttt{FALSE} quindi i valori della matrice vengono aggiunti colonna dopo colonna. Indicare \texttt{TRUE} per aggiungere gli elementi riga dopo riga
\end{itemize}

Creiamo come esempio una matrice di 3 righe e 4 colonne con i valori che vanno da 1 a 12.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Dati per popolare la matrice}
\NormalTok{my_values <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{12}
\NormalTok{my_values}
\CommentTok{##  [1]  1  2  3  4  5  6  7  8  9 10 11 12}

\CommentTok{# Matrice popolata per colonne}
\NormalTok{mat_bycol <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(my_values, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}
\NormalTok{mat_bycol}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    1    4    7   10}
\CommentTok{## [2,]    2    5    8   11}
\CommentTok{## [3,]    3    6    9   12}
\end{Highlighting}
\end{Shaded}

La funzione \texttt{matrix()} ha di default l'argomento \texttt{byrow\ =\ FALSE}, quindi di base R popola le matrici colonna dopo colonna. Per popolare le matrici riga dopo riga invece, è necessario richiederlo esplicitamente specificando \texttt{byrow\ =\ TRUE}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Matrice popolata per righe}
\NormalTok{mat_byrow <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(my_values, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{mat_byrow}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    1    2    3    4}
\CommentTok{## [2,]    5    6    7    8}
\CommentTok{## [3,]    9   10   11   12}
\end{Highlighting}
\end{Shaded}

E' importante notare come mentre sia possibile specificare qualsiasi combinazione di righe e colonne, il numero di valori forniti per popolare la matrice deve essere compatibile con la dimensione della matrice. In altre parole, \textbf{non posso fornire più o meno dati di quelli che la matrice può contenere}.

Pertanto, la launghezza del vettore passato all'argomento \texttt{data} deve essere compatibile con gli argomenti \texttt{nrow} e \texttt{ncol}. E' possibile tuttavia, fornire un unico valore se si desidera ottenre una matrice in cui tutti i valori siano identici. Creiamo ad esempio una matrice vuota con soli valori \texttt{NA} con 3 righe e 3 colonne.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mat_NA <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\OtherTok{NA}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{3}\NormalTok{)}
\NormalTok{mat_NA}
\CommentTok{##      [,1] [,2] [,3]}
\CommentTok{## [1,]   NA   NA   NA}
\CommentTok{## [2,]   NA   NA   NA}
\CommentTok{## [3,]   NA   NA   NA}
\end{Highlighting}
\end{Shaded}

\begin{tip}[Ciclare Valori]

In realtà è possibile fornire più o meno dati di quelli che la matrice può contenere. Nel caso vengano forniti più valori, R semplicemente utilizza i primi valori disponibili ignorando quelli successivi.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{20}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{2}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{2}\NormalTok{)}
\CommentTok{##      [,1] [,2]}
\CommentTok{## [1,]    1    3}
\CommentTok{## [2,]    2    4}
\end{Highlighting}
\end{Shaded}

Nel caso vengano forniti meno valori, invece, R riutilizza gli stessi valori nello stesso ordinere per completare la matrice avvertendoci del problema.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    1    4    3    2}
\CommentTok{## [2,]    2    1    4    3}
\CommentTok{## [3,]    3    2    1    4}
\end{Highlighting}
\end{Shaded}

Tuttavia, è meglio evitare questa pratica di \emph{ciclare} i valori poichè i risultati potrebbero essere poco chiari ed è facile commettere errori.

\end{tip}

\hypertarget{tipologie-di-matrici}{%
\subsection{Tipologie di Matrici}\label{tipologie-di-matrici}}

Abbiamo viso che, in modo analogo ai vettori, anche per le matrici è necessario che tutti i dati siano della stessa tipologia. Avremo pertanto matrici che includono solo valori \texttt{character}, \texttt{double}, \texttt{integer} oppure \texttt{logical} e le operazioni che si potranno eseguire (uso di operatori matematiche o operatori logici-relazionali) dipenderanno dalla tipologia di dati. Tuttavia, a differenza dei vettori, la tipologia di oggetto rimarrà sempre \texttt{matrix} indipendentemente dai dati contenuti. Le matrici sono sempre matrici, è la tipologia di dati che varia.

\hypertarget{character-1}{%
\subsubsection*{Character}\label{character-1}}
\addcontentsline{toc}{subsubsection}{Character}

E' possibile definire una matrice di soli caratteri, tuttavia sono usate raramente visto che chiaramente tutte le operazioni matematiche non sono possibili.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mat_char <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{12}\NormalTok{], }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{mat_char}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,] "a"  "b"  "c"  "d" }
\CommentTok{## [2,] "e"  "f"  "g"  "h" }
\CommentTok{## [3,] "i"  "j"  "k"  "l"}

\KeywordTok{class}\NormalTok{(mat_char)}
\CommentTok{## [1] "matrix" "array"}
\KeywordTok{typeof}\NormalTok{(mat_char)}
\CommentTok{## [1] "character"}
\end{Highlighting}
\end{Shaded}

\begin{trick}[Letters]

In R esistono due speciali oggetti \texttt{letters} e \texttt{LETTERS} che includono rispettivamente le lettere minuscole e maiuscole dell'alfabeto inglese.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{]}
\CommentTok{## [1] "a" "b" "c" "d" "e"}
\NormalTok{LETTERS[}\DecValTok{6}\OperatorTok{:}\DecValTok{10}\NormalTok{]}
\CommentTok{## [1] "F" "G" "H" "I" "J"}
\end{Highlighting}
\end{Shaded}

\end{trick}

\hypertarget{numeric-1}{%
\subsubsection*{Numeric}\label{numeric-1}}
\addcontentsline{toc}{subsubsection}{Numeric}

Le matrici di valori numerici, sia \texttt{double} che \texttt{integer}, sono senza dubbio le più comuni ed utilizzate. Vengono spesso sfruttate per eseguire calcoli algebrici computazionalemnte molto efficienti.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# doubles}
\NormalTok{mat_num <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{5}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}
\KeywordTok{class}\NormalTok{(mat_num)}
\CommentTok{## [1] "matrix" "array"}
\KeywordTok{typeof}\NormalTok{(mat_num)}
\CommentTok{## [1] "double"}

\CommentTok{# integers}
\NormalTok{mat_int <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(5L, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}
\KeywordTok{class}\NormalTok{(mat_int)}
\CommentTok{## [1] "matrix" "array"}
\KeywordTok{typeof}\NormalTok{(mat_int)}
\CommentTok{## [1] "integer"}
\end{Highlighting}
\end{Shaded}

\hypertarget{logical-1}{%
\subsubsection*{Logical}\label{logical-1}}
\addcontentsline{toc}{subsubsection}{Logical}

Infine le matrici possono essere formate anche da valori logici \texttt{TRUE} e \texttt{FALSE}. Vedremo un loro importante utilizzo per quanto riguarda la selezione degli elementi di una matrice nel Capitolo TODO.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mat_logic <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\OtherTok{TRUE}\NormalTok{, }\OtherTok{FALSE}\NormalTok{), }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}
\NormalTok{mat_logic}
\CommentTok{##       [,1]  [,2]  [,3]  [,4]}
\CommentTok{## [1,]  TRUE FALSE  TRUE FALSE}
\CommentTok{## [2,] FALSE  TRUE FALSE  TRUE}
\CommentTok{## [3,]  TRUE FALSE  TRUE FALSE}
\KeywordTok{class}\NormalTok{(mat_logic)}
\CommentTok{## [1] "matrix" "array"}
\KeywordTok{typeof}\NormalTok{(mat_logic)}
\CommentTok{## [1] "logical"}
\end{Highlighting}
\end{Shaded}

Ricordiamo che è comunque possibile eseguire operazioni matematiche con i valori logici poichè verranno automaticamente rasformatti nei rispettivi valori numerici 1 e 0.

\hypertarget{esercizi-6}{%
\subsection*{Esercizi}\label{esercizi-6}}
\addcontentsline{toc}{subsection}{Esercizi}

Esegui i seguenti esercizi (\href{https://github.com/psicostat/Introduction2R/blob/master/exercises/chapter-09-matrices.R}{soluzioni}):
1. Crea la matrice \texttt{A} così definita:

\[
\begin{matrix}
2 & 34 & 12 & 7\\
46 & 93 & 27 & 99\\
23  & 38 & 7 & 04
\end{matrix}
\]

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Crea la matrice \texttt{B} contenente tutti i primi 12 numeri dispari disposti su 4 righe e 3 colonne.
\item
  Crea la matrice \texttt{C} contenente i primi 12 multipli di 9 disposti su 3 righe e 4 colonne.
\item
  Crea la matrice \texttt{D} formata da 3 colonne in cui le lettere \texttt{"A"},\texttt{"B"} e \texttt{"C"} vengano ripetute 4 volte ciascuna rispettivamente nella prima, seconda e terza colonna.
\item
  Crea la matrice \texttt{E} formata da 3 righe in cui le lettere \texttt{"A"},\texttt{"B"} e \texttt{"C"} vengano ripetute 4 volte ciascuna rispettivamente nella prima, seconda e terza riga.
\end{enumerate}

\hypertarget{sel-matrix}{%
\section{Selezione Elementi}\label{sel-matrix}}

L'aspetto sicuramente più importante (e divertente) riguardo le matrici è accedere ai vari elementi. Ricordiamo che una matrice non è altro che una griglia di righe e colonne dove vengono disposti i vari valori. Indipendentemente da cosa la matrice contenga, è possibile utilizzare gli indici di riga e di colonna per identificare univocamente un dato elemento nella matrice. Pertanto ad ogni elemento è associata una coppia di valori (\emph{i}, \emph{j}) dove \emph{i} è l'indice di riga e \emph{j} è l'indice di colonna.

Per visualizzare questo concetto, riportiamo nel seguente esempio gli indici per ogni elemnto di una matrice \(3\times4\):

\begin{verbatim}
##      [,1]  [,2]  [,3]  [,4] 
## [1,] "1,1" "1,2" "1,3" "1,4"
## [2,] "2,1" "2,2" "2,3" "2,4"
## [3,] "3,1" "3,2" "3,3" "3,4"
\end{verbatim}

In R è possibile selezionare un elemento di una matrice utilizzando il suo indice di riga e di colonna. In modo analogo ai vettori è necessario quindi indicare all'inerno delle \textbf{parentesi quadre} \texttt{{[}{]}} poste dopo il nome del vettore, \textbf{l'indice di riga} e \textbf{l'indice di colonna} \textbf{separati da virgola}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nome_matrice[}\OperatorTok{<}\NormalTok{indice}\OperatorTok{-}\NormalTok{riga}\OperatorTok{>}\NormalTok{, }\OperatorTok{<}\NormalTok{indice}\OperatorTok{-}\NormalTok{colonna}\OperatorTok{>}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

L'\textbf{ordine} \texttt{{[}\textless{}indice-riga\textgreater{},\ \textless{}indice-colonna\textgreater{}{]}} è prestabilito e deve essere rispettato affinché la selezione avvenga correttamente. Vediamo un semplice esempio di come sia possibile accedere ad un qualsiasi elemento:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{12}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}
\NormalTok{my_matrix}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    1    4    7   10}
\CommentTok{## [2,]    2    5    8   11}
\CommentTok{## [3,]    3    6    9   12}

\CommentTok{# Selezioniamo l'elemento alla riga 2 e colonna 3}
\NormalTok{my_matrix[}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{]}
\CommentTok{## [1] 8}

\CommentTok{# Selezioniamo il valore 6}
\NormalTok{my_matrix[}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{]}
\CommentTok{## [1] 6}
\end{Highlighting}
\end{Shaded}

\begin{warning}[Subscript out of Bounds]

Notiamo come indicando degli indici al di fuori della dimensione della matrice otteniamo un messaggio di errore.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_matrix[}\DecValTok{20}\NormalTok{,}\DecValTok{30}\NormalTok{]}
\CommentTok{## Error in my_matrix[20, 30]: subscript out of bounds}
\end{Highlighting}
\end{Shaded}

\end{warning}

Oltre alla selezione di un singolo elemento è possibile eseguire altri tipi di selezione:

\hypertarget{selezionare-riga-o-colonna}{%
\subsubsection*{Selezionare Riga o Colonna}\label{selezionare-riga-o-colonna}}
\addcontentsline{toc}{subsubsection}{Selezionare Riga o Colonna}

E' possibile selezionare \textbf{tutti} gli elementi di una riga o di una colonna utilizzando la seguente sintassi:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Selzione intera riga}
\NormalTok{nome_matrice[}\OperatorTok{<}\NormalTok{indice}\OperatorTok{-}\NormalTok{riga}\OperatorTok{>}\NormalTok{, ]}

\CommentTok{# Selzione intera colonna}
\NormalTok{nome_matrice[ , }\OperatorTok{<}\NormalTok{indice}\OperatorTok{-}\NormalTok{colonna}\OperatorTok{>}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Nota come sia comunque necessario l'utilizzo della \textbf{virgola} lasciando vuoto il posto prima o dopo la virgola per indicare ad R di selezionare rispettivamente tutte le righe o tutte le colonne.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Selezioniamo la 2 riga e tutte le colonne}
\NormalTok{my_matrix[}\DecValTok{2}\NormalTok{, ]}
\CommentTok{## [1]  2  5  8 11}

\CommentTok{# Selezioniamo  tutte le righe e la 3 colonna}
\NormalTok{my_matrix[ ,}\DecValTok{3}\NormalTok{]}
\CommentTok{## [1] 7 8 9}
\end{Highlighting}
\end{Shaded}

Qualora fosse necessario selezionare più righe o più colonne è sufficiente indicare tutti gli indici di interesse. Ricorda che questi devono essere specificati in un unico vettore. All'interno delle parentesi quadre, R si aspetta una sola virgola che separa gli indici di riga da quelli di colonna. E' quindi necessario combinare gli indici che vogliamo selezionare in un unico vettore sia nel caso delle righe che delle colonne. Per selezionare righe o colonne in successione, ad esempio le prime 3 colonne, posso utilizzare la scrittura compatta \texttt{1:3} che è equivalente a \texttt{c(1,2,3)}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Selezioniamo la 1 e 3 riga}
\NormalTok{my_matrix[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{), ]}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    1    4    7   10}
\CommentTok{## [2,]    3    6    9   12}

\CommentTok{# Selezioniamo dalla 2° alla 4° colonna}
\NormalTok{my_matrix[ , }\DecValTok{2}\OperatorTok{:}\DecValTok{4}\NormalTok{]}
\CommentTok{##      [,1] [,2] [,3]}
\CommentTok{## [1,]    4    7   10}
\CommentTok{## [2,]    5    8   11}
\CommentTok{## [3,]    6    9   12}
\end{Highlighting}
\end{Shaded}

\hypertarget{selezionare-regione-matrice}{%
\subsubsection*{Selezionare Regione Matrice}\label{selezionare-regione-matrice}}
\addcontentsline{toc}{subsubsection}{Selezionare Regione Matrice}

Combinando indici di righe e di colonne è anche possibile selezionare specifiche regioni di una matrice o selezionare alcuni suoi valori per creare una nuova matrice.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Selezioniamo un blocco}
\NormalTok{my_matrix[}\DecValTok{1}\OperatorTok{:}\DecValTok{2}\NormalTok{, }\DecValTok{3}\OperatorTok{:}\DecValTok{4}\NormalTok{]}
\CommentTok{##      [,1] [,2]}
\CommentTok{## [1,]    7   10}
\CommentTok{## [2,]    8   11}

\CommentTok{# Selezioniamo valori sparsi}
\NormalTok{my_matrix[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{), }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{)]}
\CommentTok{##      [,1] [,2]}
\CommentTok{## [1,]    4   10}
\CommentTok{## [2,]    6   12}
\end{Highlighting}
\end{Shaded}

\begin{tip}[Selezionare non è Modificare]

Ricordiamo che, come per i vettori, l'operazione di selezione non modifichi l'oggetto iniziale. Pertanto è necessario salvare il risultato della selezione se si desidera mantenere le modifiche.

\end{tip}

\begin{design}[Matrici e Vettori]

I più attenti avranno notato che che i comandi di selezione non restituiscono sempre lo stesso oggetto, a volte otteniamo come risultato un vettore e delle altre una matrice.

E' importante chiarire che una \textbf{un vettore non è un matrice} e tanto più vale l'opposto. In R questi sono due tipologie di oggetti diversi e sarà importante tenere a mente questa distinzione.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Un vettore non è una matrice}
\NormalTok{my_vector <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{5}
\KeywordTok{is.vector}\NormalTok{(my_vector) }\CommentTok{# TRUE}
\KeywordTok{is.matrix}\NormalTok{(my_vector) }\CommentTok{# FALSE}

\CommentTok{# Una matrice non è un vettore}
\NormalTok{my_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{3}\NormalTok{)}
\KeywordTok{is.vector}\NormalTok{(my_matrix) }\CommentTok{# FALSE}
\KeywordTok{is.matrix}\NormalTok{(my_matrix) }\CommentTok{# TRUE}
\end{Highlighting}
\end{Shaded}

Il risultato che otteniamo da una selezione potrebbe essere un vettore oppure una matrice a seconda del tipo di selezione. Vediamo in particolare come selezionando un'unica colonna (o riga) otteniamo un vettore mentre selezionando più colonne (o righe) otteniamo una matrice.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Seleziono una colonna}
\KeywordTok{is.vector}\NormalTok{(my_matrix[, }\DecValTok{1}\NormalTok{]) }\CommentTok{# TRUE}
\KeywordTok{is.matrix}\NormalTok{(my_matrix[, }\DecValTok{1}\NormalTok{]) }\CommentTok{# FALSE}

\CommentTok{# Seleziono più colonne}
\KeywordTok{is.vector}\NormalTok{(my_matrix[, }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{)]) }\CommentTok{# FALSE}
\KeywordTok{is.matrix}\NormalTok{(my_matrix[, }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{)]) }\CommentTok{# TRUE}
\end{Highlighting}
\end{Shaded}

Questa distinzione influirà sul successivo utilizzo dell'oggetto ottenuto dalla selezione.

\hypertarget{vettore-riga-e-vettore-colonna}{%
\subsubsection*{Vettore Riga e Vettore Colonna}\label{vettore-riga-e-vettore-colonna}}
\addcontentsline{toc}{subsubsection}{Vettore Riga e Vettore Colonna}

Una particolare fonte di incomprensioni e successivi errori riguarda proprio l'utilizzo di un vettore ottenuto dalla selezione di una singola riga (o una singola colonna) di una matrice come fosse un \emph{vettore riga} (o un \emph{vettore colonna}).

In algebra lineare, i \emph{vettori riga} ed i \emph{vettori colonna} non sono altro che delle matrici rispettivamente di dimensione \(1\times n\) e \(m \times 1\). La dimensione (\(righe \times colonne\)) di una matrice, e quindi anche di un vettore, rivestono un ruolo importante nelle operazioni con le matrici ed in particolare nel prodotto matriciale.

In R i vettori hanno una sola dimensione ovvero la \emph{lunghezza} e quindi nel loro utilizzo con operazioni tra matrici vengono convertiti automaticamente in vettori riga o vettori colonna a seconda delle necessità. Tuttavia, questa trasformazione potrebbe non sempre rispettare le attuali intenzioni ed è quindi meglio utlizzare sempre le matrici e non i vettori.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Vettore}
\NormalTok{my_vector <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{4}
\KeywordTok{dim}\NormalTok{(my_vector) }\CommentTok{# dimensione righe, colonne}
\CommentTok{## NULL}
\KeywordTok{length}\NormalTok{(my_vector)}
\CommentTok{## [1] 4}

\CommentTok{# Matrice 1x4 (vettore riga)}
\NormalTok{my_row_vector <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{1}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}
\KeywordTok{dim}\NormalTok{(my_row_vector) }
\CommentTok{## [1] 1 4}
\NormalTok{my_row_vector}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    1    2    3    4}

\CommentTok{# Matrice 4x1 (vettore colonna)}
\NormalTok{my_col_vector <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{4}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{4}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{1}\NormalTok{)}
\KeywordTok{dim}\NormalTok{(my_col_vector) }
\CommentTok{## [1] 4 1}
\NormalTok{my_col_vector}
\CommentTok{##      [,1]}
\CommentTok{## [1,]    1}
\CommentTok{## [2,]    2}
\CommentTok{## [3,]    3}
\CommentTok{## [4,]    4}
\end{Highlighting}
\end{Shaded}

\hypertarget{srotolare-una-matrice}{%
\subsubsection*{Srotolare una Matrice}\label{srotolare-una-matrice}}
\addcontentsline{toc}{subsubsection}{Srotolare una Matrice}

Abbiamo visto che possiamo facilmente popolare una matrice con un vettore. Allo stesso modo possiamo vettorizzare una matrice (in altri termini ``srotolare'' la matrice) per ritornare al vettore originale. Con il comando \texttt{c(matrice)} oppure forzando la tipologia di oggetto a vettore con \texttt{vector(matrice)} o \texttt{as.vector(matrice)}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Da matrice a vettore}
\NormalTok{my_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{12}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}
\KeywordTok{c}\NormalTok{(my_matrix)}
\CommentTok{##  [1]  1  2  3  4  5  6  7  8  9 10 11 12}
\KeywordTok{as.vector}\NormalTok{(my_matrix)}
\CommentTok{##  [1]  1  2  3  4  5  6  7  8  9 10 11 12}
\end{Highlighting}
\end{Shaded}

\end{design}

\hypertarget{utilizzi-avanzati-selezione-1}{%
\subsection{Utilizzi Avanzati Selezione}\label{utilizzi-avanzati-selezione-1}}

Vediamo ora alcuni utilizzi avanzati della selezione di elementi di una matrice. In particolare impareremo a:

\begin{itemize}
\tightlist
\item
  utilizzare gli operatori relazionali e logici per selezionare gli elementi di una martrice
\item
  modificare l'ordine di righe e colonne
\item
  sostituire degli elementi
\item
  eliminare delle righe o colonne
\end{itemize}

Nota che queste operazioni siano analoghe a quelle viste per i vettori e quindi seguiranno le stesse regole e principi.

\hypertarget{operatori-relazionali-e-logici-1}{%
\subsubsection*{Operatori Relazionali e Logici}\label{operatori-relazionali-e-logici-1}}
\addcontentsline{toc}{subsubsection}{Operatori Relazionali e Logici}

Un'utile funzione è quella di selezionare tra gli elementi di una matrice quelli che rispetano una certa condizione. Possiamo ad esempio valutare \emph{``quali elementi della matrice sono maggiori di x?''}. Per fare questo dobbiamo specificare all'interno delle parentesi quadre la proposizione di interesse utilizzando gli operatori relazionali e logici (vedi Capitolo \ref{operators-rel-log}).

Quando una matrice è valutata all'interno di una proposizione, R valuta la veridicità di tale proposizione rispetto ad ogni suo elemento. Come risultato otteniamo una matrice di valori logici con le rispettive risposte per ogni elemento (\texttt{TRUE} o \texttt{FALSE}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{23}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}
\CommentTok{## Warning in matrix(1:23, nrow = 3, ncol = 4): data length [23] is not a sub-}
\CommentTok{## multiple or multiple of the number of rows [3]}
\NormalTok{my_matrix}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    1    4    7   10}
\CommentTok{## [2,]    2    5    8   11}
\CommentTok{## [3,]    3    6    9   12}

\CommentTok{# Elemeni maggiori di 4 e minori di 10}
\NormalTok{test <-}\StringTok{ }\NormalTok{my_matrix }\OperatorTok{>=}\StringTok{ }\DecValTok{4} \OperatorTok{&}\StringTok{ }\NormalTok{my_matrix }\OperatorTok{<=}\DecValTok{10}
\NormalTok{test}
\CommentTok{##       [,1] [,2] [,3]  [,4]}
\CommentTok{## [1,] FALSE TRUE TRUE  TRUE}
\CommentTok{## [2,] FALSE TRUE TRUE FALSE}
\CommentTok{## [3,] FALSE TRUE TRUE FALSE}
\end{Highlighting}
\end{Shaded}

Questa matrice può essere utilizzata all'interno delle parentesi quadre per selezionare gli elementi della matrice originale che soddisfano la proposizione. Gli elementi associati al valore \texttt{TRUE} sono selezionati mentre quelli associati al valore \texttt{FALSE} sono scartati.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Seleziono gli elementi}
\NormalTok{my_matrix[test]}
\CommentTok{## [1]  4  5  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}

Nota come in questo caso non sia necessaria alcuna virgola all'interno delle parentesi quadre e come il risultato ottenuto sia un vettore.

\hypertarget{modificare-ordine-righe-e-colonne}{%
\subsubsection*{Modificare Ordine Righe e Colonne}\label{modificare-ordine-righe-e-colonne}}
\addcontentsline{toc}{subsubsection}{Modificare Ordine Righe e Colonne}

Gli indici di riga e di colonna possono essere utilizzati per riordinare le righe e le colonne di una matrice a seconda delle necessità.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}
\NormalTok{my_matrix}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    1    4    1    4}
\CommentTok{## [2,]    2    5    2    5}
\CommentTok{## [3,]    3    6    3    6}

\CommentTok{# Altero l'ordinen delle righe}
\NormalTok{my_matrix[}\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{), ]}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    3    6    3    6}
\CommentTok{## [2,]    2    5    2    5}
\CommentTok{## [3,]    1    4    1    4}

\CommentTok{# Altero l'ordine delle colonnne}
\NormalTok{my_matrix[ ,}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{, }\DecValTok{4}\NormalTok{)]}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    1    1    4    4}
\CommentTok{## [2,]    2    2    5    5}
\CommentTok{## [3,]    3    3    6    6}
\end{Highlighting}
\end{Shaded}

\hypertarget{modificare-gli-elementi-1}{%
\subsubsection*{Modificare gli Elementi}\label{modificare-gli-elementi-1}}
\addcontentsline{toc}{subsubsection}{Modificare gli Elementi}

Un importante utilizzo degli indici riguarda la modifica di un elemento di una matrice. Per sostituire un vecchio valore con un nuovo valore, seleziono il vecchio valore della matrice e utilizzo la funzione \texttt{\textless{}-} (o \texttt{=}) per assegnare il nuovo valore.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{12}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}
\NormalTok{my_matrix}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    1    4    7   10}
\CommentTok{## [2,]    2    5    8   11}
\CommentTok{## [3,]    3    6    9   12}

\CommentTok{# Modifico il l'elemento con il valore 5}
\NormalTok{my_matrix[}\DecValTok{2}\NormalTok{,}\DecValTok{2}\NormalTok{] <-}\StringTok{ }\DecValTok{555}
\NormalTok{my_matrix}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    1    4    7   10}
\CommentTok{## [2,]    2  555    8   11}
\CommentTok{## [3,]    3    6    9   12}
\end{Highlighting}
\end{Shaded}

E' possibile anche sostituire tutti i valori di un'intera riga o colonnna opportunamente selezionata. In questo caso sarà necessario fornire un corretto numero di nuovi valori da utilizzare.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Modifico la 2 colonna}
\NormalTok{my_matrix[ ,}\DecValTok{2}\NormalTok{] <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{444}\NormalTok{, }\DecValTok{555}\NormalTok{, }\DecValTok{666}\NormalTok{)}
\NormalTok{my_matrix}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    1  444    7   10}
\CommentTok{## [2,]    2  555    8   11}
\CommentTok{## [3,]    3  666    9   12}

\CommentTok{# Modifico la 3 riga}
\NormalTok{my_matrix[}\DecValTok{3}\NormalTok{, ] <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{111}\NormalTok{, }\DecValTok{666}\NormalTok{, }\DecValTok{999}\NormalTok{, }\DecValTok{122}\NormalTok{)}
\NormalTok{my_matrix}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    1  444    7   10}
\CommentTok{## [2,]    2  555    8   11}
\CommentTok{## [3,]  111  666  999  122}
\end{Highlighting}
\end{Shaded}

Nota come a differenza dei vettori non possa aggiungere una nuova riga o colonna attraverso questa operazione ma sarà necesssario utilizzare una diversa procedura (vedi Capitolo TODO).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Aggiungo una nuova colona [errore selezione indici]}
\NormalTok{my_matrix[, }\DecValTok{5}\NormalTok{] <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{27}\NormalTok{, }\DecValTok{27}\NormalTok{, }\DecValTok{27}\NormalTok{)}
\CommentTok{## Error in `[<-`(`*tmp*`, , 5, value = c(27, 27, 27)): subscript out of bounds}
\end{Highlighting}
\end{Shaded}

\hypertarget{eliminare-righe-o-colonne}{%
\subsubsection*{Eliminare Righe o Colonne}\label{eliminare-righe-o-colonne}}
\addcontentsline{toc}{subsubsection}{Eliminare Righe o Colonne}

Per \textbf{eliminare} delle righe (o delle colonne) da una matrice, è necessario indicare all'interno delle parentesi quadre gli indici di riga (o di colonna) che si intende eliminare, preceduti dall'operatore \texttt{-} (\emph{meno}). Nel caso di più righe (o colone) è possibile indicare il meno solo prima del comando \texttt{c()} analogamente con quanto fatto con i vettori.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{12}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}

\CommentTok{# Elimino la 2° riga}
\NormalTok{my_matrix[}\OperatorTok{-}\DecValTok{2}\NormalTok{, ]}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    1    4    7   10}
\CommentTok{## [2,]    3    6    9   12}

\CommentTok{# Elimino la 2° riga  e la 2° e 3° colonna}
\NormalTok{my_matrix[}\OperatorTok{-}\DecValTok{2}\NormalTok{, }\OperatorTok{-}\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{)]}
\CommentTok{##      [,1] [,2]}
\CommentTok{## [1,]    1   10}
\CommentTok{## [2,]    3   12}
\end{Highlighting}
\end{Shaded}

Nota come l'operazione di eliminazione sia comunque un'operazione di selezione. Pertanto è necessario salvare il risultato ottenuto se si desidera mantenere le modifiche.

\hypertarget{esercizi-7}{%
\subsection*{Esercizi}\label{esercizi-7}}
\addcontentsline{toc}{subsection}{Esercizi}

Utilizzando le matrici create nei precedenti esercizi esegui le seguenti consegne (\href{https://github.com/psicostat/Introduction2R/blob/master/exercises/chapter-09-matrices.R}{soluzioni}):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Utilizzando gli indici di riga e di colonna selziona il numero 27 della matrice \texttt{A}
\item
  Selziona gli elementi compresi tra la seconda e quarta riga, seconda e terza colonna della matrice \texttt{B}
\item
  Seleziona solo gli elementi pari della matrice \texttt{A} (Nota: utilizza l'operazione resto \texttt{\%\%})
\item
  Elimina dalla matrice \texttt{C} la terza riga e la terza colonna
\item
  Seleziona tutti gli elementi della seconda e terza riga della matrice \texttt{B}
\item
  Seleziona tutti gli elementi diversi da ``B'' appartenenti alla matrice \texttt{D}
\end{enumerate}

\hypertarget{funzioni-ed-operazioni}{%
\section{Funzioni ed Operazioni}\label{funzioni-ed-operazioni}}

Vediamo ora alcune funzioni frequentemente usate e le comuni operazioni eseguite con le matrici (vedi Tabella \ref{tab:table-matrix-operators}).

\begin{table}[!h]

\caption{\label{tab:table-matrix-operators}Funzioni e operazioni con matrici}
\centering
\begin{tabular}[t]{l|l}
\hline
Funzione & Descrizione\\
\hline
\texttt{nuova\_matrice <- cbind(matrice1, matrice2)} & Unire due matrici creando nuove colonne (le matrici devono avere lo stesso numero di righe)\\
\hline
\texttt{nuova\_matrice <- rbind(matrice1, matrice2)} & Unire due matrici creando nuove righe (le matrici devono avere lo stesso numero di colonne)\\
\hline
\texttt{nrow(nome\_matrice)} & Numero di righe della matrice\\
\hline
\texttt{ncol(nome\_matrice)} & Numero di colonne della matrice\\
\hline
\texttt{dim(nome\_matrice)} & Dimensione della matrice (righe e colonne)\\
\hline
\texttt{colnames(nome\_matrice)} & Nomi delle colonne della matrice\\
\hline
\texttt{rownames(nome\_matrice)} & Nomi delle righe della matrice\\
\hline
\texttt{dimnames(nome\_matrice)} & Nomi delle righe e delle colonne\\
\hline
\texttt{t(nome\_matrice)} & Trasposta della matrice\\
\hline
\texttt{diag(nome\_matrice)} & Vettore con gli elementi della diagonale della matrice\\
\hline
\texttt{det(nome\_matrice)} & Determinante della matrice (la matrice deve essere quadrata)\\
\hline
\texttt{solve(nome\_matrice)} & Inversa della matrice\\
\hline
\texttt{matrice1 + matrice2} & Somma elemento per elemento di due matrici\\
\hline
\texttt{matrice1 - matrice2} & Differenza elemento per elemento tra due matrici\\
\hline
\texttt{matrice1 * matrice2} & Prodotto elemento per elemento tra due matrici\\
\hline
\texttt{matrice1 / matrice2} & Rapporto elemento per elemento tra due matrici\\
\hline
\texttt{matrice1 \%*\% matrice2} & Prodotto matriciale\\
\hline
\end{tabular}
\end{table}

Descriviamo ora nel dettaglio alcuni particolari utilizzi.

\hypertarget{mat-prop}{%
\subsection{Attributi di una Matrice}\label{mat-prop}}

Abbiamo visto nel Capitolo TODO che gli oggetti in R possiedono quelli che sono definiti \emph{attibuti} ovvero delle utili informazioni riguardanti l'oggetto stesso, una sorta di \emph{metadata}. Vediamo ora alcuni attributi particolarmente rilevanti nel caso delle matrici ovvero la dimensione (\texttt{dim}) e i nomi delle righe e colonne (\texttt{names}).

\hypertarget{dimensione}{%
\subsubsection*{Dimensione}\label{dimensione}}
\addcontentsline{toc}{subsubsection}{Dimensione}

Ricordiamo che la matrice è un oggetto \textbf{bidimensionale} formato da righe e colonne. Queste formano pertanto le dimensioni di una matrice. Per ottenere il numero di righe e di colonne di una matrice, possiamo usare rispettivamente i comandi \texttt{nrow()} e \texttt{ncol()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{12}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{3}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{4}\NormalTok{)}

\CommentTok{# Numero di righe}
\KeywordTok{nrow}\NormalTok{(my_matrix)}
\CommentTok{## [1] 4}

\CommentTok{# Numero di colonne}
\KeywordTok{ncol}\NormalTok{(my_matrix)}
\CommentTok{## [1] 3}
\end{Highlighting}
\end{Shaded}

In alternativa per conoscere le dimensioni di una matrice è possibile utilizzare la funzione \texttt{dim()}. Questa ci restituirà un vettore con due valori dove il primo rappresenta il numero di righe e il secondo il numero di colonne.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{dim}\NormalTok{(my_matrix)}
\CommentTok{## [1] 4 3}
\end{Highlighting}
\end{Shaded}

\hypertarget{nomi-righe-e-colonne}{%
\subsubsection*{Nomi Righe e Colonne}\label{nomi-righe-e-colonne}}
\addcontentsline{toc}{subsubsection}{Nomi Righe e Colonne}

Come avrete notato, di base le dimensioni di una matrice (ovvero le righe e le colonne) vengono identificate attraverso i loro indici numerici. In R tuttavia, è anche possibile assegnare dei nomi alle righe e alle colonne di una matrice.

Con i comandi \texttt{rownames()} e \texttt{colnames()} possiamo accedere rispettivamente ai nomi delle righe e delle colonne.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{12}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}

\CommentTok{# Nome di righe}
\KeywordTok{rownames}\NormalTok{(mat)}
\CommentTok{## NULL}

\CommentTok{# Nome di colonne}
\KeywordTok{colnames}\NormalTok{(mat)}
\CommentTok{## NULL}
\end{Highlighting}
\end{Shaded}

Non essendo impostati, ottieniamo inizialmente come output il valore \texttt{NULL}. Per impostare i nomi di righe e/o colonne, sarà quindi necessario assegnare a \texttt{rownames(nome\_matrice)} e \texttt{colnames(nome\_matrice)} un vettore di caratteri della stessa lunghezza della dimensione che stiamo rinominando. Se impostiamo un unico carattere, tutte le righe/colonne avranno lo stesso valore. Questo ci fa capire che, se vogliamo impostare dei nomi, R richiede che questo venga fatto per tutte le righe/colonne.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Assegnamo i nomi alle righe}
\KeywordTok{rownames}\NormalTok{(my_matrix) <-}\StringTok{ }\NormalTok{LETTERS[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{]}
\NormalTok{my_matrix}
\CommentTok{##   [,1] [,2] [,3] [,4]}
\CommentTok{## A    1    4    7   10}
\CommentTok{## B    2    5    8   11}
\CommentTok{## C    3    6    9   12}

\CommentTok{# Assegno i nomi alle colonne}
\KeywordTok{colnames}\NormalTok{(my_matrix) <-}\StringTok{ }\NormalTok{LETTERS[}\DecValTok{4}\OperatorTok{:}\DecValTok{7}\NormalTok{]}
\NormalTok{my_matrix}
\CommentTok{##   D E F  G}
\CommentTok{## A 1 4 7 10}
\CommentTok{## B 2 5 8 11}
\CommentTok{## C 3 6 9 12}
\end{Highlighting}
\end{Shaded}

In alternativa posson utilizzare il \texttt{dimnames()} per accedere contemporaneamente sia ai nomi di riga che a quelli di colonna. Come output ottengo una lista (vedi Capitolo TODO) dove vengono prima indicati i nomi di riga e poi quelli di colonna

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{dimnames}\NormalTok{(my_matrix)}
\CommentTok{## [[1]]}
\CommentTok{## [1] "A" "B" "C"}
\CommentTok{## }
\CommentTok{## [[2]]}
\CommentTok{## [1] "D" "E" "F" "G"}
\end{Highlighting}
\end{Shaded}

\begin{design}[Selezione per Nomi]

Quando nel Capitolo \ref{sel-matrix} abbiamo visto i diversi modi di selezionare gli elementi di una matrice, abbiamo sempre usato gli indici numerici di riga e di colonna. Tuttavia, quando i nomi delle delle dimensioni sono disponibili, è possibile indicizzare una matrice in base ai nomi delle righe e/o colone.

Possiamo quindi selezionare la prima colonna sia con il suo indice numerico \texttt{nome\_matrice{[}\ ,\ 1{]}} ma anche con il nome assegnato \texttt{nome\_matrice{[}\ ,"nome\_colonna"{]}}. Queste sono operazioni poco utili con le matrici ma che saranno fondamentali nel caso dei \textbf{dataframe} (vedi Capitolo TODO).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Seleziono la colona "F"}
\NormalTok{my_matrix[ , }\StringTok{"F"}\NormalTok{]}
\CommentTok{## A B C }
\CommentTok{## 7 8 9}

\CommentTok{# Selezioniamo la riga "A" e "C"}
\NormalTok{my_matrix[}\KeywordTok{c}\NormalTok{(}\StringTok{"A"}\NormalTok{, }\StringTok{"C"}\NormalTok{), ]}
\CommentTok{##   D E F  G}
\CommentTok{## A 1 4 7 10}
\CommentTok{## C 3 6 9 12}
\end{Highlighting}
\end{Shaded}

\end{design}

\hypertarget{unire-matrici}{%
\subsection{Unire Matrici}\label{unire-matrici}}

Abbiamo visto nel Capitolo \ref{vector-functions} come si possono unire diversi vettori tramite la funnzione \texttt{c()}. Anche per le matrici è possibile combinare matrici diverse, rispettando però alcune regole:

\begin{itemize}
\tightlist
\item
  \texttt{rbind()} - Posso unire matrici \textbf{per riga} ovvero aggiungo una o più righe ad una matrice, in questo caso le matrici devono avere lo stesso numero di colonne
\item
  \texttt{cbind()} - Posso unire matrici \textbf{per colonna} ovvero aggiungo una o più colonne ad una matrice, in questo caso le matrici devono avere lo stesso numero di righe
\item
  Le matrici che unisco devono essere della \textbf{stessa tipologia} (numeri o caratteri)
\end{itemize}

Quindi, data una matrice \texttt{my\_matrix} di dimensione \(m \times n\) se volgiamo aggiungere le righe di una seconda matrice \texttt{row\_matrix} possiamo utlizzare il comando \texttt{rbind(my\_matrix,\ row\_matrix)} a patto che abbiano lo stesso numero di colonnne (\(n\)). Se vogliamo invece aggiungere le colonne di una nuova matrice \texttt{col\_matrix} possiamo utlizzare il comando \texttt{cbind(my\_matrix,\ col\_matrix)} a patto che abbiano lo stesso numero di righe (\(m\)). E' utile pensare all'unione come ad un collage tra matrici. In Figura\ref{fig:mat-comb} è presente uno schema utile per capire visivamente questo concetto, dove le matrici colorate in verde possono essere correttamente unite mentre le matrici in rosso non presentano la corretta dimensionalità.

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{images/matrix_comb} 

}

\caption{Schema per la combinazione di matrici}\label{fig:mat-comb}
\end{figure}

Vediamo un esempio in R:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Matrice di partenza}
\NormalTok{my_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{12}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}
\NormalTok{my_matrix}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    1    4    7   10}
\CommentTok{## [2,]    2    5    8   11}
\CommentTok{## [3,]    3    6    9   12}

\CommentTok{# Matrice con stesso numero di colonne}
\NormalTok{row_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{77}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{2}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}
\NormalTok{row_matrix}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]   77   77   77   77}
\CommentTok{## [2,]   77   77   77   77}

\CommentTok{# Unione per riga}
\KeywordTok{rbind}\NormalTok{(my_matrix, row_matrix)}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    1    4    7   10}
\CommentTok{## [2,]    2    5    8   11}
\CommentTok{## [3,]    3    6    9   12}
\CommentTok{## [4,]   77   77   77   77}
\CommentTok{## [5,]   77   77   77   77}


\CommentTok{# Matrice con stesso numero di righe}
\NormalTok{col_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{99}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{2}\NormalTok{)}
\NormalTok{col_matrix}
\CommentTok{##      [,1] [,2]}
\CommentTok{## [1,]   99   99}
\CommentTok{## [2,]   99   99}
\CommentTok{## [3,]   99   99}

\CommentTok{# Unione per colonna}
\KeywordTok{cbind}\NormalTok{(my_matrix, col_matrix)}
\CommentTok{##      [,1] [,2] [,3] [,4] [,5] [,6]}
\CommentTok{## [1,]    1    4    7   10   99   99}
\CommentTok{## [2,]    2    5    8   11   99   99}
\CommentTok{## [3,]    3    6    9   12   99   99}
\end{Highlighting}
\end{Shaded}

Un ultimo aspetto utile è l'estensione dei comandi \texttt{cbind()} ed \texttt{rbind()}. Fino ad ora li abbiamo utilizzati con due soli elementi: matrice di partenza e matrice da aggiungere. Tuttavia, è possibile indicare più matrici che si vogliono unire, separandole con una virgola. Se vogliamo combinare \(n\) matrici possiamo usare il comando \texttt{cbind(mat1,\ mat2,\ mat3,\ ...)} o \texttt{rbind(mat1,\ mat2,\ mat3,\ ...)}. In questo caso il risultato finale sarà l'unione delle matrici nell'ordine utilizzato nel definire gli argomenti quindi prima la \texttt{mat1}, poi la \texttt{mat2} e così via.

\begin{warning}["Matrices Must Match"]

Abbiamo visto che possiamo unire matrici per riga/colonna solo se il numero di colonne/righe delle due matrici sono equivalenti. Otteniamo un errore, invece, quando cerchiamo di combinare matrici di dimensioni diverse \emph{``number of columns/rows of matrices must match''}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{12}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}

\CommentTok{# Matrice con errato numero di colonne}
\NormalTok{wrong_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{77}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{2}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{7}\NormalTok{)}
\KeywordTok{rbind}\NormalTok{(my_matrix, wrong_matrix)}
\CommentTok{## Error in rbind(my_matrix, wrong_matrix): number of columns of matrices must match (see arg 2)}
\end{Highlighting}
\end{Shaded}

\end{warning}

\hypertarget{operatori-matematici}{%
\subsection{Operatori Matematici}\label{operatori-matematici}}

Gli operatori matematici (e.g., \texttt{+}, \texttt{-}, \texttt{*}, \texttt{/}, etc.) svolgono le operazioni tra una matrice ed un singolo valore, tra una matrice ed un vettore oppure tra due matrici.

\hypertarget{operazione-tra-matrice-e-valore-singolo}{%
\subsubsection*{Operazione tra Matrice e Valore Singolo}\label{operazione-tra-matrice-e-valore-singolo}}
\addcontentsline{toc}{subsubsection}{Operazione tra Matrice e Valore Singolo}

Nel caso di un singolo valore, la stessa operazione viene semplicemente eseguita su tutti gli elementi della matrice. Possiamo ad esempio aggiungere a tutti gli elementi di una matrice il volore 100.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{12}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}
\NormalTok{my_matrix}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    1    4    7   10}
\CommentTok{## [2,]    2    5    8   11}
\CommentTok{## [3,]    3    6    9   12}

\CommentTok{# Aggiungo 100}
\NormalTok{my_matrix }\OperatorTok{+}\StringTok{ }\DecValTok{100}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]  101  104  107  110}
\CommentTok{## [2,]  102  105  108  111}
\CommentTok{## [3,]  103  106  109  112}
\end{Highlighting}
\end{Shaded}

\hypertarget{operazione-tra-matrice-e-vettore}{%
\subsubsection*{Operazione tra Matrice e Vettore}\label{operazione-tra-matrice-e-vettore}}
\addcontentsline{toc}{subsubsection}{Operazione tra Matrice e Vettore}

Nel caso di un vettore, l'operazione viene eseguita \textbf{elemento per elemento} ciclando i valori del vettore qualora la sua lunghezza non sia suficiente. Possiamo ad esempio aggiungere a tutti gli elementi di una matrice il vettore di valori \texttt{c(100,\ 200,\ 300,\ 400)}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Aggiungo un vettore di valori}
\NormalTok{my_matrix }\OperatorTok{+}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{200}\NormalTok{, }\DecValTok{300}\NormalTok{, }\DecValTok{400}\NormalTok{)}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]  101  404  307  210}
\CommentTok{## [2,]  202  105  408  311}
\CommentTok{## [3,]  303  206  109  412}
\end{Highlighting}
\end{Shaded}

Com'è facilmente intuibile, questa operazione è poco connsigliata poichè è facile causa di errori ed incomprensioni.

\hypertarget{operazione-tra-matrici}{%
\subsubsection*{Operazione tra Matrici}\label{operazione-tra-matrici}}
\addcontentsline{toc}{subsubsection}{Operazione tra Matrici}

Nel caso di operazioni tra matrici, l'operazione viene eseguita \textbf{elemento per elemento} ed è quindi importante che le matrici abbiano la \textbf{stessa dimensione}. Possiamo ad esempio aggiungere a tutti gli elementi di una matrice nelle cui righe abbiamo i valori 100, 200, 300 e 400.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{sum_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{100}\NormalTok{, }\DecValTok{200}\NormalTok{, }\DecValTok{300}\NormalTok{, }\DecValTok{400}\NormalTok{), }\DataTypeTok{each =} \DecValTok{3}\NormalTok{), }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}
\NormalTok{sum_matrix}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]  100  200  300  400}
\CommentTok{## [2,]  100  200  300  400}
\CommentTok{## [3,]  100  200  300  400}

\CommentTok{# sommo due matrici}
\NormalTok{my_matrix }\OperatorTok{+}\StringTok{ }\NormalTok{sum_matrix}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]  101  204  307  410}
\CommentTok{## [2,]  102  205  308  411}
\CommentTok{## [3,]  103  206  309  412}
\end{Highlighting}
\end{Shaded}

\begin{tip}[Matrix Multiplication]

Nota come in R l'operatore \texttt{*} indichi il semmplice prodotto elemento per elemento mentre per ottenere il prodotto matriciale è necessario utilizzare l'operatore \texttt{\%*\%}.

Il prodotto matriciale segue delle specifiche regole e specifiche proprietà. In particolare, il numero di colonne della prima matrice deve essere uguale al numero di righe della seconda matrice. Per un approfondimento vedi \url{https://it.wikipedia.org/wiki/Moltiplicazione_di_matrici}.

\hypertarget{algebra-lineare}{%
\subsubsection*{Algebra Lineare}\label{algebra-lineare}}
\addcontentsline{toc}{subsubsection}{Algebra Lineare}

Anche altri aspetti che riguardano le operazioni con le matrici non vengono qui discusse ma si rimanda il lettore interessato alle seguenti pagine:

\begin{itemize}
\tightlist
\item
  Per il significato di determinante di una matrice considera \url{https://it.wikipedia.org/wiki/Determinante}
\item
  Per il significato di matrice inversa considera \url{https://it.wikipedia.org/wiki/Matrice_invertibile}
\end{itemize}

\hypertarget{diagonale}{%
\subsubsection*{Diagonale}\label{diagonale}}
\addcontentsline{toc}{subsubsection}{Diagonale}

Vediamo ora alcuni utili funzioni che riguardano la diagonale di una matrice. La diagonale di una matrice è formata dagli elementi i cui indici di riga e di colonna sono uguali, ovvero l'insieme di elementi associati allo stesso indice di riga e colonna (\(x_{i,i}\)).

Il comando \texttt{diag(nome\_matrice)} permette di estrarre la diagonale di una matrice e trattarla come un semplice vettore:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Matrice quadrata}
\NormalTok{square_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{16}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{4}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}
\NormalTok{square_matrix}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    1    5    9   13}
\CommentTok{## [2,]    2    6   10   14}
\CommentTok{## [3,]    3    7   11   15}
\CommentTok{## [4,]    4    8   12   16}

\KeywordTok{diag}\NormalTok{(square_matrix)}
\CommentTok{## [1]  1  6 11 16}

\CommentTok{# Matrice non quadrata}
\NormalTok{my_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{12}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}
\NormalTok{my_matrix}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    1    4    7   10}
\CommentTok{## [2,]    2    5    8   11}
\CommentTok{## [3,]    3    6    9   12}

\KeywordTok{diag}\NormalTok{(my_matrix)}
\CommentTok{## [1] 1 5 9}
\end{Highlighting}
\end{Shaded}

La funzione \texttt{diag()} può anche essere usata per sostituire in modo semplice gli elementi sulla diagonale di una matrice oppure per creare una matrice diagonale in cui gli altri valori siano tutti zero, ad esempio la matrice identità.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Sostituisco gli elementi della diagonale}
\KeywordTok{diag}\NormalTok{(my_matrix) <-}\StringTok{ }\DecValTok{999}
\NormalTok{my_matrix}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]  999    4    7   10}
\CommentTok{## [2,]    2  999    8   11}
\CommentTok{## [3,]    3    6  999   12}

\CommentTok{# Creo una matrice diagonale}
\KeywordTok{diag}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{3}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{)}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    4    0    0    0}
\CommentTok{## [2,]    0    4    0    0}
\CommentTok{## [3,]    0    0    4    0}

\CommentTok{# Creo una matrice identità 4X4}
\KeywordTok{diag}\NormalTok{(}\DecValTok{4}\NormalTok{)}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,]    1    0    0    0}
\CommentTok{## [2,]    0    1    0    0}
\CommentTok{## [3,]    0    0    1    0}
\CommentTok{## [4,]    0    0    0    1}
\end{Highlighting}
\end{Shaded}

\end{tip}

\hypertarget{esercizi-8}{%
\subsection*{Esercizi}\label{esercizi-8}}
\addcontentsline{toc}{subsection}{Esercizi}

Utilizzando le matrici create nei precedenti esercizi, esegui le seguentti consegne (\href{https://github.com/psicostat/Introduction2R/blob/master/exercises/chapter-09-matrices.R}{soluzioni}):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Crea la matrice \texttt{G} unendo alla matrice \texttt{A} le prime due colonne della matrice \texttt{C}
\item
  Crea la matrice \texttt{H} unendo alla matrice \texttt{C} le prime due righe della matrice trasposta di \texttt{B}
\item
  Ridefinisci la matrice \texttt{A} eliminando la seconda colonna. Ridefinisci la matrice \texttt{B} eliminando la prima riga. Verifica che le matrici così ottenute abbiano la stessa dimensione.
\item
  Commenta i differenti risultati che otteniamo nelle operazioni \texttt{A*B}, \texttt{B*A}, \texttt{A\%*\%B} e \texttt{B\%*\%A}.
\item
  Assegna i seguenti nomi alle colonne e alle righe della matrice \texttt{C}: \texttt{"col\_1",\ "col\_2",\ "col\_3",\ "col\_4",\ "row\_1",\ "row\_2",\ "row\_3"}.
\end{enumerate}

\hypertarget{array}{%
\section{Array}\label{array}}

Abbiamo visto come le matrici siano un oggetto \emph{bidimensionale}, tuttavia è possibile anche creare oggetti che abbiano 3, 4 o un qualsiasi numero (\emph{n}) di dimensioni. Tali oggetti sono definiti \textbf{array} e possono essere creati con il comando \texttt{array()} indicando il vettore di valori utilizzati per popolare l'oggetto e la grandezza di ciascuna delle sue dimensioni.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{array}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ , }\DataTypeTok{dim =}\NormalTok{ )}
\end{Highlighting}
\end{Shaded}

Ad esempio per creare un cubo di lato 3 contenete i valori interi dall'1 al 27 possiamo eseguire il seguente comando.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_cube <-}\StringTok{ }\KeywordTok{array}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{27}\NormalTok{, }\DataTypeTok{dim =} \KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{3}\NormalTok{,}\DecValTok{3}\NormalTok{))}
\NormalTok{my_cube}
\CommentTok{## , , 1}
\CommentTok{## }
\CommentTok{##      [,1] [,2] [,3]}
\CommentTok{## [1,]    1    4    7}
\CommentTok{## [2,]    2    5    8}
\CommentTok{## [3,]    3    6    9}
\CommentTok{## }
\CommentTok{## , , 2}
\CommentTok{## }
\CommentTok{##      [,1] [,2] [,3]}
\CommentTok{## [1,]   10   13   16}
\CommentTok{## [2,]   11   14   17}
\CommentTok{## [3,]   12   15   18}
\CommentTok{## }
\CommentTok{## , , 3}
\CommentTok{## }
\CommentTok{##      [,1] [,2] [,3]}
\CommentTok{## [1,]   19   22   25}
\CommentTok{## [2,]   20   23   26}
\CommentTok{## [3,]   21   24   27}
\end{Highlighting}
\end{Shaded}

Tutte le principali funzioni ed operazioni di selezione che abbiamo visto per le matrici ed i vettori posono essere eseguite in modo analogo anche con gli array. Il funzinonamento generale della selezione di elementi tramite parentesi quadre risulterà ora certamente pù chiaro. Per ogni dimensione vengono indicarti gli indici di posizioni desiderati. L'ordine all'interno delle parentesi quadre determina la specifica deimensione a cui ci si riferisce e le virgole sono utilizzate per separare gli indici delle diverse dimensioni.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_hypercube[}\OperatorTok{<}\NormalTok{dim}\DecValTok{-1}\OperatorTok{>}\NormalTok{, }\OperatorTok{<}\NormalTok{dim}\DecValTok{-2}\OperatorTok{>}\NormalTok{, }\OperatorTok{<}\NormalTok{dim}\DecValTok{-3}\OperatorTok{>}\NormalTok{, ..., }\OperatorTok{<}\NormalTok{dim}\OperatorTok{-}\NormalTok{n}\OperatorTok{>}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Vediamo ora alcuni semplici eempi di selezione.

\begin{verbatim}
## [1] 1
## [1] 1 2 3
##      [,1] [,2] [,3]
## [1,]    1    4    7
## [2,]    2    5    8
## [3,]    3    6    9
## , , 1
## 
##      [,1] [,2]
## [1,]    1    4
## [2,]    2    5
## 
## , , 2
## 
##      [,1] [,2]
## [1,]   10   13
## [2,]   11   14
\end{verbatim}

\begin{tip}[Array Mother of All Matrix]

E' facilmente intuibile come le matrici non siano altro che un caso speciale di array con 2 dimensioni. Infatti i più attenti avranno notato che il valore \texttt{"array"} compariva insieme a \texttt{"matrix"} nel valutare la tipologia di oggetto.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_matrix <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{12}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{2}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{2}\NormalTok{)}
\KeywordTok{is.array}\NormalTok{(my_matrix)}
\CommentTok{## [1] TRUE}
\KeywordTok{class}\NormalTok{(my_matrix)}
\CommentTok{## [1] "matrix" "array"}
\end{Highlighting}
\end{Shaded}

Tuttavia nota come un semplice vettore non sia un array. Ricordiamo infatti che un vettore non possiede una dimensione (\texttt{dim}) ma semplicemente una lunghezza (\texttt{length}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_vector <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{12}
\KeywordTok{is.array}\NormalTok{(my_vector)}
\CommentTok{## [1] FALSE}
\KeywordTok{dim}\NormalTok{(my_vector)}
\CommentTok{## NULL}
\end{Highlighting}
\end{Shaded}

\end{tip}

\hypertarget{dataframe}{%
\chapter{Dataframe}\label{dataframe}}

I \texttt{dataframe} sono uno degli oggetti più utilizzati in R per rappresentare i propri dati. In modo analogo alle matrici, i \texttt{dataframe} sono una struttura \textbf{bidimensionale} dove i dati sono disposti secondo righe e colonne. Può essere utile pensare al dataframe esattamente come ad una normale tabella che si può creare in un foglio di calcolo (e.g., Excel) dove possiamo inserire i nostri dati. Dati in questo caso è volutamente generico poichè i dataframe, a differenza delle matrici, possono contenere nello stesso oggetto tipi diversi di dati (e.g., \emph{nomi}, \emph{date} e \emph{numeri}).

La struttura di base di un dataframe è quindi la stessa di una matrice ma ci permette di includere diversi tipi di dati nello stesso oggetto come caratteri e valori numerici. Questo ci consente di raccogliere in un unico oggetto tutte le caratteristiche delle unità statistiche (variabili numeriche, categoriali, nominali etc.) che intendiamo successivamente analizzare. Un aspetto cruciale quindi è proprio quello che il dataframe è stato pensato per gestire dati complessi ed eterogenei come quelli che si trovano in un'analisi di dati reale. Se vi capiterà di utilizzare altri linguaggi di programmazione sopratutto mirati all'analisi dati (e.g., Matlab) noterete come vi mancherà un oggetto potente e intuitivo come il dataframe.

In genere in un dataframe le righe rappresentano le unità statitiche (ad esempio persone o osservazioni) e le colonne rappresentano variabili ovvero delle proprietà misurate su quelle unità statistiche. Esistono tuttavia due formati principali di dataframe a seconda del modo in cui vengono organizzati i dati. Abbiamo i dataframe in forma \textbf{wide} (oppure larga) oppure i dataframe in forma \textbf{long} (oppure lunga). Valutiamo la differenza tra i due formati ipotizzando dei dati dove per ogni soggetto abbiamo misuriamo l'età, il genere, e la risposta a tre item di un questionario.

\hypertarget{wide-dataframe}{%
\subsubsection*{Wide Dataframe}\label{wide-dataframe}}
\addcontentsline{toc}{subsubsection}{Wide Dataframe}

Nel formato \textbf{wide}, ogni singola riga del dataframe rappresenta un soggetto e ogni sua risposta o variabile misurata sarà riportata in una diversa colonna. In Tabelle \ref{tab:table-wide-db} vengono presentati i darti dell'esempio in un formato wide.

\begin{table}

\caption{\label{tab:table-wide-db}Dataframe nel formato wong}
\centering
\begin{tabular}[t]{c|c|c|c|c|c}
\hline
Id & age & gender & item\_1 & item\_2 & item\_3\\
\hline
subj\_1 & 21 & F & 2 & 0 & 2\\
\hline
subj\_2 & 23 & M & 1 & 2 & 0\\
\hline
subj\_3 & 19 & F & 1 & 1 & 1\\
\hline
\end{tabular}
\end{table}

Osserviamo come ogni soggetto si identificato da un codice riportato nella variabile \emph{Id} e le risposte ai tre item siano riportate in tre diverse variabili \emph{item\_1}, \emph{item\_2} e \emph{item\_3}.

\hypertarget{long-dataframe}{%
\subsubsection*{Long Dataframe}\label{long-dataframe}}
\addcontentsline{toc}{subsubsection}{Long Dataframe}

Nel formato \textbf{long}, ogni singola riga rappresenta una singola osservazione. Quindi i dati di ogni soggetto saranno riportati su più righe e le variabili che non cambiano tra le osservazioni saranno ripetute. In Tabelle \ref{tab:table-long-db} vengono presentati i darti dell'esempio in un formato lide.

\begin{table}

\caption{\label{tab:table-long-db}Dataframe nel formato long}
\centering
\begin{tabular}[t]{c|c|c|c|c}
\hline
Id & age & gender & item & response\\
\hline
subj\_1 & 21 & F & 1 & 2\\
\hline
subj\_1 & 21 & F & 2 & 1\\
\hline
subj\_1 & 21 & F & 3 & 1\\
\hline
subj\_2 & 23 & M & 1 & 0\\
\hline
subj\_2 & 23 & M & 2 & 2\\
\hline
subj\_2 & 23 & M & 3 & 1\\
\hline
subj\_3 & 19 & F & 1 & 2\\
\hline
subj\_3 & 19 & F & 2 & 0\\
\hline
subj\_3 & 19 & F & 3 & 1\\
\hline
\end{tabular}
\end{table}

Osserviamo come le risposte di ogni soggetto siano distribuite su più righe. Le caratterische che non variano vengono ripetute ad ogni riga (\emph{Id}, \emph{age} e \emph{gender}) mentre le risposte agli item vengono registrate utilizzando due colonne \emph{item}, ovvero il numero dell'item, e \emph{response} l'effettiva risposta di quel partecipante a quello specifico item.

\begin{tip}[Long o Wide?]

I dati in forma long e wide hanno delle proprietà diverse sopratutto in riferimento all'utilizzo. La tipologia di dato e il risultato finale è esattamente lo stesso tuttavia alcuni software o alcuni pacchetti di R funzionano solo con dataset organizzati in un certo modo.

Non c'è quindi un formato corretto o sbagliato ma dipende dal tipo di analisi e dal software o pacchetto che si utilizza. Alcune operazioni o analisi richiedono il dataset in forma \textbf{long} altre in forma \textbf{wide}.

Il consiglio però è di abituarsi il più possibile a ragionare in forma \textbf{long} perchè la maggior parte dei moderni pacchetti per l'analisi dati e per la creazione di grafici richiedono i dati in questo formato. Ci sono comunque delle funzioni (più avanzate) per passare velocemente da un formato all'altro.

\end{tip}

Nota come nei precedenti esempi abbiamo utilizzato sia colonne che contengono valori numerici numeri sia colonne con caratteri. Questo non era chiaramente possibile con le matrici. Ricorda tuttavia che, come per le matrici, anche i dataframe richiedono che tutte le colonne (variabili) abbiano lo stesso numero di elementi.

Vedremo ora come creare dei dataframe in R e come compiere le comuni operazini di selezione. Infine descriveremo alcune semplici manipolazioni e operazioni con i dataframe. Come vedremo ci sono molte somiglianze nell'utilizzo dei dataframe e delle matrici. Quando necessario, si farà riferimento al capitolo precedente per far notare aspetti in comune e differenze tra queste due strutture di dati.

\hypertarget{creazione-di-un-dataframe}{%
\section{Creazione di un dataframe}\label{creazione-di-un-dataframe}}

Il comando per creare un dataframe è \texttt{data.frame()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nome_df <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{variable1 =} \KeywordTok{c}\NormalTok{(...),}
  \DataTypeTok{variable2 =} \KeywordTok{c}\NormalTok{(...),}
\NormalTok{  ...)}
\end{Highlighting}
\end{Shaded}

La creazione è leggermente diversa rispetto al caso delle matrici. Intuitivamente è più facile immaginarla come l'unione di diverse colonne (dove una può contenere dei nomi, un'altra delle date e così via) piuttosto che un insieme di valori inseriti per riga o per colonna come per le matrici. Infatti per creare un \texttt{dataframe} è proprio necessario specificare le colonne una alla volta, indicando \texttt{nome\_colonna\ =\ valori} all'interno del comando \texttt{data.frame()}. Vediamo un esempio in R,

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_data <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{Id =} \KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{),}
  \DataTypeTok{names =} \KeywordTok{c}\NormalTok{(}\StringTok{"Alice"}\NormalTok{, }\StringTok{"Bruno"}\NormalTok{, }\StringTok{"Carla"}\NormalTok{, }\StringTok{"Diego"}\NormalTok{, }\StringTok{"Elisa"}\NormalTok{),}
  \DataTypeTok{gender =} \KeywordTok{factor}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"F"}\NormalTok{,}\StringTok{"M"}\NormalTok{,}\StringTok{"F"}\NormalTok{, }\StringTok{"M"}\NormalTok{, }\StringTok{"F"}\NormalTok{)),}
  \DataTypeTok{age =} \KeywordTok{c}\NormalTok{(}\DecValTok{22}\NormalTok{, }\DecValTok{25}\NormalTok{, }\DecValTok{23}\NormalTok{, }\DecValTok{22}\NormalTok{, }\DecValTok{24}\NormalTok{),}
  \DataTypeTok{faculty =} \KeywordTok{factor}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"Psicologia"}\NormalTok{, }\StringTok{"Ingegneria"}\NormalTok{, }\StringTok{"Medicina"}\NormalTok{, }\StringTok{"Lettere"}\NormalTok{, }\StringTok{"Psicologia"}\NormalTok{))}
\NormalTok{)}

\NormalTok{my_data}
\CommentTok{##   Id names gender age    faculty}
\CommentTok{## 1  1 Alice      F  22 Psicologia}
\CommentTok{## 2  2 Bruno      M  25 Ingegneria}
\CommentTok{## 3  3 Carla      F  23   Medicina}
\CommentTok{## 4  4 Diego      M  22    Lettere}
\CommentTok{## 5  5 Elisa      F  24 Psicologia}
\end{Highlighting}
\end{Shaded}

In questo caso abbiamo creato un ipotetico dataframe dove in ogni riga abbiamo un soggetto e ogni colonna rappresenta una data caratteristica del soggetto come il genere, l'età e così via.

\begin{tip}[ID]

E' sempre consigliato definire una colonna (e.g., \texttt{Id}) in cui assegnnare un idenificativo univoco ad ogni soggetto. Questo ci permetto di poterlo indentificare senza correre il rischio di compiere errori. Ad esempio l'utlizzo del nome (o anche nome e cognome) potrebbe non essere indicato poichè più persone potrebbero avere lo stesso nome e non saremo quindi in grado di discriminare i due soggetti.

\end{tip}

\begin{warning}[stringsAsFactors]

Una variabile di caratteri all'interno di un DataFrame è considerata di default come una semplice varibile nominale. E' possibile specificare l'argomento \texttt{stringsAsFactors\ =\ TRUE} per ottenere che tutte le variabili di caratteri siano considerate come delle variabili catgoriali creando automaticamente dei fattori (vedi Capitolo TODO).

Nota come il comportamento di default sia differente a seconda della versione di R. Versioni precedenti a R 4.0 avevano infatti come default \texttt{stringsAsFactors\ =\ TRUE} mentre dalla 4.0 in poi abbiamo \texttt{stringsAsFactors\ =\ FALSE}.

Presta quindi molta attenzione quando utilizzi codici e soluzioni scritte prima della versione 4.0.

\end{warning}

\hypertarget{esercizi-9}{%
\subsection*{Esercizi}\label{esercizi-9}}
\addcontentsline{toc}{subsection}{Esercizi}

Esegui i seguenti esercizi (\href{https://github.com/psicostat/Introduction2R/blob/master/exercises/chapter-10-dataframe.R}{soluzioni}):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Crea il dataframe \texttt{data\_wide} riportato in Tabella \ref{tab:table-wide-db}
\item
  Crea il dataframe \texttt{data\_long} riportato in Tabella \ref{tab:table-long-db}
\end{enumerate}

\hypertarget{sel-df}{%
\section{Selezione Elementi}\label{sel-df}}

Per selezionare uno o pù valori da un dataframe è possibile, in modo analogo alle matrici, utilizzare gli indici di riga e di colonna all'interno delle parentesi quadre:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nome_dataframe[}\OperatorTok{<}\NormalTok{indice}\OperatorTok{-}\NormalTok{riga}\OperatorTok{>}\NormalTok{, }\OperatorTok{<}\NormalTok{indice}\OperatorTok{-}\NormalTok{colonna}\OperatorTok{>}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Ricordiamo che l'ordine \texttt{{[}\textless{}indice-riga\textgreater{},\ \textless{}indice-colonna\textgreater{}{]}} è prestabilito e deve essere rispettato affinché la selezione avvenga correttamente. Possiamo quindi eseguire diverse tipologie di selezioni a seconda delle necessità ussanto le stesse procedure viste per le matrici. Ad esempio, riprendeno il dataframe \texttt{my\_data} creato precedentemente possiamo selezionare:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_data}
\CommentTok{##    Id    names gender age    faculty}
\CommentTok{## 1   1    Alice      F  22 Psicologia}
\CommentTok{## 2   2    Bruno      M  25 Ingegneria}
\CommentTok{## 3   3    Carla      F  23   Medicina}
\CommentTok{## 4   4    Diego      M  22    Lettere}
\CommentTok{## 5   5    Elisa      F  24 Psicologia}
\CommentTok{## 6   6 Fabrizio      M  35    Lettere}
\CommentTok{## 7   7   Gloria      F  26 Ingegneria}
\CommentTok{## 8   8   Herman      M  20 Psicologia}
\CommentTok{## 9   9    Irene      F  23 Statistica}
\CommentTok{## 10 10     Luca      M  22 Ingegneria}

\CommentTok{# Valore 3° riga e 2° colonna}
\NormalTok{my_data[}\DecValTok{3}\NormalTok{,}\DecValTok{4}\NormalTok{]}
\CommentTok{## [1] 23}

\CommentTok{# Tutte le variabili della 1° e 3° riga}
\NormalTok{my_data[}\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{3}\NormalTok{), ]}
\CommentTok{##   Id names gender age    faculty}
\CommentTok{## 2  2 Bruno      M  25 Ingegneria}
\CommentTok{## 3  3 Carla      F  23   Medicina}

\CommentTok{# Tutti i valori della 5° variabile}
\NormalTok{my_data[ , }\DecValTok{5}\NormalTok{]}
\CommentTok{##  [1] Psicologia Ingegneria Medicina   Lettere    Psicologia Lettere   }
\CommentTok{##  [7] Ingegneria Psicologia Statistica Ingegneria}
\CommentTok{## Levels: Ingegneria Lettere Medicina Psicologia Statistica}

\CommentTok{# I valori della 2° e 4° variabile per la 3° e 5° riga}
\NormalTok{my_data[}\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{5}\NormalTok{), }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{)]}
\CommentTok{##   names age}
\CommentTok{## 3 Carla  23}
\CommentTok{## 5 Elisa  24}
\end{Highlighting}
\end{Shaded}

Tuttavia, nell'utilizzo dei dataframe è più comune indicare i nomi delle variabili e le condizioni logico relazionali per selezionare i valori di interesse.

\hypertarget{selezione-colonne-con-nomi-delle-variabili}{%
\subsubsection*{Selezione Colonne con Nomi delle Variabili}\label{selezione-colonne-con-nomi-delle-variabili}}
\addcontentsline{toc}{subsubsection}{Selezione Colonne con Nomi delle Variabili}

Una granade differenza tra le matrici ed i dataframe sta nel poter accedere alle colonne utilizzando l'operatore \texttt{\$} ed indicando il loro nome attraverso la seguente sintassi:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nome_dataframe}\OperatorTok{$}\NormalTok{nome_variabile}
\end{Highlighting}
\end{Shaded}

In questo modo accediamo direttamente a quella specifica colonna senza utilizzare indici e parentesi quadre. Ad esempio:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Seleziono la variabile "names"}
\NormalTok{my_data}\OperatorTok{$}\NormalTok{names}
\CommentTok{##  [1] "Alice"    "Bruno"    "Carla"    "Diego"    "Elisa"    "Fabrizio"}
\CommentTok{##  [7] "Gloria"   "Herman"   "Irene"    "Luca"}

\CommentTok{# Seleziono la variabile "gender"}
\NormalTok{my_data}\OperatorTok{$}\NormalTok{faculty}
\CommentTok{##  [1] Psicologia Ingegneria Medicina   Lettere    Psicologia Lettere   }
\CommentTok{##  [7] Ingegneria Psicologia Statistica Ingegneria}
\CommentTok{## Levels: Ingegneria Lettere Medicina Psicologia Statistica}
\end{Highlighting}
\end{Shaded}

In alternativa è possibile utilizzare la normale procedura di selezione tramite parentesi quadre indicando al cposto degli indici di colonna i nomi delle variabili desiderate. Questo ci permette di selezionare anche più variabili contemporaneamente, ad esempio:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Seleziono solo la variabile "names"}
\NormalTok{my_data[ , }\StringTok{"names"}\NormalTok{]}
\CommentTok{##  [1] "Alice"    "Bruno"    "Carla"    "Diego"    "Elisa"    "Fabrizio"}
\CommentTok{##  [7] "Gloria"   "Herman"   "Irene"    "Luca"}

\CommentTok{# Seleziono la variabile "names", "gender" e "faculty"}
\NormalTok{my_data[, }\KeywordTok{c}\NormalTok{(}\StringTok{"names"}\NormalTok{, }\StringTok{"gender"}\NormalTok{, }\StringTok{"faculty"}\NormalTok{)]}
\CommentTok{##       names gender    faculty}
\CommentTok{## 1     Alice      F Psicologia}
\CommentTok{## 2     Bruno      M Ingegneria}
\CommentTok{## 3     Carla      F   Medicina}
\CommentTok{## 4     Diego      M    Lettere}
\CommentTok{## 5     Elisa      F Psicologia}
\CommentTok{## 6  Fabrizio      M    Lettere}
\CommentTok{## 7    Gloria      F Ingegneria}
\CommentTok{## 8    Herman      M Psicologia}
\CommentTok{## 9     Irene      F Statistica}
\CommentTok{## 10     Luca      M Ingegneria}
\end{Highlighting}
\end{Shaded}

Nota come i nomi delle variabili debbano essere forniti come delle stringhe.

\hypertarget{selezione-righe-con-condizioni-logiche}{%
\subsubsection*{Selezione Righe con Condizioni Logiche}\label{selezione-righe-con-condizioni-logiche}}
\addcontentsline{toc}{subsubsection}{Selezione Righe con Condizioni Logiche}

Avevamo visto precedentemete nel caso dei vettori e delle matrici come sia possibile costruire delle preposizioni logiche per selezionare solo i valori che rispettino una data condizione. Ora questa funzione si rivela particolarmente utile poichè ci permette di \emph{interrogare} il nostro dataframe in modo semplice ed intuitivo. Utilizzando una condizione logica possiamo, infatti, \emph{filtrare} le oservazioni che soddisfano una data condizione ed ottenere solo le informazioni di interesse.

Nella canonica sintassi \texttt{{[}\textless{}indice-riga\textgreater{},\ \textless{}indice-colonna\textgreater{}{]}}, gli indici di riga vengono sostituiti con una condizione logica che ci permette di filtrare le righe e al posto degli indici di colonna vengono indicati i nomi delle variabili di interesse. Utilizzeremo quindi la seguente sintassi:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nome_dataframe[}\OperatorTok{<}\NormalTok{condizione_logica_righe}\OperatorTok{>}\NormalTok{, }\OperatorTok{<}\NormalTok{nomi_variabili}\OperatorTok{>}\NormalTok{]}
\end{Highlighting}
\end{Shaded}

Vediamo ora degli esempi di selezione:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Tutti i dati di "Diego" (Id == 4)}
\NormalTok{my_data[my_data}\OperatorTok{$}\NormalTok{Id }\OperatorTok{==}\StringTok{ }\DecValTok{4}\NormalTok{, ]}
\CommentTok{##   Id names gender age faculty}
\CommentTok{## 4  4 Diego      M  22 Lettere}

\CommentTok{# Tutti i dai delle ragazze}
\NormalTok{my_data[my_data}\OperatorTok{$}\NormalTok{gender }\OperatorTok{==}\StringTok{ "F"}\NormalTok{, ]}
\CommentTok{##   Id  names gender age    faculty}
\CommentTok{## 1  1  Alice      F  22 Psicologia}
\CommentTok{## 3  3  Carla      F  23   Medicina}
\CommentTok{## 5  5  Elisa      F  24 Psicologia}
\CommentTok{## 7  7 Gloria      F  26 Ingegneria}
\CommentTok{## 9  9  Irene      F  23 Statistica}

\CommentTok{# Le facoltà dei soggeti con più di 24 anni}
\NormalTok{my_data[my_data}\OperatorTok{$}\NormalTok{age }\OperatorTok{>}\StringTok{ }\DecValTok{24}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\StringTok{"age"}\NormalTok{, }\StringTok{"faculty"}\NormalTok{)]}
\CommentTok{##   age    faculty}
\CommentTok{## 2  25 Ingegneria}
\CommentTok{## 6  35    Lettere}
\CommentTok{## 7  26 Ingegneria}
\end{Highlighting}
\end{Shaded}

Nota come, nel definire una condizione logica utilizzano le variabili dello stesso dataframe, sia comunque necessario indicare sempre anche il nome del dataframe. Nel caso precendente avremmo ottenuto un errore indicando semplicemente \texttt{age\ \textgreater{}\ 24} poichè così indichiamo l'oggetto \texttt{age} (che non esiste) e non la variabile \texttt{age} contenuta in \texttt{my\_data}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_data[age }\OperatorTok{>}\StringTok{ }\DecValTok{24}\NormalTok{, }\KeywordTok{c}\NormalTok{(}\StringTok{"age"}\NormalTok{, }\StringTok{"faculty"}\NormalTok{)]}
\CommentTok{## Error in `[.data.frame`(my_data, age > 24, c("age", "faculty")): object 'age' not found}
\end{Highlighting}
\end{Shaded}

In modo analogo a quanto visto con i vettori, utlizzando la condizione \texttt{my\_data\$age\ \textgreater{}\ 24} otteniamo un vettore di valori \texttt{TRUE} e \texttt{FALSE} a seconda che la condizione sia rispettata o meno.

Utilizzando gli operatori logici \textbf{AND}(\texttt{\&}) \textbf{OR}(\texttt{\textbar{}}) e \textbf{NOT}(\texttt{!}) possiamo combinare più operazioni logiche insieme per ottenere indicizzazioni più complesse, ma sempre intuitive dal punto di vista della scrittura. Ad esempio, per selezionare ``I soggetti tra i 20 e i 25 anni iscrittti a psicologia'' eseguiremo:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_data[my_data}\OperatorTok{$}\NormalTok{age }\OperatorTok{>=}\StringTok{ }\DecValTok{20} \OperatorTok{&}\StringTok{ }\NormalTok{my_data}\OperatorTok{$}\NormalTok{age }\OperatorTok{<=}\DecValTok{25} \OperatorTok{&}\StringTok{ }\NormalTok{my_data}\OperatorTok{$}\NormalTok{faculty }\OperatorTok{==}\StringTok{ "Psicologia"}\NormalTok{, ]}
\CommentTok{##   Id  names gender age    faculty}
\CommentTok{## 1  1  Alice      F  22 Psicologia}
\CommentTok{## 5  5  Elisa      F  24 Psicologia}
\CommentTok{## 8  8 Herman      M  20 Psicologia}
\end{Highlighting}
\end{Shaded}

Utilizzando questo metodo di indicizzazione possiamo apprezzare la vera potenza dei dataframe. Abbiamo, infatti, un metodo molto semplice ed intuitivo per lavorare con strutture di dati complesse formate da diverse tipologie di dati.

\begin{design}[Output Selezione]

Due aspetti importanti riguardanti il risultato di una selezione sono la tipologia di ouput ottenuto e come salvarla.

\hypertarget{tiplogia-output}{%
\subsubsection*{Tiplogia Output}\label{tiplogia-output}}
\addcontentsline{toc}{subsubsection}{Tiplogia Output}

In modo analogo alle matrici, i comandi di selezione non restituiscono sempre la stessa tipologia di oggetto. Infatti, quando selezioniamo una singola variabile otteniamo come risultato un vettore mentre selezionando due o più variabili oteniamo un dataframe.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Singola variabile}
\KeywordTok{class}\NormalTok{(my_data}\OperatorTok{$}\NormalTok{age)}
\CommentTok{## [1] "numeric"}

\CommentTok{# Più variabili}
\KeywordTok{class}\NormalTok{(my_data[ , }\KeywordTok{c}\NormalTok{(}\StringTok{"names"}\NormalTok{, }\StringTok{"age"}\NormalTok{)])}
\CommentTok{## [1] "data.frame"}
\end{Highlighting}
\end{Shaded}

\hypertarget{salvare-selezione}{%
\subsubsection*{Salvare Selezione}\label{salvare-selezione}}
\addcontentsline{toc}{subsubsection}{Salvare Selezione}

Come per tutte le altre tipologie di oggetti, le operazioni di selezione non modificano l'oggetto iniziale. Pertanto è necessario salvare il risultato della selezione se si desidera mantenere le modifiche. In questo caso, è cosigliabile creare un nuovo oggetto e non sovrascrivere l'oggetto iniziale poichè non ci permetterebbe di compiere nuove selezioni od operazioni su tutti i dati iniziali. E' buona norma quindi mantenere sempre un dataframe con la versione dei dati originali.

\end{design}

\hypertarget{utilizzi-avanzati-selezione-2}{%
\subsection{Utilizzi Avanzati Selezione}\label{utilizzi-avanzati-selezione-2}}

Vediamo ora alcuni utilizzi avanzati della selezione di elementi di un dataframe.

\hypertarget{modificare-gli-elementi-2}{%
\subsubsection*{Modificare gli Elementi}\label{modificare-gli-elementi-2}}
\addcontentsline{toc}{subsubsection}{Modificare gli Elementi}

In modo analogo agli altri oggetti, possiamo modificare dei valori selezionando il vecchio valore della matrice e utilizzo la funzione \texttt{\textless{}-} (o \texttt{=}) per assegnare il nuovo valore.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_data[}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, ]}
\CommentTok{##   Id names gender age    faculty}
\CommentTok{## 1  1 Alice      F  22 Psicologia}
\CommentTok{## 2  2 Bruno      M  25 Ingegneria}
\CommentTok{## 3  3 Carla      F  23   Medicina}
\CommentTok{## 4  4 Diego      M  22    Lettere}
\CommentTok{## 5  5 Elisa      F  24 Psicologia}

\CommentTok{# Sostituisco il nome "Diego" con "Davide"}
\NormalTok{my_data[}\DecValTok{4}\NormalTok{, }\StringTok{"names"}\NormalTok{] <-}\StringTok{ "Davide"}

\NormalTok{my_data[}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{]}
\CommentTok{##    Id    names gender age    faculty}
\CommentTok{## 1   1    Alice      F  22 Psicologia}
\CommentTok{## 2   2    Bruno      M  25 Ingegneria}
\CommentTok{## 3   3    Carla      F  23   Medicina}
\CommentTok{## 4   4   Davide      M  22    Lettere}
\CommentTok{## 5   5    Elisa      F  24 Psicologia}
\CommentTok{## 6   6 Fabrizio      M  35    Lettere}
\CommentTok{## 7   7   Gloria      F  26 Ingegneria}
\CommentTok{## 8   8   Herman      M  20 Psicologia}
\CommentTok{## 9   9    Irene      F  23 Statistica}
\CommentTok{## 10 10     Luca      M  22 Ingegneria}
\end{Highlighting}
\end{Shaded}

\hypertarget{eliminare-righe-o-colonne-1}{%
\subsubsection*{Eliminare Righe o Colonne}\label{eliminare-righe-o-colonne-1}}
\addcontentsline{toc}{subsubsection}{Eliminare Righe o Colonne}

In modo analogo agli altri oggetti, per \textbf{eliminare} delle righe (o delle colonne) da un dataframe, è necessario indicare all'interno delle parentesi quadre gli indici di riga (o di colonna) che si intende eliminare, preceduti dall'operatore \texttt{-} (\emph{meno}). Nel caso di più righe (o colone) è possibile indicare il meno solo prima del comando \texttt{c()}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Elimino le variabili "gender" e "age"}
\NormalTok{my_data[ , }\KeywordTok{c}\NormalTok{(}\StringTok{"gender"}\NormalTok{, }\StringTok{"age"}\NormalTok{)]}
\CommentTok{##    gender age}
\CommentTok{## 1       F  22}
\CommentTok{## 2       M  25}
\CommentTok{## 3       F  23}
\CommentTok{## 4       M  22}
\CommentTok{## 5       F  24}
\CommentTok{## 6       M  35}
\CommentTok{## 7       F  26}
\CommentTok{## 8       M  20}
\CommentTok{## 9       F  23}
\CommentTok{## 10      M  22}

\CommentTok{# Elimino le prime 5 osservazioni}
\NormalTok{my_data[}\OperatorTok{-}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{), ]}
\CommentTok{##    Id    names gender age    faculty}
\CommentTok{## 6   6 Fabrizio      M  35    Lettere}
\CommentTok{## 7   7   Gloria      F  26 Ingegneria}
\CommentTok{## 8   8   Herman      M  20 Psicologia}
\CommentTok{## 9   9    Irene      F  23 Statistica}
\CommentTok{## 10 10     Luca      M  22 Ingegneria}

\CommentTok{# Elimino le prime 5 osservazioni e la variabile "names"}
\NormalTok{my_data[}\OperatorTok{-}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{), }\DecValTok{-3}\NormalTok{]}
\CommentTok{##    Id    names age    faculty}
\CommentTok{## 6   6 Fabrizio  35    Lettere}
\CommentTok{## 7   7   Gloria  26 Ingegneria}
\CommentTok{## 8   8   Herman  20 Psicologia}
\CommentTok{## 9   9    Irene  23 Statistica}
\CommentTok{## 10 10     Luca  22 Ingegneria}
\end{Highlighting}
\end{Shaded}

E' possibile anche escludere (ed eliminare in un certo senso) delle informazioni usando gli operatori logici in gli operatori \textbf{NOT}(\texttt{!}) e diverso da (\texttt{!=}):

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Seleziono tutto tranne gli studenti di psicologia}

\CommentTok{# Modo 1 (valuto disuguaglianza)}
\NormalTok{my_data[my_data}\OperatorTok{$}\NormalTok{faculty }\OperatorTok{!=}\StringTok{ "Psicologia"}\NormalTok{, ]}
\CommentTok{##    Id    names gender age    faculty}
\CommentTok{## 2   2    Bruno      M  25 Ingegneria}
\CommentTok{## 3   3    Carla      F  23   Medicina}
\CommentTok{## 4   4   Davide      M  22    Lettere}
\CommentTok{## 6   6 Fabrizio      M  35    Lettere}
\CommentTok{## 7   7   Gloria      F  26 Ingegneria}
\CommentTok{## 9   9    Irene      F  23 Statistica}
\CommentTok{## 10 10     Luca      M  22 Ingegneria}

\CommentTok{# Modo 1 (nego l'uguaglianza)}
\NormalTok{my_data[}\OperatorTok{!}\NormalTok{my_data}\OperatorTok{$}\NormalTok{faculty }\OperatorTok{==}\StringTok{ "Psicologia"}\NormalTok{, ]}
\CommentTok{##    Id    names gender age    faculty}
\CommentTok{## 2   2    Bruno      M  25 Ingegneria}
\CommentTok{## 3   3    Carla      F  23   Medicina}
\CommentTok{## 4   4   Davide      M  22    Lettere}
\CommentTok{## 6   6 Fabrizio      M  35    Lettere}
\CommentTok{## 7   7   Gloria      F  26 Ingegneria}
\CommentTok{## 9   9    Irene      F  23 Statistica}
\CommentTok{## 10 10     Luca      M  22 Ingegneria}
\end{Highlighting}
\end{Shaded}

Nota come l'operazione di eliminazione sia comunque un'operazione di selezione. Pertanto è necessario salvare il risultato ottenuto se si desidera mantenere le modifiche.

\begin{warning}[Attenzione ad Esliminare]

L'utilizzo dell'operatore \texttt{-} è sempre in qualche modo pericoloso, sopratutto se l'oggetto che viene creato (o sovrascritto) viene poi utilizzato in altre operazioni. Eliminare delle informazioni, tranne quando è veramente necessario, non è mai una buona cosa. Se dovete selezionare una parte dei dati è sempre meglio creare un nuovo dataframe (o un nuovo oggetto in generale) e mantendere una versione di quello originale sempre disponibile.

\end{warning}

\hypertarget{esercizi-10}{%
\subsection*{Esercizi}\label{esercizi-10}}
\addcontentsline{toc}{subsection}{Esercizi}

Facendo riferimento ai dataframe \texttt{data\_long} e \texttt{data\_wide} precedentemente creati, esegui i seguenti esercizi (\href{https://github.com/psicostat/Introduction2R/blob/master/exercises/chapter-10-dataframe.R}{soluzioni}):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Utilizzando gli \textbf{indici numerici} di riga e di colonna seleziona i dati del soggetto \texttt{subj\_2} riguardanti le variabili \texttt{item} e \texttt{response} dal DataFrame \texttt{data\_long}.
\item
  Compi la stessa selezione dell'esercizio precedente usando però questa volta una condizione logica per gli indici di riga e indicando direttamente il nome delle variabili per gli indici di colonna.
\item
  Considerando il DataFrame \texttt{data\_wide} seleziona le variabili \texttt{Id} e \texttt{gender} dei soggetti che hanno risposto 1 alla variabile \texttt{item\_1}.
\item
  Considerando il DataFrame \texttt{data\_long} seleziona solamente i dati riguardanti le ragazze con etè superiore ai 20 anni.
\item
  Elimina dal DataFrame \texttt{data\_long} le osservazioni riguardanti il soggetto \texttt{subj\_2} e la variabile \texttt{"gender"}.
\end{enumerate}

\hypertarget{funzioni-ed-operazioni-1}{%
\section{Funzioni ed Operazioni}\label{funzioni-ed-operazioni-1}}

Vediamo ora alcune funzioni frequentemente usate e le comuni operazioni eseguite con i dataframe (vedi Tabella \ref{tab:table-df-functions}).

\begin{table}[!h]

\caption{\label{tab:table-df-functions}Funzioni e operazioni con dataframe}
\centering
\begin{tabular}[t]{l|l}
\hline
Funzione & Descrizione\\
\hline
\texttt{nrow(nome\_df)} & Numero di osservazioni del dataframe\\
\hline
\texttt{ncol(nome\_df)} & Numero di variabili del dataframe\\
\hline
\texttt{colnames(nome\_df)} & Nomi delle colonne del dataframe\\
\hline
\texttt{rownames(nome\_df)} & Nomi delle righe del dataframe\\
\hline
\texttt{nome\_df <- cbind(nome\_df, dati)} \\ \texttt{nome\_df\$nome\_var <- dati} & Aggiungi una nuova variabile al dataframe (deve avere lo stesso numero di righe)\\
\hline
\texttt{nome\_df <- rbind(nome\_df, dati)} & Aggiungi delle osservazioni (i nuovi dati devono essere coerenti con la struttura del dataframe)\\
\hline
\texttt{head(nome\_df)} & Prime righe del dataframe\\
\hline
\texttt{tail(nome\_df)} & Ultime righe del dataframe\\
\hline
\texttt{str(nome\_df)} & Struttura del dataframe\\
\hline
\texttt{summary(nome\_df)} & Summary del dataframe\\
\hline
\end{tabular}
\end{table}

Descriviamo ora nel dettaglio alcuni particolari utilizzi, considrando come esempio una versione ridotta del dataframe \texttt{my\_data} precedentemente creata.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data_short <-}\StringTok{ }\NormalTok{my_data[}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{, ]}
\NormalTok{data_short}
\CommentTok{##   Id  names gender age    faculty}
\CommentTok{## 1  1  Alice      F  22 Psicologia}
\CommentTok{## 2  2  Bruno      M  25 Ingegneria}
\CommentTok{## 3  3  Carla      F  23   Medicina}
\CommentTok{## 4  4 Davide      M  22    Lettere}
\CommentTok{## 5  5  Elisa      F  24 Psicologia}
\end{Highlighting}
\end{Shaded}

\hypertarget{attributi-di-un-dataframe}{%
\subsection{Attributi di un Dataframe}\label{attributi-di-un-dataframe}}

Abbiamo visto nel Capitolo TODO che gli oggetti in R possiedono quelli che sono definiti \emph{attibuti} ovvero delle utili informazioni riguardanti l'oggetto stesso, una sorta di \emph{metadata}. Vediamo ora, in modo analogo alle matrici, come valutare la dimensione di un dataframe e i nomi delle righe e delle colonne.

\hypertarget{dimensione-1}{%
\subsubsection*{Dimensione}\label{dimensione-1}}
\addcontentsline{toc}{subsubsection}{Dimensione}

Ricordiamo che un dataframe è un oggetto \textbf{bidimensionale} formato da righe e colonne. Per ottenere il numero di righe e di colonne di un dataframe, possiamo usare rispettivamente i comandi \texttt{nrow()} e \texttt{ncol()}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Numero di righe}
\KeywordTok{nrow}\NormalTok{(my_data)}
\CommentTok{## [1] 10}

\CommentTok{# Numero di colonne}
\KeywordTok{ncol}\NormalTok{(my_data)}
\CommentTok{## [1] 5}
\end{Highlighting}
\end{Shaded}

In alternativa, come per le matrici, è possibile usare la funzione \texttt{dim()}che restituisce un vettore con due valori dove il primo rappresenta il numero di righe e il secondo il numero di colonne.

\hypertarget{nomi-righe-e-colonne-1}{%
\subsubsection*{Nomi Righe e Colonne}\label{nomi-righe-e-colonne-1}}
\addcontentsline{toc}{subsubsection}{Nomi Righe e Colonne}

In modo simile alle matrici, è possibile accedere ai nomi delle righe e delle colonne utilizzando rispettivamente le funzioni \texttt{rownames()} e \texttt{colnames()}. Di default il dataframe richiede dei nomi solo alle colonne mentre il alle righe viene assegnato un nome in accordo con l'indice di riga. Tuttavia, è possibile anche nominare le righe con valori arbitrari sebbene sia una funzione raramente utilizzata.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Controllo i nomi attuali}
\KeywordTok{rownames}\NormalTok{(data_short)}
\CommentTok{## [1] "1" "2" "3" "4" "5"}
\KeywordTok{colnames}\NormalTok{(data_short)}
\CommentTok{## [1] "Id"      "names"   "gender"  "age"     "faculty"}
\end{Highlighting}
\end{Shaded}

Per impostare i nomi di righe e/o colonne, sarà quindi necessario assegnare a \texttt{rownames(nome\_dataframe)} e \texttt{colnames(nome\_dataframe)} un vettore di caratteri della stessa lunghezza della dimensione che stiamo rinominando.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Assegnamo i nomi alle righe}
\KeywordTok{rownames}\NormalTok{(data_short) <-}\StringTok{ }\KeywordTok{paste0}\NormalTok{(}\StringTok{"Subj_"}\NormalTok{, }\DecValTok{1}\OperatorTok{:}\KeywordTok{nrow}\NormalTok{(data_short))}

\CommentTok{# Assegno i nomi alle colonne}
\KeywordTok{colnames}\NormalTok{(data_short) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Id"}\NormalTok{, }\StringTok{"Nome"}\NormalTok{, }\StringTok{"Genere"}\NormalTok{, }\StringTok{"Eta"}\NormalTok{, }\StringTok{"Facolta"}\NormalTok{)}

\NormalTok{data_short}
\CommentTok{##        Id   Nome Genere Eta    Facolta}
\CommentTok{## Subj_1  1  Alice      F  22 Psicologia}
\CommentTok{## Subj_2  2  Bruno      M  25 Ingegneria}
\CommentTok{## Subj_3  3  Carla      F  23   Medicina}
\CommentTok{## Subj_4  4 Davide      M  22    Lettere}
\CommentTok{## Subj_5  5  Elisa      F  24 Psicologia}
\end{Highlighting}
\end{Shaded}

Infine, nota come la funzione \texttt{names()} nel caso dei dataframe sia analoga alla funzione \texttt{colnames()} e sia possibile usare il vaore \texttt{NULL} per eliminare ad esempio i nomi delle righe.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{names}\NormalTok{(data_short)}
\CommentTok{## [1] "Id"      "Nome"    "Genere"  "Eta"     "Facolta"}

\KeywordTok{rownames}\NormalTok{(data_short) <-}\StringTok{ }\OtherTok{NULL}
\NormalTok{data_short}
\CommentTok{##   Id   Nome Genere Eta    Facolta}
\CommentTok{## 1  1  Alice      F  22 Psicologia}
\CommentTok{## 2  2  Bruno      M  25 Ingegneria}
\CommentTok{## 3  3  Carla      F  23   Medicina}
\CommentTok{## 4  4 Davide      M  22    Lettere}
\CommentTok{## 5  5  Elisa      F  24 Psicologia}
\end{Highlighting}
\end{Shaded}

\hypertarget{unire-dataframe}{%
\subsection{Unire Dataframe}\label{unire-dataframe}}

In modo analogo alle matrici è possibile unire più dataframe utilizzando le funzioni \texttt{cbind()} e \texttt{rbind()} per cui valgono gli stesssi accorgimenti riguardanti la dimensione rispettivamente di righe e colonne. Tuttavia, nel caso dei dataframe è possibile creare una nuova colonna anche utilizzando l'operatore \texttt{\$}. Descriviamo ora in modo accurato i differenti utilizzi.

\hypertarget{dataframename---new_var}{%
\subsubsection*{\texorpdfstring{\texttt{dataframe\$name\ \textless{}-\ new\_var}}{dataframe\$name \textless- new\_var}}\label{dataframename---new_var}}
\addcontentsline{toc}{subsubsection}{\texttt{dataframe\$name\ \textless{}-\ new\_var}}

Con la scrittura \texttt{dataframe\$name\ \textless{}-\ new\_var} aggiungiamo al dataframe in oggetto una nuova colonna chiamata \texttt{name} che prende i valori all'interno di \texttt{new\_var}. Sarà necessario che la nuova variabile abbia lo stesso numero di valori delle righe del dataframe.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Aggiungiamo la colonna "media"}
\NormalTok{data_short}\OperatorTok{$}\NormalTok{Media <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\FloatTok{27.5}\NormalTok{, }\FloatTok{23.6}\NormalTok{, }\FloatTok{28.3}\NormalTok{, }\FloatTok{29.2}\NormalTok{, }\FloatTok{24.8}\NormalTok{)}

\CommentTok{# Equivalente a}
\NormalTok{media_voti <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\FloatTok{27.5}\NormalTok{, }\FloatTok{23.6}\NormalTok{, }\FloatTok{28.3}\NormalTok{, }\FloatTok{29.2}\NormalTok{, }\FloatTok{24.8}\NormalTok{)}
\NormalTok{data_short}\OperatorTok{$}\NormalTok{Media <-}\StringTok{ }\NormalTok{media_voti}

\NormalTok{data_short}
\CommentTok{##   Id   Nome Genere Eta    Facolta Media}
\CommentTok{## 1  1  Alice      F  22 Psicologia  27.5}
\CommentTok{## 2  2  Bruno      M  25 Ingegneria  23.6}
\CommentTok{## 3  3  Carla      F  23   Medicina  28.3}
\CommentTok{## 4  4 Davide      M  22    Lettere  29.2}
\CommentTok{## 5  5  Elisa      F  24 Psicologia  24.8}
\end{Highlighting}
\end{Shaded}

\hypertarget{cbind}{%
\subsubsection*{\texorpdfstring{\texttt{cbind()}}{cbind()}}\label{cbind}}
\addcontentsline{toc}{subsubsection}{\texttt{cbind()}}

Con la funzione \texttt{cbind()} possiamo aggiungere una o più variabili al nostro dataframe. Nota come a differenza dell'utilizzo dell'operatore \texttt{\$,}usando \texttt{cbind()} il risultato non venga automaticamente salvato ma sia necessario assegnare l'operazione ad un nuovo oggetto \texttt{dataframe\ \textless{}-\ cbind(dataframe,\ new\_var)}. In quest'ultimo caso il nome della colonna sarà \texttt{new\_var}. Se vogliamo anche rinominare la colonna possiamo usare la sintassi \texttt{cbind(dataframe,\ "nome"\ =\ new\_var)} oppure chiamare l'oggetto direttamente con il nome desiderato:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# aggiungo la variabile Numero_esami}
\NormalTok{numero_esami <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{12}\NormalTok{, }\DecValTok{14}\NormalTok{, }\DecValTok{13}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{8}\NormalTok{)}

\KeywordTok{cbind}\NormalTok{(data_short, numero_esami) }\CommentTok{# senza specificare il nome}
\CommentTok{##   Id   Nome Genere Eta    Facolta Media numero_esami}
\CommentTok{## 1  1  Alice      F  22 Psicologia  27.5           12}
\CommentTok{## 2  2  Bruno      M  25 Ingegneria  23.6           14}
\CommentTok{## 3  3  Carla      F  23   Medicina  28.3           13}
\CommentTok{## 4  4 Davide      M  22    Lettere  29.2           10}
\CommentTok{## 5  5  Elisa      F  24 Psicologia  24.8            8}

\KeywordTok{cbind}\NormalTok{(data_short, }\StringTok{"N_esami"}\NormalTok{ =}\StringTok{ }\NormalTok{numero_esami) }\CommentTok{# specificando anche il nome}
\CommentTok{##   Id   Nome Genere Eta    Facolta Media N_esami}
\CommentTok{## 1  1  Alice      F  22 Psicologia  27.5      12}
\CommentTok{## 2  2  Bruno      M  25 Ingegneria  23.6      14}
\CommentTok{## 3  3  Carla      F  23   Medicina  28.3      13}
\CommentTok{## 4  4 Davide      M  22    Lettere  29.2      10}
\CommentTok{## 5  5  Elisa      F  24 Psicologia  24.8       8}
\end{Highlighting}
\end{Shaded}

Anche in questo caso sarà necessario che le nuove variabili abbia lo stesso numero di valori delle righe del dataframe.

\hypertarget{rbind}{%
\subsubsection*{\texorpdfstring{\texttt{rbind()}}{rbind()}}\label{rbind}}
\addcontentsline{toc}{subsubsection}{\texttt{rbind()}}

Leggermente più complessa (e inusuale) è l'aggiunta di righe ad un dataframe. Al contrario della matrice che di base non aveva nomi per le colonne e solo numeri o stringhe come tipologia di dato, per combinare per riga due dataframe dobbiamo avere la stessa struttura. Ovvero:

\begin{itemize}
\tightlist
\item
  Lo stesso numero di colonne (come per le matrici)
\item
  Lo stesso nome delle colonne
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data_short}
\CommentTok{##   Id   Nome Genere Eta    Facolta Media}
\CommentTok{## 1  1  Alice      F  22 Psicologia  27.5}
\CommentTok{## 2  2  Bruno      M  25 Ingegneria  23.6}
\CommentTok{## 3  3  Carla      F  23   Medicina  28.3}
\CommentTok{## 4  4 Davide      M  22    Lettere  29.2}
\CommentTok{## 5  5  Elisa      F  24 Psicologia  24.8}

\CommentTok{# Nuovo dataset con le stesse colonne ma diverso nome}
\NormalTok{new_row <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{Id =} \DecValTok{6}\NormalTok{,}
  \DataTypeTok{Nome =} \StringTok{"Marta"}\NormalTok{,}
  \DataTypeTok{Sex =} \StringTok{"F"}\NormalTok{,      }\CommentTok{# Sex invece di Genere}
  \DataTypeTok{Eta =} \DecValTok{44}\NormalTok{,}
  \DataTypeTok{Facolta =} \StringTok{"Filosofia"}\NormalTok{,}
  \DataTypeTok{Media =} \FloatTok{28.7}
\NormalTok{)}

\NormalTok{new_row}
\CommentTok{##   Id  Nome Sex Eta   Facolta Media}
\CommentTok{## 1  6 Marta   F  44 Filosofia  28.7}

\KeywordTok{rbind}\NormalTok{(data_short, new_row) }\CommentTok{# Errore}
\CommentTok{## Error in match.names(clabs, names(xi)): names do not match previous names}

\CommentTok{# Nuovo dataset con le stesse colonne con il nome corretto}
\NormalTok{new_row <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{Id =} \DecValTok{6}\NormalTok{,}
  \DataTypeTok{Nome =} \StringTok{"Marta"}\NormalTok{,}
  \DataTypeTok{Genere =} \StringTok{"F"}\NormalTok{, }
  \DataTypeTok{Eta =} \DecValTok{44}\NormalTok{,}
  \DataTypeTok{Facolta =} \StringTok{"Filosofia"}\NormalTok{,}
  \DataTypeTok{Media =} \FloatTok{28.7}
\NormalTok{)}

\KeywordTok{rbind}\NormalTok{(data_short, new_row)}
\CommentTok{##   Id   Nome Genere Eta    Facolta Media}
\CommentTok{## 1  1  Alice      F  22 Psicologia  27.5}
\CommentTok{## 2  2  Bruno      M  25 Ingegneria  23.6}
\CommentTok{## 3  3  Carla      F  23   Medicina  28.3}
\CommentTok{## 4  4 Davide      M  22    Lettere  29.2}
\CommentTok{## 5  5  Elisa      F  24 Psicologia  24.8}
\CommentTok{## 6  6  Marta      F  44  Filosofia  28.7}
\end{Highlighting}
\end{Shaded}

Anche in questo caso sarà necessario salvare il risultato ottenuto per mantenere i cambiamenti.

\hypertarget{informazioni-dataframe}{%
\subsection{Informazioni Dataframe}\label{informazioni-dataframe}}

Vediamo infine alcune funzioni molto comuni usate per ottenere informazioni riassuntive riguardo ai dati contenuti in un dataframe:

\begin{itemize}
\tightlist
\item
  \texttt{head()} (o \texttt{tail()}) ci permete di visualizzare le prime (o le ulitme righe del nostro dataframe)
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{head}\NormalTok{(my_data)}
\CommentTok{##   Id    names gender age    faculty}
\CommentTok{## 1  1    Alice      F  22 Psicologia}
\CommentTok{## 2  2    Bruno      M  25 Ingegneria}
\CommentTok{## 3  3    Carla      F  23   Medicina}
\CommentTok{## 4  4   Davide      M  22    Lettere}
\CommentTok{## 5  5    Elisa      F  24 Psicologia}
\CommentTok{## 6  6 Fabrizio      M  35    Lettere}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{str()} ci permete di valutare la struttura del dataset ottenendo utili informazini quali in numero di osservazioni, il numero di variabili e la ipologia di variabili
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(my_data)}
\CommentTok{## 'data.frame':    10 obs. of  5 variables:}
\CommentTok{##  $ Id     : int  1 2 3 4 5 6 7 8 9 10}
\CommentTok{##  $ names  : chr  "Alice" "Bruno" "Carla" "Davide" ...}
\CommentTok{##  $ gender : Factor w/ 2 levels "F","M": 1 2 1 2 1 2 1 2 1 2}
\CommentTok{##  $ age    : num  22 25 23 22 24 35 26 20 23 22}
\CommentTok{##  $ faculty: Factor w/ 5 levels "Ingegneria","Lettere",..: 4 1 3 2 4 2 1 4 5 1}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{summary()} ci permete avere delle informazioni riassuntive delle variabili a seconda della loro tipologia
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{summary}\NormalTok{(my_data)}
\CommentTok{##        Id           names           gender      age              faculty }
\CommentTok{##  Min.   : 1.00   Length:10          F:5    Min.   :20.00   Ingegneria:3  }
\CommentTok{##  1st Qu.: 3.25   Class :character   M:5    1st Qu.:22.00   Lettere   :2  }
\CommentTok{##  Median : 5.50   Mode  :character          Median :23.00   Medicina  :1  }
\CommentTok{##  Mean   : 5.50                             Mean   :24.20   Psicologia:3  }
\CommentTok{##  3rd Qu.: 7.75                             3rd Qu.:24.75   Statistica:1  }
\CommentTok{##  Max.   :10.00                             Max.   :35.00}
\end{Highlighting}
\end{Shaded}

\hypertarget{esercizi-11}{%
\subsection*{Esercizi}\label{esercizi-11}}
\addcontentsline{toc}{subsection}{Esercizi}

Facendo riferimento ai dataframe \texttt{data\_long} e \texttt{data\_wide} (\href{https://github.com/psicostat/Introduction2R/blob/master/exercises/chapter-10-dataframe.R}{soluzioni}):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Aggiungi sia al DataFrame \texttt{data\_wide} che \texttt{data\_long} la variabile numerica \texttt{"memory\_pre"}.
\end{enumerate}

\begin{verbatim}
##       Id memory_pre
## 1 subj_1          3
## 2 subj_2          2
## 3 subj_3          1
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Aggiungi sia al DataFrame \texttt{data\_wide} che \texttt{data\_long} la variabile categoriale \texttt{"gruppo"}.
\end{enumerate}

\begin{verbatim}
##       Id      gruppo
## 1 subj_1 trattamento
## 2 subj_2 trattemento
## 3 subj_3   controllo
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Aggiungi al DataFrame \texttt{data\_wide} i dati del soggetto \texttt{subj\_4} e \texttt{subj\_5}.
\end{enumerate}

\begin{verbatim}
##       Id age gender item_1 item_2 item_3 memory_pre      gruppo
## 1 subj_4  25      F      1      0      2          1 trattemento
## 2 subj_5  22      M      1      1      0          3   controllo
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Considerando il DataFrame \texttt{datawide} calcola la variabile \texttt{"memory\_post"} data dalla somma degli item.
\item
  Considerando il DataFrame \texttt{data\_wide} cambia i nomi delle variabili \texttt{item\_1}, \texttt{item\_2} e \texttt{item\_3} rispettivamente in \texttt{problem\_1}, \texttt{problem\_2} e \texttt{problem\_3}.
\end{enumerate}

\hypertarget{list}{%
\chapter{Liste}\label{list}}

Le \textbf{liste} sono uno degli oggetti più versatili e utili in R. Possiamo pensare alle liste come a dei grandi raccoglitori di altri oggetti. La caratteristica principale delle liste è proprio questa, ovvero la capacità di contenere \textbf{tipologie diverse di oggetti} al loro interno come ad esempio vettori, dataframe, matrici e anche altre liste.

A differenza di dataframe e matrici dove gli elementi sono tra loro in relazione, gli elementi di una lista sono completamente indipendenti. Una \texttt{lista}, infatti, può contenere oggetti completamente diversi tra loro sia per tipologia che per dimensioni, senza che vi sia alcuna relazione o vincolo.

Un modo utile per immaginarsi una lista (vedi Figura \ref{fig:list-example}) è pensare ad un corridoio di un albergo dove ogni porta conduce ad una stanza diversa per caratteristiche, numero di elementi e così via. E' importante notare come gli elementi siano disposti in un preciso ordine e quindi possano essere identificati tramite il loro \textbf{indice di posizione}, in modo analogo a quanto visto con gli elementi di un vettore.

\begin{figure}

{\centering \includegraphics[width=0.3\linewidth,height=0.3\textheight]{images/list_example} 

}

\caption{Esempio concettuale di una lista}\label{fig:list-example}
\end{figure}

Da un punto di vista pratico la lista è un oggetto molto semplice, simile ad un vettore, e molte delle sue caratteristiche sono in comune con gli altri oggetti che abbiamo già affrontato. Tuttavia, la difficltà principale risiede nella sua indicizzazione poichè, data la loro grande versatilità, le strutture delle liste possono ragiungere notevoli livelli di complessità.

Vediamo ora come creare una lista e i diversi modi per sselezionare i suoi elementi. Come vedremo ci sono molte somiglianze nell'utilizzo dei dataframe e delle matrici. Quando necessario, si farà riferimento al capitolo precedente per far notare aspetti in comune e differenze tra queste due strutture di dati.

\hypertarget{creazione-di-liste}{%
\section{Creazione di Liste}\label{creazione-di-liste}}

Il comando per creare una lista è \texttt{list()}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nome_lista <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{nome_oggetto_1 =}\NormalTok{ oggetto_}\DecValTok{1}\NormalTok{,}
\NormalTok{  ...,}
  \DataTypeTok{nome_oggetto_n =}\NormalTok{ oggetto_n)}
\end{Highlighting}
\end{Shaded}

Nonostante il parametro \texttt{nome\_oggetto\_x} non sia necessario, come vedremo è assolutamente consigliato rinominare tutti gli elementi della lista per agevolare l'indicizzazione. Se non nominiamo gli elementi, infatti, questi saranno identificati solo tramite il loro indice di posizione, ovvero un numero progressivo \(1...n\) esattamente come nel caso dei vettori. Questo rende meno intutiva la successiva selezione degli elementi.

Quindi, se nel nostro workspace abbiamo degli oggetti diversi come una semplice \texttt{variabile}, un \texttt{vettore} e un \texttt{dataframe}, possiamo raccoglieere tutti questi elementi dentro un'unica lista. Ad esempio:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Una variabile}
\NormalTok{my_value <-}\StringTok{ "Prova"}

\CommentTok{# Un vettore}
\NormalTok{my_vector <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{, }\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{10}\NormalTok{)}

\CommentTok{# Un dataframe}
\NormalTok{my_data <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{id =} \DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{,}
                      \DataTypeTok{gender =} \KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"m"}\NormalTok{, }\StringTok{"f"}\NormalTok{), }\DataTypeTok{times =} \DecValTok{3}\NormalTok{),}
                      \DataTypeTok{y =} \DecValTok{1}\OperatorTok{:}\DecValTok{6}\NormalTok{)}

\CommentTok{# Creiamo la lista}
\NormalTok{my_list <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}\DataTypeTok{elemento_1 =}\NormalTok{ my_value,}
                \DataTypeTok{elemento_2 =}\NormalTok{ my_vector,}
                \DataTypeTok{elemento_3 =}\NormalTok{ my_data)}

\NormalTok{my_list}
\CommentTok{## $elemento_1}
\CommentTok{## [1] "Prova"}
\CommentTok{## }
\CommentTok{## $elemento_2}
\CommentTok{## [1]  1  3  5  6 10}
\CommentTok{## }
\CommentTok{## $elemento_3}
\CommentTok{##   id gender y}
\CommentTok{## 1  1      m 1}
\CommentTok{## 2  2      f 2}
\CommentTok{## 3  3      m 3}
\CommentTok{## 4  4      f 4}
\CommentTok{## 5  5      m 5}
\CommentTok{## 6  6      f 6}
\end{Highlighting}
\end{Shaded}

\hypertarget{esercizi-12}{%
\subsection*{Esercizi}\label{esercizi-12}}
\addcontentsline{toc}{subsection}{Esercizi}

Considerando gli oggetti creati nei precedenti capitoli, esegui i seguenti esercizi (\href{https://github.com/psicostat/Introduction2R/blob/master/exercises/chapter-11-lists.R}{soluzioni}):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Crea la lista \texttt{esperimento\_1} contenente:

  \begin{itemize}
  \tightlist
  \item
    DataFrame \texttt{data\_wide}
  \item
    la matrice \texttt{A}
  \item
    il vettore \texttt{x}
  \item
    la variabile \texttt{info\ =\ "Prima\ raccolta\ dati"}
  \end{itemize}
\item
  Crea la lista \texttt{esperimento\_2} contenente:

  \begin{itemize}
  \tightlist
  \item
    DataFrame \texttt{data\_long}
  \item
    la matrice \texttt{C}
  \item
    il vettore \texttt{y}
  \item
    la variabile \texttt{info\ =\ "Seconda\ raccolta\ dati"}
  \end{itemize}
\end{enumerate}

\hypertarget{selezione-elementi-1}{%
\section{Selezione Elementi}\label{selezione-elementi-1}}

Come dicevamo in precedenza, ogni elemento di una lista possiende il suo \textbf{indice di posizione}, ovvero un valore numerico progressivo in modo del tutto analogo a quanto visto per gli elementi di un vettore. Tuttavia, c'è un'importante differenza per quanto riguarda la modalità di selezione in base al tipo di oggetto che si vuole ottenere come risultato. Infatti, mentre con i vettori usavamo le singole parentesi quadre \texttt{my\_vector{[}i{]}} per accedere direttamente all'elemento alla posizione \(i\), con le liste abbiamo due alternative:

\begin{itemize}
\tightlist
\item
  \texttt{my\_list{[}i{]}} - utilizzando le \textbf{singole parentesi quadre} (\texttt{{[}i{]}}) otteniamo come risultato un oggetto di tipo lista con all'interno l'elemento alla posizione \(i\). Questo non ci permette, tuttavia, di accedere direttamente ai suoi valori.
\item
  \texttt{my\_list{[}{[}i{]}{]}} - utilizzando le \textbf{doppie parentesi quadre} (\texttt{{[}{[}i{]}{]}}) estraiamo dalla lista l'elemento alla posizione \(i\) e come risultato otteniamo l'oggetto stesso. Questo ci permette quindi di accedere direttamente ai suoi valori.
\end{itemize}

Vediamo la differenza nel seguente esempio:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_list}
\CommentTok{## $elemento_1}
\CommentTok{## [1] "Prova"}
\CommentTok{## }
\CommentTok{## $elemento_2}
\CommentTok{## [1]  1  3  5  6 10}
\CommentTok{## }
\CommentTok{## $elemento_3}
\CommentTok{##   id gender y}
\CommentTok{## 1  1      m 1}
\CommentTok{## 2  2      f 2}
\CommentTok{## 3  3      m 3}
\CommentTok{## 4  4      f 4}
\CommentTok{## 5  5      m 5}
\CommentTok{## 6  6      f 6}

\CommentTok{# Indicizzazione [ ]}
\NormalTok{my_list[}\DecValTok{2}\NormalTok{]}
\CommentTok{## $elemento_2}
\CommentTok{## [1]  1  3  5  6 10}
\KeywordTok{class}\NormalTok{(my_list[}\DecValTok{2}\NormalTok{]) }\CommentTok{# una lista}
\CommentTok{## [1] "list"}

\CommentTok{# Indicizzazione [[]]}
\NormalTok{my_list[[}\DecValTok{2}\NormalTok{]]}
\CommentTok{## [1]  1  3  5  6 10}
\KeywordTok{class}\NormalTok{(my_list[[}\DecValTok{2}\NormalTok{]]) }\CommentTok{# un vettore}
\CommentTok{## [1] "numeric"}
\end{Highlighting}
\end{Shaded}

Questa differenza nel risultato ottenuto usando le \textbf{singole parentesi quadre} (\texttt{{[}\ {]}}) o le \textbf{doppie parentesi quadre} (\texttt{{[}{[}\ {]}{]}}) è molto importante perché influirà sulle successive operazioni che potremmo compiere. Ricordiamo che nel primo caso (\texttt{{[}\ {]}}) ottenimo una lista con i soli elementi selezionati, mentre nel secondo caso (\texttt{{[}{[}\ {]}{]}}) accediamo direttamente all'oggetto selezionato.

Questa distinzione diventa chiara applicando una funzione generica allo stesso elemento indicizzato in modo diverso oppure usando la funzione \texttt{str()} per capire la struttura. Vediamo come solo accedendo direttamente all'elemento possiamo eseguire le normali operazioni, mentre, indicizzando con una sola parentesi, l'oggetto ottenuto è una lista con un singolo elemento.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Applichiamo la media al vettore `elemento_2` indicizzato con 1 o 2 parentesi}
\KeywordTok{mean}\NormalTok{(my_list[}\DecValTok{2}\NormalTok{])}
\CommentTok{## Warning in mean.default(my_list[2]): argument is not numeric or logical:}
\CommentTok{## returning NA}
\CommentTok{## [1] NA}
\KeywordTok{mean}\NormalTok{(my_list[[}\DecValTok{2}\NormalTok{]])}
\CommentTok{## [1] 5}

\CommentTok{# Vediamo la struttura}
\KeywordTok{str}\NormalTok{(my_list[}\DecValTok{2}\NormalTok{])}
\CommentTok{## List of 1}
\CommentTok{##  $ elemento_2: num [1:5] 1 3 5 6 10}
\KeywordTok{str}\NormalTok{(my_list[[}\DecValTok{2}\NormalTok{]])}
\CommentTok{##  num [1:5] 1 3 5 6 10}
\end{Highlighting}
\end{Shaded}

\begin{design}[{[ ] vs [[ ]]}]

Il diverso tipo di selezione ottenuto con l'utilizzo delle singole o doppie parentesi quadre è definito nel seguente modo:

\begin{itemize}
\tightlist
\item
  \textbf{singole parentesi quadre} (\texttt{{[}\ {]}}) - restituisce un oggetto della stessa classe (i.e., tipologia) dell'oggetto iniziale
\item
  \textbf{doppie parentesi quadre} (\texttt{{[}{[}\ {]}{]}}) - estrae un elemento dall'oggetto iniziale restituendo un oggetto non necessariamente della stessa classe (i.e., tipologia)
\end{itemize}

Vediamo quindi come sia possibile utilizzare le doppie parentesi anche con i vettori e i dataframe ma in questo caso il risultato non differeisce dalla normale procedura di selezione.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Vettori}
\NormalTok{my_vector[}\DecValTok{2}\NormalTok{]}
\CommentTok{## [1] 3}
\NormalTok{my_vector[[}\DecValTok{2}\NormalTok{]]}
\CommentTok{## [1] 3}

\CommentTok{# Dataframe}
\NormalTok{my_data[, }\DecValTok{2}\NormalTok{]}
\CommentTok{## [1] "m" "f" "m" "f" "m" "f"}
\NormalTok{my_data[[}\DecValTok{2}\NormalTok{]] }\CommentTok{# la selezione è posibile solo sulle colonne}
\CommentTok{## [1] "m" "f" "m" "f" "m" "f"}
\end{Highlighting}
\end{Shaded}

Nota infine come l'uso di singole parentesi quadre (\texttt{{[}\ {]}}) permette di selezionare più elementi contemporaneamente, mentre le doppie parentesi quadre (\texttt{{[}{[}\ {]}{]}}) permettono di estrarre solo un elemento alla volta

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_list[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{)]}
\CommentTok{## $elemento_1}
\CommentTok{## [1] "Prova"}
\CommentTok{## }
\CommentTok{## $elemento_2}
\CommentTok{## [1]  1  3  5  6 10}

\NormalTok{my_list[[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{)]]}
\CommentTok{## Error in my_list[[c(1, 2)]]: subscript out of bounds}
\end{Highlighting}
\end{Shaded}

\end{design}

\hypertarget{selezione-operatore}{%
\subsubsection*{\texorpdfstring{Selezione Operatore \texttt{\$}}{Selezione Operatore \$}}\label{selezione-operatore}}
\addcontentsline{toc}{subsubsection}{Selezione Operatore \texttt{\$}}

In alternativa all'uso delle \textbf{doppie parentesi quadre} (\texttt{{[}{[}\ {]}{]}}) è possibile, in modo analogo ai dataframe, accedere agli elementi di una lista utilizzando l'operatore \texttt{\$} ed indicando il loro nome:

\begin{itemize}
\tightlist
\item
  \texttt{my\_list\$nome\_elemento} - l'operatore \texttt{\$} ci permette di accedere direttamente all'oggetto desiderato.
\end{itemize}

Vediamo alcuni esempi riprendendo la lista \texttt{my\_list} create precedentemente.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Selezionare "elemento_1"}
\NormalTok{my_list}\OperatorTok{$}\NormalTok{elemento_}\DecValTok{1}
\CommentTok{## [1] "Prova"}

\CommentTok{# Selezionare "elemento_3"}
\NormalTok{my_list}\OperatorTok{$}\NormalTok{elemento_}\DecValTok{3}
\CommentTok{##   id gender y}
\CommentTok{## 1  1      m 1}
\CommentTok{## 2  2      f 2}
\CommentTok{## 3  3      m 3}
\CommentTok{## 4  4      f 4}
\CommentTok{## 5  5      m 5}
\CommentTok{## 6  6      f 6}
\end{Highlighting}
\end{Shaded}

Nota come il nome degli elementi possa essere usato anche con le parentesi quadre.

\begin{verbatim}
## $elemento_1
## [1] "Prova"
## 
## $elemento_2
## [1]  1  3  5  6 10
\end{verbatim}

\hypertarget{utilizzo-elementi-e-successive-selezioni}{%
\subsubsection*{Utilizzo Elementi e Successive Selezioni}\label{utilizzo-elementi-e-successive-selezioni}}
\addcontentsline{toc}{subsubsection}{Utilizzo Elementi e Successive Selezioni}

Una volta che abbiamo estratto un elemento da una lista, è possibile utilizzare l'oggetto nel modo che preferiamo. Possiamo sia assegnare l'elemento ad nuovo oggetto da utilizzare successvamente, oppure eseguire le funzioni o altre operazioni generiche direttamente sul comando della selezione.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Media dei valori dell' "elemento_2"}

\CommentTok{# Assegno l'oggetto}
\NormalTok{my_values <-}\StringTok{ }\NormalTok{my_list}\OperatorTok{$}\NormalTok{elemento_}\DecValTok{2}
\KeywordTok{mean}\NormalTok{(my_values)}
\CommentTok{## [1] 5}

\CommentTok{# Calcolo direttamente}
\KeywordTok{mean}\NormalTok{(my_list}\OperatorTok{$}\NormalTok{elemento_}\DecValTok{2}\NormalTok{)}
\CommentTok{## [1] 5}
\end{Highlighting}
\end{Shaded}

Chiaramente le operazione che possiamo svolgere, come ad esempio ulteriori selezioni, dipendono dalla specifica tipologia e struttura dell'oggetto selezionato.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# ---- Seleziono il primo valore dell'oggetto "elemento_2" ----}

\NormalTok{my_list}\OperatorTok{$}\NormalTok{elemento_}\DecValTok{2}
\CommentTok{## [1]  1  3  5  6 10}

\NormalTok{my_list}\OperatorTok{$}\NormalTok{elemento_}\DecValTok{2}\NormalTok{[}\DecValTok{1}\NormalTok{]}
\CommentTok{## [1] 1}
\NormalTok{my_list[[}\DecValTok{2}\NormalTok{]][}\DecValTok{1}\NormalTok{] }\CommentTok{# equivalente a alla precedente}
\CommentTok{## [1] 1}

\CommentTok{#---- Seleziono la colonna "gender" dell'oggetto "elemento_3" ----}

\NormalTok{my_list}\OperatorTok{$}\NormalTok{elemento_}\DecValTok{3}\OperatorTok{$}\NormalTok{gender}
\CommentTok{## [1] "m" "f" "m" "f" "m" "f"}

\CommentTok{# Altre scritture equivalenti}
\NormalTok{my_list[[}\DecValTok{3}\NormalTok{]]}\OperatorTok{$}\NormalTok{gender}
\CommentTok{## [1] "m" "f" "m" "f" "m" "f"}
\NormalTok{my_list[[}\DecValTok{3}\NormalTok{]][, }\DecValTok{2}\NormalTok{]}
\CommentTok{## [1] "m" "f" "m" "f" "m" "f"}
\NormalTok{my_list[[}\DecValTok{3}\NormalTok{]][, }\StringTok{"gender"}\NormalTok{]}
\CommentTok{## [1] "m" "f" "m" "f" "m" "f"}
\end{Highlighting}
\end{Shaded}

\hypertarget{utilizzi-avanzati-selezione-3}{%
\subsection{Utilizzi Avanzati Selezione}\label{utilizzi-avanzati-selezione-3}}

Vediamo ora alcuni utilizzi avanzati della selezione di elementi di un dataframe.

\hypertarget{modificare-gli-elementi-3}{%
\subsubsection*{Modificare gli Elementi}\label{modificare-gli-elementi-3}}
\addcontentsline{toc}{subsubsection}{Modificare gli Elementi}

In modo analogo agli altri oggetti, possiamo modificare dei valori selezionando il vecchio elemento della lista e utilizzo la funzione \texttt{\textless{}-} (o \texttt{=}) per assegnare il nuovo elemento. Nota come in questo caso sia possibile uttilizzare sia le singole parentesi quadre (\texttt{{[}\ {]}}) che le doppie parentesi quadre (\texttt{{[}{[}\ {]}{]}}).

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_list}
\CommentTok{## $elemento_1}
\CommentTok{## [1] "Prova"}
\CommentTok{## }
\CommentTok{## $elemento_2}
\CommentTok{## [1]  1  3  5  6 10}
\CommentTok{## }
\CommentTok{## $elemento_3}
\CommentTok{##   id gender y}
\CommentTok{## 1  1      m 1}
\CommentTok{## 2  2      f 2}
\CommentTok{## 3  3      m 3}
\CommentTok{## 4  4      f 4}
\CommentTok{## 5  5      m 5}
\CommentTok{## 6  6      f 6}

\CommentTok{# sostituiamo il primo elemento}
\NormalTok{my_list[}\DecValTok{1}\NormalTok{] <-}\StringTok{ "Un nuovo elemento"}

\CommentTok{# sostituiamo il secondo elemento}
\NormalTok{my_list[[}\DecValTok{2}\NormalTok{]] <-}\StringTok{ "Un altro nuovo elemento"}

\NormalTok{my_list}
\CommentTok{## $elemento_1}
\CommentTok{## [1] "Un nuovo elemento"}
\CommentTok{## }
\CommentTok{## $elemento_2}
\CommentTok{## [1] "Un altro nuovo elemento"}
\CommentTok{## }
\CommentTok{## $elemento_3}
\CommentTok{##   id gender y}
\CommentTok{## 1  1      m 1}
\CommentTok{## 2  2      f 2}
\CommentTok{## 3  3      m 3}
\CommentTok{## 4  4      f 4}
\CommentTok{## 5  5      m 5}
\CommentTok{## 6  6      f 6}
\end{Highlighting}
\end{Shaded}

\hypertarget{eliminare-elementi}{%
\subsubsection*{Eliminare Elementi}\label{eliminare-elementi}}
\addcontentsline{toc}{subsubsection}{Eliminare Elementi}

In modo analogo agli altri oggetti, per \textbf{eliminare} degli elementi da una lista, è necessario indicare all'interno delle parentesi quadre gli indici di posizione degli elementi che si intende eliminare, preceduti dall'operatore \texttt{-} (\emph{meno}). In questo caso è necessario l'utilizzo delle singole parentesi quadre (\texttt{{[}\ {]}}).

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Elimino il secondo elemento}
\NormalTok{my_list[}\OperatorTok{-}\DecValTok{2}\NormalTok{]}
\CommentTok{## $elemento_1}
\CommentTok{## [1] "Un nuovo elemento"}
\CommentTok{## }
\CommentTok{## $elemento_3}
\CommentTok{##   id gender y}
\CommentTok{## 1  1      m 1}
\CommentTok{## 2  2      f 2}
\CommentTok{## 3  3      m 3}
\CommentTok{## 4  4      f 4}
\CommentTok{## 5  5      m 5}
\CommentTok{## 6  6      f 6}
\end{Highlighting}
\end{Shaded}

Ricorda come l'operazione di eliminazione sia comunque un'operazione di selezione. Pertanto è necessario salvare il risultato ottenuto se si desidera mantenere le modifiche.

\hypertarget{esercizi-13}{%
\subsection*{Esercizi}\label{esercizi-13}}
\addcontentsline{toc}{subsection}{Esercizi}

Esegui i seguenti esercizi (\href{https://github.com/psicostat/Introduction2R/blob/master/exercises/chapter-11-lists.R}{soluzioni})

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Utilizzando gli \textbf{indici numerici} di posizione selziona i dati dei soggetti \texttt{subj\_1} e \texttt{subj\_4} riguardanti le variabili \texttt{age},\texttt{gender} e \texttt{gruppo} dal DataFrame \texttt{data\_wide} contenuto nella lista \texttt{esperimento\_1}.
\item
  Compi la stessa selezione dell'esercizio precedente usando però questa volta il nome dell'oggetto per selezionare il DateFrame dalla lista.
\item
  Considerando la lista \texttt{esperimento\_2} seleziona gli oggetti \texttt{data\_long}, \texttt{y} e \texttt{info}
\item
  Cambia i nomi degli oggetti contenuti nella lista \texttt{esperimento\_2} rispettivamente in \texttt{"dati\_esperimento"}, \texttt{"matrice\_VCV"}, \texttt{"codici\_Id"} e \texttt{"note"}
\end{enumerate}

\hypertarget{funzioni-ed-operazioni-2}{%
\section{Funzioni ed Operazioni}\label{funzioni-ed-operazioni-2}}

Vediamo ora alcune funzioni frequentemente usate e le comuni operazioni eseguite con le liste (vedi Tabella \ref{tab:table-list-functions}).

\begin{table}[!h]

\caption{\label{tab:table-list-functions}Funzioni ed operazioni con liste}
\centering
\begin{tabular}[t]{l|l}
\hline
Funzione & Descrizione\\
\hline
\texttt{length(nome\_df)} & Numero di elementi nella lista\\
\hline
\texttt{names(nome\_df)} & Nomi degli elementi della lista\\
\hline
\texttt{nome\_list\$nome\_obj <- oggetto} & Aggiungi un nuovo elemento alla lista\\
\hline
\texttt{c(nome\_df)} & Unire più liste\\
\hline
\texttt{unlist(nome\_df)} & Ottieni un vettori di tutti gli elementi\\
\hline
\texttt{str(nome\_df)} & Struttura del dataframe\\
\hline
\texttt{summary(nome\_df)} & Summary del dataframe\\
\hline
\end{tabular}
\end{table}

Descriviamo ora nel dettaglio alcuni particolari utilizzi, considrando come esempio la lista \texttt{my\_list} qui definita. Nota che i nomi degli elemnti sono stati omessi volutamente.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{my_list <-}\StringTok{ }\KeywordTok{list}\NormalTok{(my_value,}
\NormalTok{                my_vector,}
\NormalTok{                my_data)}
\end{Highlighting}
\end{Shaded}

\hypertarget{attributi-di-una-lista}{%
\subsection{Attributi di una Lista}\label{attributi-di-una-lista}}

Anche le liste come gli altri oggetti, hanno degli \emph{attibuti} ovvero delle utili informazioni riguardanti l'oggetto stesso. Vediamo ora come valutare la dimensione di una lista e i nomi dei suoi elementi.

\hypertarget{dimensione-2}{%
\subsubsection*{Dimensione}\label{dimensione-2}}
\addcontentsline{toc}{subsubsection}{Dimensione}

Per valutare la dimensione di una lista, ovvero il numero di elementi che contiene, possiamo utilizzare la funzione \texttt{length()}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Numero elementi}
\KeywordTok{length}\NormalTok{(my_list)}
\CommentTok{## [1] 3}
\end{Highlighting}
\end{Shaded}

\hypertarget{nomi-elementi}{%
\subsubsection*{Nomi Elementi}\label{nomi-elementi}}
\addcontentsline{toc}{subsubsection}{Nomi Elementi}

Per accedere ai nomi degli elementi di una lista, è possibile utilizzare la funzione \texttt{names()}. Se i nomi non sono stati specificati al momento della creazione, otterremo il valore \texttt{NULL}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Controllo i nomi attuali}
\KeywordTok{names}\NormalTok{(my_list)}
\CommentTok{## NULL}
\end{Highlighting}
\end{Shaded}

Per impostare i nomi degli elementi, sarà quindi necessario assegnare a \texttt{names(my\_list)} un vettore di caratteri con i nomi di ciascun elemento.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Assegnamo i nomi}
\KeywordTok{names}\NormalTok{(my_list) <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"Variabile"}\NormalTok{, }\StringTok{"Vettore"}\NormalTok{, }\StringTok{"Dataframe"}\NormalTok{)}

\NormalTok{my_list}
\CommentTok{## $Variabile}
\CommentTok{## [1] "Prova"}
\CommentTok{## }
\CommentTok{## $Vettore}
\CommentTok{## [1]  1  3  5  6 10}
\CommentTok{## }
\CommentTok{## $Dataframe}
\CommentTok{##   id gender y}
\CommentTok{## 1  1      m 1}
\CommentTok{## 2  2      f 2}
\CommentTok{## 3  3      m 3}
\CommentTok{## 4  4      f 4}
\CommentTok{## 5  5      m 5}
\CommentTok{## 6  6      f 6}
\end{Highlighting}
\end{Shaded}

\hypertarget{unire-liste}{%
\subsection{Unire Liste}\label{unire-liste}}

Per aggiungere elementi ad una lista è possibile sia creare un nuovo elemento con l'operatore \texttt{\$}, in modo annalogo ai datafame, sia combinare più liste con la funzione \texttt{c()}.

\hypertarget{my_listname---new_obj}{%
\subsubsection*{\texorpdfstring{\texttt{my\_list\$name\ \textless{}-\ new\_obj}}{my\_list\$name \textless- new\_obj}}\label{my_listname---new_obj}}
\addcontentsline{toc}{subsubsection}{\texttt{my\_list\$name\ \textless{}-\ new\_obj}}

Con la scrittura \texttt{my\_list\$name\ \textless{}-\ new\_obj} aggiungiamo alla lista in oggetto un nuovo elemento di cui dobbiamo specificare il nome e gli assegnamo l'oggetto \texttt{new\_obj}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Aggiungiamo un nuovo elemento}
\NormalTok{my_list}\OperatorTok{$}\NormalTok{new_obj <-}\StringTok{ "Un nuovo elemento"}

\NormalTok{my_list}
\CommentTok{## $Variabile}
\CommentTok{## [1] "Prova"}
\CommentTok{## }
\CommentTok{## $Vettore}
\CommentTok{## [1]  1  3  5  6 10}
\CommentTok{## }
\CommentTok{## $Dataframe}
\CommentTok{##   id gender y}
\CommentTok{## 1  1      m 1}
\CommentTok{## 2  2      f 2}
\CommentTok{## 3  3      m 3}
\CommentTok{## 4  4      f 4}
\CommentTok{## 5  5      m 5}
\CommentTok{## 6  6      f 6}
\CommentTok{## }
\CommentTok{## $new_obj}
\CommentTok{## [1] "Un nuovo elemento"}
\end{Highlighting}
\end{Shaded}

\hypertarget{c}{%
\subsubsection*{\texorpdfstring{\texttt{c()}}{c()}}\label{c}}
\addcontentsline{toc}{subsubsection}{\texttt{c()}}

Con la funzione \texttt{c()} possiamo combinare più liste insieme. Nota come sia necessario che i nuovi oggetti che vogliamo includere siano effettivamente una lista, altrimenti potremmo non ottenere il risultato desiderato:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# ERRORE: combino una lista con un vettore}
\NormalTok{new_vector <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{3}
\KeywordTok{c}\NormalTok{(my_list, new_vector)}
\CommentTok{## $Variabile}
\CommentTok{## [1] "Prova"}
\CommentTok{## }
\CommentTok{## $Vettore}
\CommentTok{## [1]  1  3  5  6 10}
\CommentTok{## }
\CommentTok{## $Dataframe}
\CommentTok{##   id gender y}
\CommentTok{## 1  1      m 1}
\CommentTok{## 2  2      f 2}
\CommentTok{## 3  3      m 3}
\CommentTok{## 4  4      f 4}
\CommentTok{## 5  5      m 5}
\CommentTok{## 6  6      f 6}
\CommentTok{## }
\CommentTok{## $new_obj}
\CommentTok{## [1] "Un nuovo elemento"}
\CommentTok{## }
\CommentTok{## [[5]]}
\CommentTok{## [1] 1}
\CommentTok{## }
\CommentTok{## [[6]]}
\CommentTok{## [1] 2}
\CommentTok{## }
\CommentTok{## [[7]]}
\CommentTok{## [1] 3}

\CommentTok{# CORRETTO: combino una lista con un'altra lista}
\KeywordTok{c}\NormalTok{(my_list, }\KeywordTok{list}\NormalTok{(}\DataTypeTok{new_vector =} \DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{))}
\CommentTok{## $Variabile}
\CommentTok{## [1] "Prova"}
\CommentTok{## }
\CommentTok{## $Vettore}
\CommentTok{## [1]  1  3  5  6 10}
\CommentTok{## }
\CommentTok{## $Dataframe}
\CommentTok{##   id gender y}
\CommentTok{## 1  1      m 1}
\CommentTok{## 2  2      f 2}
\CommentTok{## 3  3      m 3}
\CommentTok{## 4  4      f 4}
\CommentTok{## 5  5      m 5}
\CommentTok{## 6  6      f 6}
\CommentTok{## }
\CommentTok{## $new_obj}
\CommentTok{## [1] "Un nuovo elemento"}
\CommentTok{## }
\CommentTok{## $new_vector}
\CommentTok{## [1] 1 2 3}
\end{Highlighting}
\end{Shaded}

In questo caso sarà necessario salvare il risultato ottenuto per mantenere i cambiamenti.

\hypertarget{informazioni-lista}{%
\subsection{Informazioni Lista}\label{informazioni-lista}}

Vediamo infine alcune funzioni molto comuni usate per ottenere informazioni riassuntive riguardo gli elementi di una lista:

\begin{itemize}
\tightlist
\item
  \texttt{str()} ci permete di valutare la struttura della lista ottenendo utili informazini quali in numero di elementi e la loro tipologia
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{str}\NormalTok{(my_list)}
\CommentTok{## List of 4}
\CommentTok{##  $ Variabile: chr "Prova"}
\CommentTok{##  $ Vettore  : num [1:5] 1 3 5 6 10}
\CommentTok{##  $ Dataframe:'data.frame':   6 obs. of  3 variables:}
\CommentTok{##   ..$ id    : int [1:6] 1 2 3 4 5 6}
\CommentTok{##   ..$ gender: chr [1:6] "m" "f" "m" "f" ...}
\CommentTok{##   ..$ y     : int [1:6] 1 2 3 4 5 6}
\CommentTok{##  $ new_obj  : chr "Un nuovo elemento"}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \texttt{summary()} ci permete avere delle informazioni riassuntive degli elementi tuttavia risulta poco utlie
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{summary}\NormalTok{(my_list)}
\CommentTok{##           Length Class      Mode     }
\CommentTok{## Variabile 1      -none-     character}
\CommentTok{## Vettore   5      -none-     numeric  }
\CommentTok{## Dataframe 3      data.frame list     }
\CommentTok{## new_obj   1      -none-     character}
\end{Highlighting}
\end{Shaded}

\hypertarget{struttura-nested}{%
\section{Struttura Nested}\label{struttura-nested}}

Al contrario dei vettori che si estendono in \emph{lunghezza} o dei dataframe/matrici che sono caratterizzati da righe e colonne, la peculiarità della lista (oltre alla lunghezza come abbaimo visto) è il concetto di \textbf{profondità}. Infatti una lista può contenere al suo interno una o più liste di fatto creando una \textbf{struttura nidificata molto complessa}. Nonostante la struttura più complessa, il principio di indicizzazione e creazione è lo stesso. La Figura \ref{fig:list-depth} rappresenta l'idea di una lista nidificata (o nested):

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth,height=0.5\textheight]{images/list_depth} 

}

\caption{Rappresentazione concettuale di una lista nested}\label{fig:list-depth}
\end{figure}

Per fare un esempio pratico, immaginiamo che \(n\) soggetti abbiamo eseguito \(k\) diversi esperimenti e vogliamo organizzare questa struttura di dati in R in modo efficace e ordinato. Possiamo immaginare una lista \texttt{esperimenti} che contiene:

\begin{itemize}
\tightlist
\item
  Ogni soggetto come una lista, chiamata \texttt{s1,\ s2,\ ...,\ sn}
\item
  Ogni elemento della lista-soggetto è un dataframe per lo specifico esperimento chiamato \texttt{exp1,\ exp2,\ ...,\ expn}
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Per comodità ripetiamo lo stesso esperimento e lo stesso soggetto}

\CommentTok{# Esperimento generico}
\NormalTok{exp_x <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{id =} \DecValTok{1}\OperatorTok{:}\DecValTok{10}\NormalTok{,}
  \DataTypeTok{gender =} \KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"m"}\NormalTok{, }\StringTok{"f"}\NormalTok{), }\DataTypeTok{each =} \DecValTok{5}\NormalTok{),}
  \DataTypeTok{y =} \DecValTok{1}\OperatorTok{:}\DecValTok{10}
\NormalTok{)}

\CommentTok{# Soggetto generico}
\NormalTok{sx <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{exp1 =}\NormalTok{ exp_x,}
  \DataTypeTok{exp2 =}\NormalTok{ exp_x,}
  \DataTypeTok{exp3 =}\NormalTok{ exp_x}
\NormalTok{)}

\CommentTok{# Lista Completa}
\NormalTok{esperimenti <-}\StringTok{ }\KeywordTok{list}\NormalTok{(}
  \DataTypeTok{s1 =}\NormalTok{ sx,}
  \DataTypeTok{s2 =}\NormalTok{ sx,}
  \DataTypeTok{s3 =}\NormalTok{ sx}
\NormalTok{)}

\KeywordTok{str}\NormalTok{(esperimenti)}
\CommentTok{## List of 3}
\CommentTok{##  $ s1:List of 3}
\CommentTok{##   ..$ exp1:'data.frame': 10 obs. of  3 variables:}
\CommentTok{##   .. ..$ id    : int [1:10] 1 2 3 4 5 6 7 8 9 10}
\CommentTok{##   .. ..$ gender: chr [1:10] "m" "m" "m" "m" ...}
\CommentTok{##   .. ..$ y     : int [1:10] 1 2 3 4 5 6 7 8 9 10}
\CommentTok{##   ..$ exp2:'data.frame': 10 obs. of  3 variables:}
\CommentTok{##   .. ..$ id    : int [1:10] 1 2 3 4 5 6 7 8 9 10}
\CommentTok{##   .. ..$ gender: chr [1:10] "m" "m" "m" "m" ...}
\CommentTok{##   .. ..$ y     : int [1:10] 1 2 3 4 5 6 7 8 9 10}
\CommentTok{##   ..$ exp3:'data.frame': 10 obs. of  3 variables:}
\CommentTok{##   .. ..$ id    : int [1:10] 1 2 3 4 5 6 7 8 9 10}
\CommentTok{##   .. ..$ gender: chr [1:10] "m" "m" "m" "m" ...}
\CommentTok{##   .. ..$ y     : int [1:10] 1 2 3 4 5 6 7 8 9 10}
\CommentTok{##  $ s2:List of 3}
\CommentTok{##   ..$ exp1:'data.frame': 10 obs. of  3 variables:}
\CommentTok{##   .. ..$ id    : int [1:10] 1 2 3 4 5 6 7 8 9 10}
\CommentTok{##   .. ..$ gender: chr [1:10] "m" "m" "m" "m" ...}
\CommentTok{##   .. ..$ y     : int [1:10] 1 2 3 4 5 6 7 8 9 10}
\CommentTok{##   ..$ exp2:'data.frame': 10 obs. of  3 variables:}
\CommentTok{##   .. ..$ id    : int [1:10] 1 2 3 4 5 6 7 8 9 10}
\CommentTok{##   .. ..$ gender: chr [1:10] "m" "m" "m" "m" ...}
\CommentTok{##   .. ..$ y     : int [1:10] 1 2 3 4 5 6 7 8 9 10}
\CommentTok{##   ..$ exp3:'data.frame': 10 obs. of  3 variables:}
\CommentTok{##   .. ..$ id    : int [1:10] 1 2 3 4 5 6 7 8 9 10}
\CommentTok{##   .. ..$ gender: chr [1:10] "m" "m" "m" "m" ...}
\CommentTok{##   .. ..$ y     : int [1:10] 1 2 3 4 5 6 7 8 9 10}
\CommentTok{##  $ s3:List of 3}
\CommentTok{##   ..$ exp1:'data.frame': 10 obs. of  3 variables:}
\CommentTok{##   .. ..$ id    : int [1:10] 1 2 3 4 5 6 7 8 9 10}
\CommentTok{##   .. ..$ gender: chr [1:10] "m" "m" "m" "m" ...}
\CommentTok{##   .. ..$ y     : int [1:10] 1 2 3 4 5 6 7 8 9 10}
\CommentTok{##   ..$ exp2:'data.frame': 10 obs. of  3 variables:}
\CommentTok{##   .. ..$ id    : int [1:10] 1 2 3 4 5 6 7 8 9 10}
\CommentTok{##   .. ..$ gender: chr [1:10] "m" "m" "m" "m" ...}
\CommentTok{##   .. ..$ y     : int [1:10] 1 2 3 4 5 6 7 8 9 10}
\CommentTok{##   ..$ exp3:'data.frame': 10 obs. of  3 variables:}
\CommentTok{##   .. ..$ id    : int [1:10] 1 2 3 4 5 6 7 8 9 10}
\CommentTok{##   .. ..$ gender: chr [1:10] "m" "m" "m" "m" ...}
\CommentTok{##   .. ..$ y     : int [1:10] 1 2 3 4 5 6 7 8 9 10}
\end{Highlighting}
\end{Shaded}

Ora la struttura è molto più complessa, ma se abbiamo chiara la Figura \ref{fig:list-depth} e l'indicizzazione per le liste precedenti, accedere agli elementi della lista \texttt{esperimenti} è semplice ed intuitivo. Se vogliamo accedere al dataset del \texttt{soggetto\ 3} che riguarda \texttt{l\textquotesingle{}esperimento\ 2}:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Con indici numerici}
\NormalTok{esperimenti[[}\DecValTok{3}\NormalTok{]][[}\DecValTok{2}\NormalTok{]] }\CommentTok{# elemento 3 (una lista) e poi l'elemento 2}
\CommentTok{##    id gender  y}
\CommentTok{## 1   1      m  1}
\CommentTok{## 2   2      m  2}
\CommentTok{## 3   3      m  3}
\CommentTok{## 4   4      m  4}
\CommentTok{## 5   5      m  5}
\CommentTok{## 6   6      f  6}
\CommentTok{## 7   7      f  7}
\CommentTok{## 8   8      f  8}
\CommentTok{## 9   9      f  9}
\CommentTok{## 10 10      f 10}

\CommentTok{# Con i nomi (molto più intuitivo)}
\NormalTok{esperimenti}\OperatorTok{$}\NormalTok{s3}\OperatorTok{$}\NormalTok{exp2}
\CommentTok{##    id gender  y}
\CommentTok{## 1   1      m  1}
\CommentTok{## 2   2      m  2}
\CommentTok{## 3   3      m  3}
\CommentTok{## 4   4      m  4}
\CommentTok{## 5   5      m  5}
\CommentTok{## 6   6      f  6}
\CommentTok{## 7   7      f  7}
\CommentTok{## 8   8      f  8}
\CommentTok{## 9   9      f  9}
\CommentTok{## 10 10      f 10}
\end{Highlighting}
\end{Shaded}

\begin{tip}[A cosa servono le liste?]

Se il vantaggio di un dataframe rispetto ad una matrice è palese, quale è la vera utilità delle liste essendo ``semplicemente'' dei contenitori?
I vantaggi principali che rendono le liste degli oggetti estremamente potenti sono:

\begin{itemize}
\tightlist
\item
  \textbf{Organizzare strutture complesse di dati}: come abbiamo visto nell'esempio precedente, insiemi di oggetti nidificati possono essere organizzati in un oggetto unico senza avere decine di singoli oggetti nel workspace.
\item
  \textbf{Effettuare operazioni complesse su più oggetti parallelamente}. Immaginate di avere una lista di dataframe strutturalmente simili ma con dati diversi all'interno. Se volete applicare una funzione ad ogni dataframe potete organizzare i dati in una lista e usare le funzioni dell'\texttt{apply} family che vedremo nei prossimi capitoli. TODO
\end{itemize}

Infine, proprio per la loro flessibilità, le liste sono spesso utilizzate da vari pachetti per restituire i risultati delle analisi statistiche svolte. Saper accedere ai vari elementi di una lista risulta quindi necessario per ottenere specifiche infomazioni e risultati.

\end{tip}

\hypertarget{part-algoritmi}{%
\part*{Algoritmi}\label{part-algoritmi}}
\addcontentsline{toc}{part}{Algoritmi}

\hypertarget{introduzione-2}{%
\chapter*{Introduzione}\label{introduzione-2}}
\addcontentsline{toc}{chapter}{Introduzione}

Working in progress.

\hypertarget{functions}{%
\chapter{Definizione di Funzioni}\label{functions}}

Working in progress.

\hypertarget{coditionals}{%
\chapter{Programmazione Condizionale}\label{coditionals}}

Working in progress.

\hypertarget{loop}{%
\chapter{Attenti al loop}\label{loop}}

Working in progress.

\hypertarget{part-case-study}{%
\part*{Case study}\label{part-case-study}}
\addcontentsline{toc}{part}{Case study}

\hypertarget{introduzione-3}{%
\chapter*{Introduzione}\label{introduzione-3}}
\addcontentsline{toc}{chapter}{Introduzione}

Working in progress.

\hypertarget{attachment}{%
\chapter{Caso Studio I: Attaccamento}\label{attachment}}

Working in progress.

\hypertarget{infobox}{%
\section{Infobox}\label{infobox}}

Illustrations included in \texttt{images/} are retrieved from \href{https://rstudio4edu.github.io/rstudio4edu-book/}{rstudio4edu-book} under \href{https://creativecommons.org/licenses/by-nc/2.0/}{CC-BY-NC}. Remember to include an \emph{Attributions} section in the book and repository's README file.

\begin{tip}[My title]

Lorem ipsum dolor sit amet consectetur adipisicing elit. Maxime mollitia,
molestiae quas vel sint commodi repudiandae consequuntur voluptatum laborum
numquam blanditiis harum quisquam eius sed odit fugiat iusto fuga praesentium
optio, eaque rerum!

\end{tip}

\begin{warning}[My title]

Lorem ipsum dolor sit amet consectetur adipisicing elit. Maxime mollitia,
molestiae quas vel sint commodi repudiandae consequuntur voluptatum laborum
numquam blanditiis harum quisquam eius sed odit fugiat iusto fuga praesentium
optio, eaque rerum!

\end{warning}

\begin{deffun}[My title]

Lorem ipsum dolor sit amet consectetur adipisicing elit. Maxime mollitia,
molestiae quas vel sint commodi repudiandae consequuntur voluptatum laborum
numquam blanditiis harum quisquam eius sed odit fugiat iusto fuga praesentium
optio, eaque rerum!

\end{deffun}

\begin{design}[My title]

Lorem ipsum dolor sit amet consectetur adipisicing elit. Maxime mollitia,
molestiae quas vel sint commodi repudiandae consequuntur voluptatum laborum
numquam blanditiis harum quisquam eius sed odit fugiat iusto fuga praesentium
optio, eaque rerum!

\end{design}

\begin{trick}[My title]

Lorem ipsum dolor sit amet consectetur adipisicing elit. Maxime mollitia,
molestiae quas vel sint commodi repudiandae consequuntur voluptatum laborum
numquam blanditiis harum quisquam eius sed odit fugiat iusto fuga praesentium
optio, eaque rerum!

\end{trick}

  \bibliography{book.bib,packages.bib}

\end{document}
