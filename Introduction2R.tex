% Options for packages loaded elsewhere
\PassOptionsToPackage{unicode}{hyperref}
\PassOptionsToPackage{hyphens}{url}
%
\documentclass[
]{book}
\usepackage{lmodern}
\usepackage{amssymb,amsmath}
\usepackage{ifxetex,ifluatex}
\ifnum 0\ifxetex 1\fi\ifluatex 1\fi=0 % if pdftex
  \usepackage[T1]{fontenc}
  \usepackage[utf8]{inputenc}
  \usepackage{textcomp} % provide euro and other symbols
\else % if luatex or xetex
  \usepackage{unicode-math}
  \defaultfontfeatures{Scale=MatchLowercase}
  \defaultfontfeatures[\rmfamily]{Ligatures=TeX,Scale=1}
\fi
% Use upquote if available, for straight quotes in verbatim environments
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\IfFileExists{microtype.sty}{% use microtype if available
  \usepackage[]{microtype}
  \UseMicrotypeSet[protrusion]{basicmath} % disable protrusion for tt fonts
}{}
\makeatletter
\@ifundefined{KOMAClassName}{% if non-KOMA class
  \IfFileExists{parskip.sty}{%
    \usepackage{parskip}
  }{% else
    \setlength{\parindent}{0pt}
    \setlength{\parskip}{6pt plus 2pt minus 1pt}}
}{% if KOMA class
  \KOMAoptions{parskip=half}}
\makeatother
\usepackage{xcolor}
\IfFileExists{xurl.sty}{\usepackage{xurl}}{} % add URL line breaks if available
\IfFileExists{bookmark.sty}{\usepackage{bookmark}}{\usepackage{hyperref}}
\hypersetup{
  pdftitle={Introduction to R},
  pdfauthor={Claudio Zandonella Callegher and Filippo Gambarota members of Psicostat},
  hidelinks,
  pdfcreator={LaTeX via pandoc}}
\urlstyle{same} % disable monospaced font for URLs
\usepackage{color}
\usepackage{fancyvrb}
\newcommand{\VerbBar}{|}
\newcommand{\VERB}{\Verb[commandchars=\\\{\}]}
\DefineVerbatimEnvironment{Highlighting}{Verbatim}{commandchars=\\\{\}}
% Add ',fontsize=\small' for more characters per line
\usepackage{framed}
\definecolor{shadecolor}{RGB}{248,248,248}
\newenvironment{Shaded}{\begin{snugshade}}{\end{snugshade}}
\newcommand{\AlertTok}[1]{\textcolor[rgb]{0.94,0.16,0.16}{#1}}
\newcommand{\AnnotationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\AttributeTok}[1]{\textcolor[rgb]{0.77,0.63,0.00}{#1}}
\newcommand{\BaseNTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\BuiltInTok}[1]{#1}
\newcommand{\CharTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\CommentTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\CommentVarTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ConstantTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ControlFlowTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\DataTypeTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{#1}}
\newcommand{\DecValTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\DocumentationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\ErrorTok}[1]{\textcolor[rgb]{0.64,0.00,0.00}{\textbf{#1}}}
\newcommand{\ExtensionTok}[1]{#1}
\newcommand{\FloatTok}[1]{\textcolor[rgb]{0.00,0.00,0.81}{#1}}
\newcommand{\FunctionTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\ImportTok}[1]{#1}
\newcommand{\InformationTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\newcommand{\KeywordTok}[1]{\textcolor[rgb]{0.13,0.29,0.53}{\textbf{#1}}}
\newcommand{\NormalTok}[1]{#1}
\newcommand{\OperatorTok}[1]{\textcolor[rgb]{0.81,0.36,0.00}{\textbf{#1}}}
\newcommand{\OtherTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{#1}}
\newcommand{\PreprocessorTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textit{#1}}}
\newcommand{\RegionMarkerTok}[1]{#1}
\newcommand{\SpecialCharTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\SpecialStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\StringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\VariableTok}[1]{\textcolor[rgb]{0.00,0.00,0.00}{#1}}
\newcommand{\VerbatimStringTok}[1]{\textcolor[rgb]{0.31,0.60,0.02}{#1}}
\newcommand{\WarningTok}[1]{\textcolor[rgb]{0.56,0.35,0.01}{\textbf{\textit{#1}}}}
\usepackage{longtable,booktabs}
% Correct order of tables after \paragraph or \subparagraph
\usepackage{etoolbox}
\makeatletter
\patchcmd\longtable{\par}{\if@noskipsec\mbox{}\fi\par}{}{}
\makeatother
% Allow footnotes in longtable head/foot
\IfFileExists{footnotehyper.sty}{\usepackage{footnotehyper}}{\usepackage{footnote}}
\makesavenoteenv{longtable}
\usepackage{graphicx,grffile}
\makeatletter
\def\maxwidth{\ifdim\Gin@nat@width>\linewidth\linewidth\else\Gin@nat@width\fi}
\def\maxheight{\ifdim\Gin@nat@height>\textheight\textheight\else\Gin@nat@height\fi}
\makeatother
% Scale images if necessary, so that they will not overflow the page
% margins by default, and it is still possible to overwrite the defaults
% using explicit options in \includegraphics[width, height, ...]{}
\setkeys{Gin}{width=\maxwidth,height=\maxheight,keepaspectratio}
% Set default figure placement to htbp
\makeatletter
\def\fps@figure{htbp}
\makeatother
\setlength{\emergencystretch}{3em} % prevent overfull lines
\providecommand{\tightlist}{%
  \setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}}
\setcounter{secnumdepth}{5}
\usepackage[a4paper,includeheadfoot,left=3cm, right=3cm, top=3cm, bottom=3cm]{geometry}  % margin settings
\usepackage{booktabs}
\usepackage{makecell} % for tables
\usepackage{amsthm}
\makeatletter
\def\thm@space@setup{%
  \thm@preskip=8pt plus 2pt minus 4pt
  \thm@postskip=\thm@preskip
}
\makeatother

\usepackage{hyperref}

%----    define infoboxes    ----%
\usepackage{tcolorbox}
\usepackage{xcolor}

% colors
\definecolor{background}{HTML}{fcfcfc}
\definecolor{tip-text}{HTML}{e7b002}
\definecolor{tip-line}{HTML}{fdce38}
\definecolor{warning-text}{HTML}{b06336}
\definecolor{warning-line}{HTML}{c97d50}
\definecolor{deffun-text}{HTML}{0b797e}
\definecolor{deffun-line}{HTML}{6CC2C9}
\definecolor{design-text}{HTML}{7c972e}
\definecolor{design-line}{HTML}{a7c84a}
\definecolor{trick-text}{HTML}{8c3031}
\definecolor{trick-line}{HTML}{A3595A}

\newtcolorbox{mybox}[1][black]{
  colback=background,
  coltext=black,
  colframe=#1,
  boxsep=5pt,
  arc=4pt}

% tip
\newenvironment{tip}[1][Title]
  {
  \setlength{\fboxsep}{1em}
  \begin{mybox}[tip-line]
    \raisebox{-.2\height}{\includegraphics[height=.6cm]{images/lightbulb.png}} \large \textcolor{tip-text}{Tip-Box: #1}\\
    }
    {
  \end{mybox}
  }

% warning
\newenvironment{warning}[1][Title]
  {
  \setlength{\fboxsep}{1em}
  \begin{mybox}[warning-line]
    \raisebox{-.2\height}{\includegraphics[height=.6cm]{images/gotcha.png}} \large \textcolor{warning-text}{Warning-Box: #1}\\
    }
    {
  \end{mybox}
  }

% deffun
\newenvironment{deffun}[1][Title]
  {
  \setlength{\fboxsep}{1em}
  \begin{mybox}[deffun-line]
    \raisebox{-.2\height}{\includegraphics[height=.6cm]{images/gears.png}} \large \textcolor{deffun-text}{Definition-Box: #1}\\
    }
    {
  \end{mybox}
  }

% design
\newenvironment{design}[1][Title]
  {
  \setlength{\fboxsep}{1em}
  \begin{mybox}[design-line]
    \raisebox{-.2\height}{\includegraphics[height=.6cm]{images/design.png}} \large \textcolor{design-text}{Approfondimento: #1}\\
    }
    {
  \end{mybox}
  }

% trick
\newenvironment{trick}[1][Title]
  {
  \setlength{\fboxsep}{1em}
  \begin{mybox}[trick-line]
    \raisebox{-.2\height}{\includegraphics[height=.6cm]{images/hat.png}} \large \textcolor{trick-text}{Trick-Box: #1}\\
    }
    {
  \end{mybox}
  }
\usepackage{titlepic}
\titlepic{\includegraphics[width=\textwidth]{images/logo_psicostat.pdf}}
\usepackage{booktabs}
\usepackage{longtable}
\usepackage{array}
\usepackage{multirow}
\usepackage{wrapfig}
\usepackage{float}
\usepackage{colortbl}
\usepackage{pdflscape}
\usepackage{tabu}
\usepackage{threeparttable}
\usepackage{threeparttablex}
\usepackage[normalem]{ulem}
\usepackage{makecell}
\usepackage{xcolor}
\usepackage[]{natbib}
\bibliographystyle{plainnat}

\title{{Introduction to R}}
\usepackage{etoolbox}
\makeatletter
\providecommand{\subtitle}[1]{% add subtitle to \maketitle
  \apptocmd{\@title}{\par {\large #1 \par}}{}{}
}
\makeatother
\subtitle{Corso per imparare le basi di \textbf{R}}
\author{\href{https://claudiozandonella.netlify.app/}{Claudio Zandonella Callegher} and \href{https://filippogambarota.netlify.app/}{Filippo Gambarota} members of \href{https://psicostat.dpss.psy.unipd.it/}{Psicostat}}
\date{21-03-2021}

\begin{document}
\maketitle

{
\setcounter{tocdepth}{1}
\tableofcontents
}
\hypertarget{presentazione}{%
\chapter*{Presentazione}\label{presentazione}}
\addcontentsline{toc}{chapter}{Presentazione}

In questo libro impareremo le basi di \emph{R}, uno dei migliori software per la visualizzazione e l'analisi statistica dei dati. Partiremo da zero intorducendo gli aspetti fondamentili di R e i concetti alla base di ogni linguaggio di programmazione che ti pemetteranno in seguito di approfondire e sviluppare le tue abilità in questo bellissimo mondo.

\hypertarget{perchuxe8-r}{%
\section*{Perchè R}\label{perchuxe8-r}}
\addcontentsline{toc}{section}{Perchè R}

Ci sono molte ragioni per cui scegliere R rispetto ad altri programmi usati per condurre le analisi statistiche. Innanzitutto è un linguaggio di programmazione (come ad esempio Python, Java, C++, o Julia) e non semplicemente un'interfaccia punta e clicca (come ad esempio SPSS o JASP). Questo comporta si maggiori difficoltà iniziali ma ti ricompenserà in futuro poichè avari imparato ad utilizza uno strumennto molto potente.

Inoltre, R è:

\begin{itemize}
\tightlist
\item
  nato per la statistica
\item
  open-source
\item
  ricco di pacchetti
\item
  supportato da una grande community
\item
  gratis
\end{itemize}

\hypertarget{struttura-del-libro}{%
\section*{Struttura del libro}\label{struttura-del-libro}}
\addcontentsline{toc}{section}{Struttura del libro}

Il libro è suddiviso in quattro sezioni principali:

\begin{itemize}
\tightlist
\item
  \textbf{Get started}. Una volta installato R ed RStudio, famiglierizzeremo con l'ambiente di lavoro introducendo alcuni aspetti generali e le funzioni principali. Verranno inoltre descritte alcune buone regole per iniziare una sessione di lavoro in R.
\item
  \textbf{Struttura dei dati}. Impareremo gli oggetti principali che R utilizza al suo interno. Variabili, vettori, matrici, dataframe e liste non avranno più segreti e capiremo come manipolarli e utlizzarli a seconda delle varie necessità.
\item
  \textbf{Algoritmi}. Non farti spaventare da questo nome. Ne avrai spesso sentito parlarne come qualcosa di molto complicato, ma in realtà gli algoritmi sono semplicemente una serie di istruzioni che il computer segue quando deve eseguire un determinato compito. In questa sezione vedremo i principali comandi di R usati per definire degli algoritmi. Questo è il vantaggio di conoscere un linguaggio di programmazione, ci permette di creare nuovi programmi che il computer eseguirà per noi.
\item
  \textbf{Case study}. Eseguiremo passo per passo un analisi che ci permetterà di imparare come importare i dati, codificare le variabili, manipolare e preprare i dati perle analisi, condurre delle analisi descrittive e creare dei grafici.
\end{itemize}

Alla fine di questo libro probabilmente non sarete assunti da Google, ma speriamo almeno che R non vi faccia più così paura e che magari a qualcuno sia nato l'interesse di approfondire questo fantastico mondo fatto di linee di codice.

\hypertarget{risorse-utili}{%
\section*{Risorse Utili}\label{risorse-utili}}
\addcontentsline{toc}{section}{Risorse Utili}

Segnaliamo qui per il lettore interessato del materiale online (in inglese) per approfondire le conoscenze sull'uso di R.

Materiale introduttivo:

\begin{itemize}
\tightlist
\item
  \emph{R for Psychological Science} di Danielle Navarro \url{https://psyr.djnavarro.net/index.html}
\item
  \emph{Hands-On Programming with R} di Garrett Grolemund \url{https://rstudio-education.github.io/hopr/}
\end{itemize}

Materiale intermedio:

\begin{itemize}
\tightlist
\item
  \emph{R for Data Science} di Hadley Wickham e Garrett Grolemund \url{https://r4ds.had.co.nz/}
\end{itemize}

Materiale avanzato:

\begin{itemize}
\tightlist
\item
  \emph{R Packages} di Hadley Wickham e Jennifer Bryan \url{https://r-pkgs.org/}
\item
  \emph{Advanced R} di Hadley Wickham \url{https://adv-r.hadley.nz/}
\end{itemize}

\hypertarget{psicostat}{%
\section*{Psicostat}\label{psicostat}}
\addcontentsline{toc}{section}{Psicostat}

Questo libro è stato prodotto da \href{https://claudiozandonella.netlify.app/}{Claudio Zandonella Callegher} and \href{https://filippogambarota.netlify.app/}{Filippo Gambarota}, membri di \textbf{Psicostat}. Un gruppo di ricerca interdisciplinare dell'universita di Padova che unisce la passione per la statistica e la psicologia. Se vuoi conoscere di più riguardo le nostre attività visita il nosto sito \url{https://psicostat.dpss.psy.unipd.it/} o aggiungiti alla nostra mailing list \url{https://lists.dpss.psy.unipd.it/postorius/lists/psicostat.lists.dpss.psy.unipd.it/}.

\hypertarget{collaborazione}{%
\section*{Collaborazione}\label{collaborazione}}
\addcontentsline{toc}{section}{Collaborazione}

Se vuoi collaborare alla revione e scrittura di questo libro (ovviamente è tutto in R) visita la nostra repository di Github \url{https://github.com/psicostat/Introduction2R}.

\hypertarget{riconoscimenti}{%
\section*{Riconoscimenti}\label{riconoscimenti}}
\addcontentsline{toc}{section}{Riconoscimenti}

Il template di questo libro è basato su \href{https://github.com/rstudio/bookdown-demo}{Rstudio Bookdown-demo} rilasciato con licenza \href{https://creativecommons.org/publicdomain/zero/1.0/}{CC0-1.0} e \href{https://rstudio4edu.github.io/rstudio4edu-book/}{rstudio4edu-book} rilasciato con licenza \href{https://creativecommons.org/licenses/by/2.0/}{CC BY}. Nota che le illustrazioni utilizzate nelle vignette appartengono sempre a \href{https://rstudio4edu.github.io/rstudio4edu-book/}{rstudio4edu-book} e sono rilasciate con licenza \href{https://creativecommons.org/licenses/by-nc/2.0/}{CC BY-NC}.

\hypertarget{licenza}{%
\section*{Licenza}\label{licenza}}
\addcontentsline{toc}{section}{Licenza}

Questo libro è rilasciato sotto la Creative Commons Attribution-ShareAlike 4.0 International Public License (\href{https://creativecommons.org/licenses/by-sa/4.0/legalcode}{CC BY-SA}).
Le illustrazioni utilizzate nelle vignette appartengono a \href{https://rstudio4edu.github.io/rstudio4edu-book/}{rstudio4edu-book} e sono rilasciate con licenza \href{https://creativecommons.org/licenses/by-nc/2.0/}{CC BY-NC}.

\hypertarget{part-get-started}{%
\part*{Get Started}\label{part-get-started}}
\addcontentsline{toc}{part}{Get Started}

\hypertarget{intorduzione}{%
\chapter*{Intorduzione}\label{intorduzione}}
\addcontentsline{toc}{chapter}{Intorduzione}

In questa sezione verranno prima presentate le istruzioni per installare R ed RStudio. Successivamente, svolgeremo le prime oprazioni in R e famiglierizzeremo con dei concetti di base della programmazioene quali gli oggetti e le funzioni. Introdurremmo infine altri concetti relativi alle sessioni di lavoro in R e descriveremo alcune buone regole per nell'utilizzo di R.

I capitoli sono così organizzati:

\begin{itemize}
\tightlist
\item
  \textbf{Capitolo \ref{install} - Installare R e RStudio}. Instruzioni passo a passo per installare R e RStudio
\item
  \textbf{Capitolo \ref{rstudio-gui} - Interfaccia RStudio}. Introduzione all'interfaccia utente di RStudio.
\item
  \textbf{Capitolo \ref{first-comands} - Primi Passi in R}. Operatori matematici, operatori relazionali, operatori logici.
\item
  \textbf{Capitolo \ref{objects-functions} - Due Compagni Inseparabili}. Introduzione dei concetti di oggetti e funzioni in R.
\item
  \textbf{Capitolo \ref{working-environment} - Ambiente di Lavoro}. Introduzione dei concetti di Envieronment, working directory e dei pacchetti di R.
\item
  \textbf{Capitolo \ref{working-session} - Sessione di Lavoro}. Descrizione di buone pratiche nelle sessioni di lavoro e gestione degli errori.
\end{itemize}

\hypertarget{install}{%
\chapter{Installare R e RStudio}\label{install}}

R ed R-studio sono due software distinti. R è un linguaggio di programmazione usato in particolare in ambiti quali la statistica. R-studio invece è un'interfaccia \emph{user-friendly} che permette di utilizzare R.
R può essere utilizzato autonomamente tuttavia è consigliato l'utilizzo attraverso R-studio. Entrambi vanno installati separatamente e la procedura varia a seconda del proprio sistema operativo (Windows, MacOS o Linux). Riportiamo le istruzioni solo per Windows e MacOS Linux (Ubuntu). Ovviamente R è disponibile per tutte le principali distribuzioni di Linux. Le istruzioni riportate per Ubuntu (la distribuzione più diffusa) sono valide anche per le distribuzioni derivate.

\hypertarget{install-r}{%
\section{Installare R}\label{install-r}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Accedere al sito \url{https://www.r-project.org}
\item
  Selezionare la voce \textbf{CRAN} (Comprehensive R Archive Network) dal menù di sinistra sotto \textbf{Download}
\end{enumerate}

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install_CRAN.png}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Selezionare il primo link \url{https://cloud.r-project.org/}
\end{enumerate}

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install_mirror.png}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Selezionare il proprio sistema operativo
\end{enumerate}

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install_OS.png}

\hypertarget{r-windows}{%
\subsection{R Windows}\label{r-windows}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Selezionare la voce \textbf{base}
\end{enumerate}

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install-Windows-base.png}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Selezionare la voce \textbf{Download} della versione più recente di R disponibile
\end{enumerate}

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install-Windows-version.png}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Al termine del download, eseguire il file e seguire le istruzioni fino al termine dell'installazione
\end{enumerate}

\hypertarget{r-macos}{%
\subsection{R MacOS}\label{r-macos}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Selezionare della versione più recente di R disponibile
\end{enumerate}

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install_Mac_version.png}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Al termine del download, eseguire il file e seguire le istruzioni fino al termine dell'installazione di R
\item
  Successivamente è necessario installare anche una componente aggiuntiva \textbf{XQuartz} premendo il link all'interno del riquadro arancione riportato nella figura precedente
\item
  Selezionare la voce Download
\end{enumerate}

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install_Mac_XQuartz.png}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Al termine del download, eseguire il file e seguire le istruzioni fino al termine dell'installazione
\end{enumerate}

\hypertarget{r-linux}{%
\subsection{R Linux}\label{r-linux}}

Nonostante la semplicità di installazione di pacchetti su Linux, R a volte potrebbe essere più complicato da installare per via delle diverse distribuzioni, repository e chiavi per riconoscere la repository come sicura.

Sul \textbf{CRAN} vi è la guida ufficiale con tutti i comandi \texttt{apt} da eseguire da terminale. Seguendo questi passaggi non dovrebbero esserci problemi.

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Andate sul \href{https://cran.r-project.org/}{CRAN}
\item
  Cliccate \texttt{Download\ R\ for\ Linux}
\item
  Selezionate la vostra distribuzione (Ubuntu in questo caso)
\item
  Seguite le istruzioni, principalmente eseguendo i comandi da terminale suggeriti
\end{enumerate}

Per qualsiasi difficoltà o errore, sopratutto con il mondo Linux, una ricerca su online risolve sempre il problema.

\begin{design}[R Tools]

Utilizzi avanzati di R richiedono l'insallazione di una serie ulteriore software definiti \textbf{R tools}.

\hypertarget{windows}{%
\subsubsection*{Windows}\label{windows}}
\addcontentsline{toc}{subsubsection}{Windows}

Seleziona la voce \textbf{Rtools} e segui le istruzioni per completare l'installazione.

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install-Windows-tools.png}

Nota che sono richieste anche delle operazioni di configurazione affinchè tutto funzioni correttamente.

\hypertarget{macos}{%
\subsubsection*{MacOS}\label{macos}}
\addcontentsline{toc}{subsubsection}{MacOS}

Seleziona la voce \textbf{tools} e segui le istruzioni riportate.

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install_Mac_tools.png}

Nota in particolare che con R 4.0 le seguenti indicazioni sono riportate.

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install_Mac_tools2.png}

\end{design}

\hypertarget{installare-r-studio}{%
\section{Installare R Studio}\label{installare-r-studio}}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Accedere al sito \url{https://rstudio.com}
\item
  Selezionare la voce \textbf{DOWNLOAD IT NOW}
\end{enumerate}

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install_rstudio1.png}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{2}
\tightlist
\item
  Selezionare la versione gratuita di RStudio Desktop
\end{enumerate}

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install_rstudio2.png}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Selezionare la versione corretta a seconda del proprio sistema operativo
\end{enumerate}

\includegraphics[width=0.95\textwidth,height=\textheight]{images/install_rstudio3.png}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{4}
\tightlist
\item
  Al termine del download, eseguire il file e seguire le istruzioni fino al termine dell'installazione
\end{enumerate}

\hypertarget{r-studio-in-linux}{%
\subsection{R Studio in Linux}\label{r-studio-in-linux}}

In questo caso, come su Windows e MacOS l'installazione consiste nello scaricare ed eseguire il file corretto, in base alla distribuzione (ad esempio \texttt{.deb} per Ubuntu e derivate). Importante, nel caso di Ubuntu (ma dovrebbe valere anche per le altre distribuzioni) anche versioni successive a quella indicata (es. Ubuntu 16) sono perfettamente compatibili.

\hypertarget{rstudio-gui}{%
\chapter{Interfaccia RStudio}\label{rstudio-gui}}

In questo capitolo presenteremo l'interfaccia utente di RStudio. Molti aspetti che introdurremo brevemente qui verranno discussi nei sucessivi capitoli. Adesso ci interessa solo famigliarizzare con l'interfaccia del nostro strumento di lavoro principale ovvero RStudio.

Come abbiamo visto nel Capitolo \ref{install}, R è il vero ``motore computazionale'' che ci permette di compiere tutte le operazioni di calcolo, analisi statistiche e magie varie. Tuttavia l'interfaccia di base di R, definita \textbf{Console} (vedi Figura \ref{fig:r-console}), è per così dire \emph{démodé} o meglio, solo per veri intenditori.

\begin{figure}

{\centering \includegraphics[width=0.85\linewidth]{images/r-console} 

}

\caption{La console di R, solo per veri intenditori}\label{fig:r-console}
\end{figure}

In genere, per lavorare con R viene utilizzato RStudio. RStudio è un programma (IDE - Integrated Development Environment) che integra in un unica interfaccia utente (GUI - Graphical User Interface) diversi strumenti utili per la scrittura ed esecuzione di codici. L'interfaccia di RStudio è costituita da 4 pannelli principali (vedi Figura \ref{fig:rstudio-gui}):

\begin{figure}

{\centering \includegraphics[width=0.85\linewidth]{images/rstudio-gui} 

}

\caption{Interfaccia utente di Rstudio con i suoi 4 pannelli}\label{fig:rstudio-gui}
\end{figure}

\hypertarget{console-il-cuore-di-r}{%
\subsubsection*{1. Console: il cuore di R}\label{console-il-cuore-di-r}}
\addcontentsline{toc}{subsubsection}{1. Console: il cuore di R}

Qui ritroviamo la \emph{Console} di R dove vengono effetivemente eseguiti tutti i tuoi codici e comandi. Nota come nell'ulitma riga della \emph{Console} appaia il carattere \texttt{\textgreater{}}. Questo è definito \emph{prompt} è ci indica che R in attesa di nuovi comandi da eseguire.

La \emph{Console} di R è un'interfaccia a linea di comando. A differenza di altri programmi ``\emph{punta e clicca}'', in R è necessario digitare i comandi utilizzando la tastiera. Per eseguire dei comandi possiamo direttamnte scrivere nella \emph{Console} le operazioni da eseguire e premere \texttt{invio}. R eseguirà immediatamente i nostro comando, riporterà il risultato e nella linea successiva apparirà nuovamente il \emph{prompt} indicando che R è pronto ad eseguire un altro comando (vedi Figura \ref{fig:comand-sequence}).

\begin{figure}

{\centering \includegraphics[width=0.95\linewidth]{images/comand-sequence} 

}

\caption{Esecuzione di comandi direttamente nella console}\label{fig:comand-sequence}
\end{figure}

Nel caso di comandi scritti su più righe, vedi l'esempio di Figura \ref{fig:multiple-line-comand}, è possibile notare come venga mostrato il simbolo \texttt{+} come \emph{prompt}. Questo indica che R è in attesa che l'intero comando venga digitato prima che esso venga eseguito.

\begin{figure}

{\centering \includegraphics[width=0.95\linewidth]{images/multiple-line-comand} 

}

\caption{Esecuzione di un comando su più righe}\label{fig:multiple-line-comand}
\end{figure}

Come avrai notato facendo alcune prove, i comandi digitati nella \emph{Console} vengono eseguiti immediatamente ma non sono salvati. Per rieseguire un comando, possiamo navigare tra quelli precedentementemente eseguiti usando le freccie della tastiera \(\uparrow\downarrow\). Tuttavia, in caso di errori dovremmo riscrivere e rieseguire tutti i comandi. Siccome scrivere codici è un continuo ``\emph{try and error}'', lavorare unicamente dalla \emph{Console} diventa presto caotico. Abbiamo bisogno quindi di una soluzione che ci permetta di lavrorare più comodamente sui nostri codici e di poter salvare i nostri comandi da eseguire all'occorrenza con il giusto ordine. La soluzione sono gli \emph{Scripts} che introdurremo vedremo nella prossima sezione.

\begin{tip}[Interrompere un comando]

Potrebbe accadere che per qualche errore nel digitare un comando o perchè sono richiesti lunghi tempi computazionali, la \emph{Console} di R diventi non responsiva. In questo caso è necessario interrompere la scrittura o l'esecuzione di un comando. Vediamo due situazioni comuni:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \textbf{Continua a comparire il prompt} \texttt{+}. Specialmente nel caso di utilizzo di parentesi e lunghi comandi, accade che una volta premuto \texttt{invio} R non esegua alcun comando ma resta in attesa mostrando il \emph{prompt} \texttt{+} (vedi Figure seguente). Questo è in genere dato da un errore nella sintassi del comando (e.g., un errore nell'uso delle parentesi o delle virgole). Per riprendere la sessione è necessario premere il tasto \texttt{esc} della tastiera. L'apprire del \emph{prompt} \texttt{\textgreater{}}, indica che R è nuovamente in ascolto pronto per esequire un nuovo comando ma attento a non ripetere lo stesso errore, la sintassi dei comandi è importante (vedi Capitolo TODO).
\end{enumerate}

\begin{center}\includegraphics[width=0.95\linewidth]{images/comand-esc} \end{center}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  \textbf{R non risponde}. Alcuni calcoli potrebbero richiedere molto tempo o semplicemnte un qualche problema ha mandato in loop la tua sessione di lavoro. In questa situazione la \emph{Console} di R diventa non responsiva. Nel caso fosse necessario interrompere i processi attualmente in esecuzione devi premere il pulsante \emph{STOP} come indicato nella Figura seguente. R si fermerà e ritornerà in attesa di nuovi comandi (\emph{prompt} \texttt{\textgreater{}}).
\end{enumerate}

\begin{center}\includegraphics[width=0.95\linewidth]{images/console-stop} \end{center}

\end{tip}

\begin{trick}[Force Quit]

In alcuni casi estremi in cui R sembra non rispondere, usa i comandi \texttt{Ctrl-C} per forzare R a interrompere il processo in esecuzione.

Come ultima soluzione ricorda uno dei principi base dell'informatica ``\emph{spegni e riaccendi}'' (a volte potrebbe bastare chiudere e riaprire RStudio).

\end{trick}

\hypertarget{source-il-tuo-blocco-appunti}{%
\subsubsection*{2. Source: il tuo blocco appunti}\label{source-il-tuo-blocco-appunti}}
\addcontentsline{toc}{subsubsection}{2. Source: il tuo blocco appunti}

In questa parte vengono mostrati i tuoi \emph{Scripts}. Questi non sono altro che degli speciali documenti (con estensione ``\textbf{.R}'') in cui sono salvati i tuoi codici e comandi che potrai eseguire quando necessario in R. Gli \emph{Scripts} ti permetteranno di lavorare comodamente sui tuoi codici, scrivere i comandi, corregerli, organizzarli, aggiungere dei commenti e soprattutto salvarli.

Dopo aver terminato di scrivere i comandi, posiziona il cursore sulla stessa linea del comando che desideri eseguire e premi \texttt{command\ +\ invio} (MacOs) o \texttt{Ctrl+R} (Windows). Automaticamente il comando verà copiato nella \emph{Console} ed eseguito. In alternativa potrai premere il tasto \textbf{Run} indicato dalla freccia in Figura \ref{fig:script-run}.

\begin{figure}

{\centering \includegraphics[width=0.95\linewidth]{images/script-run} 

}

\caption{Esecuzione di un comando da script premi `command + invio` (MacOs)/ `Ctrl+R` (Windows) o premi il tasto indicato dalla freccia}\label{fig:script-run}
\end{figure}

\begin{tip}[Commenti]

Se hai guardato con attenzione lo script rappresentato in Figura \ref{fig:script-run}, potresti aver notato delle righe di testo verde precedute dal simbolo \texttt{\#}. Questo simbolo può essere utlizzato per inserire dei \emph{commenti} all'interno dello script. R ignorerà qualsiasi commento ed eseguirà soltato le parti di codici.

L'utilizzo dei commenti è molto importante nel caso di script complessi poichè ci permette di spiegare e documentare il codice che viene eseguito. Nel Capitolo TODO approfondiremo il loro utilizzo.

\end{tip}

\begin{design}[Creare e Salvare uno Script]

Per creare un nuovo script è sufficiente premere il pulsante in alto a sinistra come mostrato in Figura e selezionare \emph{``R Script''}.

\includegraphics[width=0.75\textwidth,height=\textheight]{images/script-new.png}

Unn nuovo script senza nome verrà creato. Per salvare lo script premere l'icona del floppy e indicare il nome. Ricorda di usare l'estensione ``\textbf{.R}'' per salvare gli script.

\includegraphics[width=0.75\textwidth,height=\textheight]{images/script-save.png}

\end{design}

\hypertarget{environment-e-history-la-sessione-di-lavoro}{%
\subsubsection*{3. Environment e History: la sessione di lavoro}\label{environment-e-history-la-sessione-di-lavoro}}
\addcontentsline{toc}{subsubsection}{3. Environment e History: la sessione di lavoro}

Qui sono presentati una serie di pannelli utili per valutare informazioni inerenti alla propria sessione di lavoro. I pannelli principali sono \emph{Environment} e \emph{History} (gli altri pannelli presenti in Figura \ref{fig:environment} riguardanno funzioni avanzate di RStudio).

\begin{itemize}
\tightlist
\item
  \textbf{Environment}: elenco tutti gli oggetti e variabili attualmente presenti nel'ambiente di lavoro. Approfondiremo i concetti di variabili e di ambiente di lavoro rispettivamente nel Capitolo \ref{objects-functions} e Capitolo TODO.
\end{itemize}

\begin{figure}

{\centering \includegraphics[width=0.6\linewidth]{images/environment} 

}

\caption{*Environment* - Elenco degli oggetti e variabili presenti nel'ambiente di lavoro}\label{fig:environment}
\end{figure}

\begin{itemize}
\tightlist
\item
  \textbf{History}: elenco di tutti i comandi precedentemente eseguiti nella console. Nota che questo no equivale ad uno script, anzi, è semplicemente un elenco non modificabile (e quasi mai usato).
\end{itemize}

\hypertarget{file-plots-package-help-system-management}{%
\subsubsection*{4. File, Plots, Package, Help: system management}\label{file-plots-package-help-system-management}}
\addcontentsline{toc}{subsubsection}{4. File, Plots, Package, Help: system management}

In questa parte sono raccolti una serie di pannelli utilizzatti per interfacciarsi con ulteriori risorse del sistema (e.g., file e pacchetti) o produrre output quali grafici e tabelle.

\begin{itemize}
\tightlist
\item
  \textbf{Files}: pannello da cui è possibile navigare tra tutti i file del proprio computer
\end{itemize}

\begin{figure}

{\centering \includegraphics[width=0.6\linewidth]{images/files} 

}

\caption{*Files* - permette di navigare tra i file del proprio computer}\label{fig:files}
\end{figure}

\begin{itemize}
\tightlist
\item
  \textbf{Plots}: pannello i cui vengono prodotti i grafici e che è possibil esportare cliccando \emph{Export}.
\end{itemize}

\begin{figure}

{\centering \includegraphics[width=0.6\linewidth]{images/plots} 

}

\caption{*Plots* - presentazione dei grafici}\label{fig:plots}
\end{figure}

\begin{itemize}
\tightlist
\item
  \textbf{Packages}: elenco dei pacchetti di R (questo argomento verrà approfondito nel Capitolo TODO).
\end{itemize}

\begin{figure}

{\centering \includegraphics[width=0.6\linewidth]{images/packages} 

}

\caption{*Packages* - elenco dei pacchetti di R}\label{fig:packages}
\end{figure}

\begin{itemize}
\tightlist
\item
  \textbf{Help}: utilizzato per navigare la documentazione interna di R (questo argomento verrà approfondito nel Capitolo TODO).
\end{itemize}

\begin{figure}

{\centering \includegraphics[width=0.6\linewidth]{images/help} 

}

\caption{*Help* -  documentazione di R}\label{fig:help}
\end{figure}

\begin{tip}[Personalizza tema e layout]

RStudio permette un ampio grado di personalizzazione dell'intrafaccia grafica utilizzata. E' possibile cambiare tema, font e disposizione dei pannelli a seconda dei tuoi gusti ed esigenze.

Prova a cambiare il tema dell editor in \emph{Idle Fingers} per utlizzare on background scuro che affatichi meno la vista (vedi Figura seguente). Clicca su RStudio \textgreater{} Preferenze \textgreater{} Appearence (MacOS) o Tools \textgreater{} Options \textgreater{} Appearence (Windows).

\begin{center}\includegraphics[width=0.9\linewidth]{images/dark-theme} \end{center}

\end{tip}

\hypertarget{first-comands}{%
\chapter{Primi Passi in R}\label{first-comands}}

Ora che abbiamo iniziato a famigliarizzare con il nostro stumento di lavoro possiamo finalmente dare fuoco alle polveri e concentraci sulla scrittura di codici!

In questo capitolo muoveremo i primi passi in R. Inizieremo vedendo come utilizzare operatori matematici, relazionali e logici per compiere semplici operazioni in R. Imparare R è un lungo percorso (scoop: questo percorso non termina mai dato che R è sempre in continuo sviiluppo). Soprattutto all'inizio può sembrare eccessivamente difficile poichè è si incontrano per la prima volta molti comandi e concetti di programmazione. Tuttavia, una volta famigliarizzato con gli apetti di base, la progressione diventa sempre più veloce (inarrestabile direi!).

In questo capitolo introdurremo per la prima volta molti elementi che saranno poi ripresi e approfonditi nei seguenti capitoli. Quindi non preoccuparti se non tutto ti sarà chiaro fin da subito. Imparare il tuo primo linguaggio di programmazione è difficile ma da qualche parte bisogna pure iniziare. Pronto per le tue prime linee di codice? Let's become a useR!

\hypertarget{math-operators}{%
\section{Operatori Matematici}\label{math-operators}}

R è un'ottima calcolatrice. Nella Tabella \ref{tab:table-math-operators} sono elencati i principali operatori matematici e funzioni usate in R.

\begin{table}[!h]

\caption{\label{tab:table-math-operators}Operatori Matematici}
\centering
\begin{tabular}[t]{l|l|l}
\hline
Funzione & Nome & Esempio\\
\hline
\texttt{x + y} & Addizione & \texttt{\makecell[l]{> 5 + 3 \\{[1]} 8}}\\
\hline
\texttt{x - y} & Sottrazione & \texttt{\makecell[l]{> 7 - 2 \\{[1]} 5}}\\
\hline
\texttt{x * y} & Moltiplicazione & \texttt{\makecell[l]{> 4 * 3 \\{[1]} 12}}\\
\hline
\texttt{x / y} & Divisione & \texttt{\makecell[l]{> 8 / 3 \\{[1]} 2.666667}}\\
\hline
\texttt{x \%\% y} & Resto della divisione & \texttt{\makecell[l]{> 7 \%\% 5 \\{[1]} 2}}\\
\hline
\texttt{x \%/\% y} & Divisione intera & \texttt{\makecell[l]{> 7 \%/\% 5 \\{[1]} 1}}\\
\hline
\texttt{x \^{} y} & Potenza & \texttt{\makecell[l]{> 3\^{}3 \\{[1]} 27}}\\
\hline
\texttt{abs(x)} & Valore assoluto & \texttt{\makecell[l]{> abs(3-5\^{}2) \\{[1]} 22}}\\
\hline
\texttt{sign(x)} & Segno di un'espressione & \texttt{\makecell[l]{> sign(-8) \\{[1]} -1}}\\
\hline
\texttt{sqrt(x)} & Radice quadrata & \texttt{\makecell[l]{> sqrt(25) \\{[1]} 5}}\\
\hline
\texttt{log(x)} & Logaritmo naturale & \texttt{\makecell[l]{> log(10) \\{[1]} 2.302585}}\\
\hline
\texttt{exp(x)} & Esponenziale & \texttt{\makecell[l]{> exp(1) \\{[1]} 2.718282}}\\
\hline
\texttt{\makecell[l]{sin(x)\\cos(x)\\tan(x)\\asin(x)\\acos(x)\\atan(x)}} & Funzioni trigonometriche & \texttt{\makecell[l]{ >sin(pi/2) \\{[1]}1 \\>cos(pi/2) \\{[1]}6.123234e-17}}\\
\hline
\texttt{factorial(x)} & Fattoriale & \texttt{\makecell[l]{> factorial(6) \\{[1]} 720}}\\
\hline
\texttt{choose(n, k)} & Coefficiente binomiale & \texttt{\makecell[l]{> choose(5,3) \\{[1]} 10}}\\
\hline
\end{tabular}
\end{table}

\begin{tip}[Le prime funzioni]

Nota come per svolgere operazioni come la radice quadrata o il valore assoluto vengono utlizzate delle specifiche funzioni. In R le funzioni sono richiamate digitando \texttt{\textless{}nome-funnzione\textgreater{}()} (e.g., \texttt{sqrt(25)}) indicando all'interno delle parentesi tonde gli argomenti della funzione. Approfondiremo le funzioni nel Capitolo \ref{functions-def}.

\end{tip}

\hypertarget{ordine-operazioni}{%
\subsection{Ordine Operazioni}\label{ordine-operazioni}}

Nello svolgere le operazioni, R segue lo stesso l'ordine usato nelle normali espressioni matematiche. Quindi l'ordine di precedenza degli operatori è:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  \texttt{\^{}} (potenza)
\item
  \texttt{\%\%} (resto della divisione) e \texttt{\%/\%} (divisione intera)
\item
  \texttt{*} (moltiplicazione) e \texttt{/}(divisione)
\item
  \texttt{+} (addizione) e \texttt{-}(sotttrazione)
\end{enumerate}

Nota che in presenza di funzioni (e.g., \texttt{abs()}, \texttt{sin()}), R per prima cosa sostituisca le funzioni con il loro risultato per poi procedere con l'esecuzione delle operazioni nell'ordine indicato precedentemente.

L'ordine di esecuzione delle operazioni può essere controllato attraverso l'uso delle \textbf{parentesi tondone} \texttt{()}. R eseguirà tutte le operazioni incluse nelle parentesi seguendo lo stesso ordine inndicato sopra. Utilizzando più gruppi di parentesi possiamo ottenere i risultati desiderati.

\begin{warning}[Le parentesi]

Nota che in R solo le \textbf{parentesi tonde} \texttt{()} sono utilizzate per gestire l'ordine con cui sono eseguite le oprazioni.

\textbf{Parentesi quadre} \texttt{{[}{]}} e \textbf{parentesi graffe} \texttt{\{\}} sono invece speciali operatori utilizzati in R per altre ragioni come la selezione di elemente e la definizione di blocchi di codici. Argomenti che approfondiremo rispettivamente nel Capitolo TODO e Capitolo TODO.

\end{warning}

\hypertarget{esercizi}{%
\subsection*{Esercizi}\label{esercizi}}
\addcontentsline{toc}{subsection}{Esercizi}

Calcola il risultato delle seguenti operazioni utilizzando R (\href{https://github.com/psicostat/Introduction2R/blob/master/exercises/chapter-03.R}{soluzioni}):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \(\frac{(45+21)^3+\frac{3}{4}}{\sqrt{32-\frac{12}{17}}}\)
\item
  \(\frac{\sqrt{7-\pi}}{3\ (45-34)}\)
\item
  \(\sqrt[3]{12-e^2}+\ln(10\pi)\)
\item
  \(\frac{\sin(\frac{3}{4}\pi)^2+\cos(\frac{3}{2}\pi)}{\log_7{e^{\frac{3}{2}}}}\)
\item
  \(\frac{\sum_{n=1}^{10} n}{10}\)
\end{enumerate}

Note per la risoluzione degli esercizi:

\begin{itemize}
\tightlist
\item
  In R la radice quadrata si ottine con la funzione \texttt{sqrt()} mentre per radici di indici diversi si utilizza la notazione esponenziale (\(\sqrt[3]{x}\) è dato da \texttt{x\^{}(1/3)}).
\item
  Il valore di \(\pi\) si ottiene con \texttt{pi}.
\item
  Il valore di \(e\) si ottiene con \texttt{exp(1)}.
\item
  In R per i logaritmi si usa la funzione \texttt{log(x,\ base=a)}, di base viene considerato il logaritmo naturale.
\end{itemize}

\hypertarget{operatori-relazionali-e-logici}{%
\section{Operatori Relazionali e Logici}\label{operatori-relazionali-e-logici}}

Queste operazioni al momento potrebbero sembrare non particolrmente interessanti ma si riveleranno molto utili nei capitoli successivi ad esempio per la selezione di elementi (vedi Capitolo TODO) o la definizionne di algoritmi (vedi Capitolo TODO).

\hypertarget{operatori-relazionali}{%
\subsection{Operatori Relazionali}\label{operatori-relazionali}}

In R è possibile valutare se una data relazione è vera o fasa. Ad esempio, posiamo valutare se ``\emph{2 è minore di 10}'' o se ``\emph{4 numero è un numero pari}''.

R valuterà le proposizioni e ci restituirà il valore \texttt{TRUE} se la proposizione è vera oppure \texttt{FALSE} se la proposizione è falsa. Nella Tabella \ref{tab:relational-operators} sono elencati gli operatori relazionali.

\begin{table}[!h]

\caption{\label{tab:relational-operators}Operatori Relazionali}
\centering
\begin{tabular}[t]{l|l|l}
\hline
Funzione & Nome & Esempio\\
\hline
\texttt{x == y} & Uguale & \texttt{\makecell[l]{> 5 == 3 \\{[1]} FALSE}}\\
\hline
\texttt{x != y} & Diverso & \texttt{\makecell[l]{> 7 != 2 \\{[1]} TRUE}}\\
\hline
\texttt{x > y} & Maggiore & \texttt{\makecell[l]{> 4 > 3 \\{[1]} TRUE}}\\
\hline
\texttt{x >= y} & Maggiore o uguale & \texttt{\makecell[l]{> -2 >= 3 \\{[1]} FALSE}}\\
\hline
\texttt{x < y} & Minore & \texttt{\makecell[l]{> 7 < 5 \\{[1]} FALSE}}\\
\hline
\texttt{x <= y} & Minore o uguale & \texttt{\makecell[l]{> 7 <= 7 \\{[1]} TRUE}}\\
\hline
\texttt{x \%in\% y} & inclusione & \texttt{\makecell[l]{> 5 \%in\% c(3, 5, 8) \\{[1]} TRUE}}\\
\hline
\end{tabular}
\end{table}

\begin{warning}['==' non è uguale a '=']

Attenzione che per valutare l'uguaglianza tra due valori non bisogna utilizzare \texttt{=} ma \texttt{==}. Questo è un'errore molto comune ceh si commmette in continuazione.

L'operatore \texttt{=} è utilizzato in R per assegnare un valore ad una variablie. Argomento che vederemo nella Sezione TODO

\end{warning}

\begin{tip}[TRUE-T-1; FALSE-F-0]

Nota che in qualsiasi linguaggio di Programmazione, ai valori TRUE e FALSE sono associati rispettivament i valori numerici 1 e 0. Questi sono definiti \href{https://it.wikipedia.org/wiki/Variabile_booleana}{valori booleani}.

\begin{Shaded}
\begin{Highlighting}[]
\OtherTok{TRUE} \OperatorTok{==}\StringTok{ }\DecValTok{1}   \CommentTok{# TRUE}
\OtherTok{TRUE} \OperatorTok{==}\StringTok{ }\DecValTok{2}   \CommentTok{# FALSE}
\OtherTok{TRUE} \OperatorTok{==}\StringTok{ }\DecValTok{0}   \CommentTok{# FALSE}
\OtherTok{FALSE} \OperatorTok{==}\StringTok{ }\DecValTok{0}  \CommentTok{# TRUE}
\OtherTok{FALSE} \OperatorTok{==}\StringTok{ }\DecValTok{1}  \CommentTok{# FALSE}
\end{Highlighting}
\end{Shaded}

In R è possibile anche abbreviare TRUE e FALSE rispettivamente in T e F, sebbene sia una pratica non consigliata poichè potrebbe nonn essere chiara e creare fraintendimenti. Infatti mentre TRUE e FALSE sono parole riservate (vedi Capitolo TODO) T a F non lo sono.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{T }\OperatorTok{==}\StringTok{ }\DecValTok{1}      \CommentTok{# TRUE}
\NormalTok{T }\OperatorTok{==}\StringTok{ }\OtherTok{TRUE}   \CommentTok{# TRUE}
\NormalTok{F }\OperatorTok{==}\StringTok{ }\DecValTok{0}      \CommentTok{# TRUE}
\NormalTok{F }\OperatorTok{==}\StringTok{ }\OtherTok{FALSE}  \CommentTok{# TRUE}
\end{Highlighting}
\end{Shaded}

\end{tip}

\hypertarget{operatori-logici}{%
\subsection{Operatori Logici}\label{operatori-logici}}

In R è possibile congiungere più relazioni per valutare una desiderata proposizione. Ad esempio potremmo valutare se ``\emph{17 è maggiore di 10 e minore di 20}''. Per unire più relazioni in un'unica proposizione che R valuterà come \texttt{TRUE} o \texttt{FALSE}, vengono utilizati gli operatori logici riportati in Tabella \ref{tab:logical-operators}.

\begin{table}[!h]

\caption{\label{tab:logical-operators}Operatori Logici}
\centering
\begin{tabular}[t]{l|l|l}
\hline
Funzione & Nome & Esempio\\
\hline
\texttt{!x} & Negazione & \texttt{\makecell[l]{> !TRUE \\{[1]} FALSE}}\\
\hline
\texttt{x \& y} & Congiunzione & \texttt{\makecell[l]{> TRUE \& FALSE \\{[1]} FALSE}}\\
\hline
\texttt{x | y} & Disgiunzione Inclusiva & \texttt{\makecell[l]{> TRUE | FALSE \\{[1]} TRUE}}\\
\hline
\end{tabular}
\end{table}

Questi operatori sono anche definiti \href{https://it.wikipedia.org/wiki/Espressione_booleana}{operatori booleani} e seguono le comuni definizioni degli operatori logici. In particolare abbiamo che:

\begin{itemize}
\tightlist
\item
  Nel caso della \textbf{congiunzione logica} \texttt{\&}, affinchè la proposizione sia vera è necessario che entrambe le relazioni siano vere. Negli altri casi la proposizione sarà valutarta falsa (vedi Tabella \ref{tab:and-operator}).
\end{itemize}

\begin{table}[!h]

\caption{\label{tab:and-operator}Congiunzione '\&'}
\centering
\begin{tabular}[t]{>{}l|>{}l|>{}l}
\hline
x & y & x \textbackslash{}\& y\\
\hline
TRUE & TRUE & TRUE\\
\hline
TRUE & FALSE & FALSE\\
\hline
FALSE & TRUE & FALSE\\
\hline
FALSE & FALSE & FALSE\\
\hline
\end{tabular}
\end{table}

\begin{itemize}
\tightlist
\item
  Nel caso della \textbf{disgiunzione inclusiva logica} \texttt{\textbar{}}, affinchè la proposizione sia vera è necessario che almeno una relaziona sia vera. La proposizione sarà valutarta falsa solo quando entrambe le relazioni sono false (vedi Tabella \ref{tab:or-operator}).
\end{itemize}

\begin{table}[!h]

\caption{\label{tab:or-operator}Disgiunzione inclusiva '|'}
\centering
\begin{tabular}[t]{>{}l|>{}l|>{}l}
\hline
x & y & x | y\\
\hline
TRUE & TRUE & TRUE\\
\hline
TRUE & FALSE & TRUE\\
\hline
FALSE & TRUE & TRUE\\
\hline
FALSE & FALSE & FALSE\\
\hline
\end{tabular}
\end{table}

\begin{design}[Disgiunzione esclusiva]

Per completezza ricordiamo che tra gli operatori logici esiste anche la \textbf{disgiunzione esclusiva}. La proposizione sarà valutata falsa se entrambe le relazioni sono vere oppure false. Affinchè la proposizione sia valutata vera una sola delle relazioni deve essere vera mentre l'altra deve essere falsa.

In R la disgiunzione esclusiva tra due ralazioni (x e y) è indicata con la funzione \texttt{xor(x,\ y)}. Tuttavia tale funzione è raramente usata.

\begin{longtable}[]{@{}lll@{}}
\caption{Disgiunzione esclusiva `xor(x, y)'}\tabularnewline
\toprule
x & y & xor(x, y)\tabularnewline
\midrule
\endfirsthead
\toprule
x & y & xor(x, y)\tabularnewline
\midrule
\endhead
TRUE & TRUE & FALSE\tabularnewline
TRUE & FALSE & TRUE\tabularnewline
FALSE & TRUE & TRUE\tabularnewline
FALSE & FALSE & FALSE\tabularnewline
\bottomrule
\end{longtable}

\end{design}

\hypertarget{ordine-valutazione-relazioni}{%
\subsection{Ordine valutazione relazioni}\label{ordine-valutazione-relazioni}}

Nel valutare le veridicità delle proposizioni R esegue le operazioni nel seguente ordine:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  operatori matematici (e.g., \texttt{\^{}}, \texttt{*}, \texttt{/}, \texttt{+}, \texttt{-}, etc.)
\item
  operatori relazionali (e.g., \texttt{\textless{}}, \texttt{\textgreater{}}, \texttt{\textless{}=}, \texttt{\textgreater{}=}, \texttt{==}, \texttt{!=})
\item
  operatori logici (e.g., \texttt{!}, \texttt{\&}, \texttt{\textbar{}})
\end{enumerate}

La lista completa dell'ordine di esecuzione delle operazioni è riportata al seguente link \url{https://stat.ethz.ch/R-manual/R-devel/library/base/html/Syntax.html}. Ricordiamo che, in caso di dubbi riguardanti l'ordine di esecuzione delle operazioni, la cosa migliore è utilizzare le parentesi tonde \texttt{()} per disambiguare ogni possibile fraintendimento.

\begin{warning}[L'operatore '\%in\%']

Nota che l'operatore \texttt{\%in\%} che abbiamo precedentemente indicato tra gli operatori relazionali in realtà è un operatore speciale. In particolare, non segue le stesse regole degli altri operatori relazionlali per quanto riguarda l'ordine di esecuzione.

La soluzione migliore? Usa le parentesi!

\end{warning}

\hypertarget{esercizi-1}{%
\subsection*{Esercizi}\label{esercizi-1}}
\addcontentsline{toc}{subsection}{Esercizi}

Esegui i seguenti esercizi utilizzando gli operatori relazionali e logici (\href{https://github.com/psicostat/Introduction2R/blob/master/exercises/chapter-03.R}{soluzioni}):

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Definisici due relazioni false e due vere che ti permettano di valutare i risultati di tutti i possibili incroci che puoi ottenere con gli operatori logici \texttt{\&} e \texttt{\textbar{}}.
\item
  Definisci una proposizione che ti permetta di valutare se un numero è pari. Definisci un'altra proposizione per i nueri dispari (tip: cosa ti ricorda \texttt{\%\%}?).
\item
  Definisci una proposizione per valutare la seguente condizione (ricordati di testare tutti i possibili scenari) ``\emph{x è un numero compreso tra -4 e -2 oppure è un numero compreso tra 2 e 4}''.
\item
  Esegui le seguenti operazioni \texttt{4\ \^{}\ 3\ \%in\%\ c(2,3,4)} e \texttt{4\ *\ 3\ \%in\%\ c(2,3,4)}. Cosa osservi nell'ordine di esecuzione degli operatori?
\end{enumerate}

\hypertarget{objects-functions}{%
\chapter{Due Compagni Inseparabili}\label{objects-functions}}

In questo capitolo introdurremmo i concetti di oggetti e funzioni, due elementi alla base di R (e di ogni linguaggio di programmazione). Potremmo pensare agli oggetti in R come a delle variabili che ci permettono di mantenere in memoria dei valori (e.g., i risultati dei nostri calcoli o i nostri dati). Le funzioni in R, invece, sono analoghe a delle funzioni matematiche che, ricevuti degli oggetti in input, compiono delle azioni e restituiscono dei nuovi oggetti in output.

Questa è una iper-semplificazione (e pure tecnicamente non corretta) che ci permettere però di capire come, partendo dai nostri dati o valori iniziali, possiamo manipolarli applicando delle funzioni per ottenere, attraverso differenti step, i risultati desiderati (e.g., analisi statistiche o grafici e tabelle).

Qui valuteremo gli aspetti fondamentali riguardanti l'utilizzo degli oggetti e delle funzioni che saranno successivamente approfonditi rispettivamente nel corso della seconda e della terza sezione del libro (TODO).

\hypertarget{objects-section}{%
\section{Oggetti}\label{objects-section}}

Quando eseguiamo un commando in R, il risultato ottenuto viene immediatamente mostrato in \emph{Console}. Tale risultato, tuttavia, non viene salvato in memoria e quindi non potrà essere riutilizzato in nessuna operazione futura. Condurre delle analisi in questo modo sarebbe estremamente complicato ed inefficiente. La soluzione più ovvia è quella di salvare in memoria i nostri risultati intermedi per poterli poi riutilizzare nel corso delle nostre analisi. Si definisce questo processo come \emph{assegnare} un valore ad un oggetto.

\hypertarget{assegnare-e-richiamare-un-oggetto}{%
\subsection{Assegnare e Richiamare un oggetto}\label{assegnare-e-richiamare-un-oggetto}}

Per assegnare il valore numerico 5 all'oggetto \texttt{x} è necessario eseguire il seguente comando:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{5}
\end{Highlighting}
\end{Shaded}

La funzione \texttt{\textless{}-} ci permette di assegnare i valori che si trovano alla sua destra all'oggetto il cui nome è definito alla sinistra. Abbiamo pertanto il seguente pattern: \texttt{\textless{}nome-oggetto\textgreater{}\ \textless{}-\ \textless{}valore-assegnato\textgreater{}}.Notate come in \emph{Console} appaia solo il comando appena eseguito ma non venga mostrato alcun risultato.

Per utilizzare il valore contenuto nell'oggetto sarà ora sufficiente richiamare nel proprio codice il nome dell'oggetto desiderato.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x }\OperatorTok{+}\StringTok{ }\DecValTok{3}
\CommentTok{## [1] 8}
\end{Highlighting}
\end{Shaded}

E' inoltre possibile ``aggiornare'' o ``sostituire'' il valore contenuto in un oggetto. Ad esempio:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Aggiornare un valore}
\NormalTok{x <-}\StringTok{ }\NormalTok{x}\OperatorTok{*}\DecValTok{10}
\NormalTok{x}
\CommentTok{## [1] 50}

\CommentTok{# Sostituire un valore}
\NormalTok{x <-}\StringTok{ "Hello World!"}
\NormalTok{x}
\CommentTok{## [1] "Hello World!"}
\end{Highlighting}
\end{Shaded}

Nel primo caso, abbiamo utilizzato il vecchio valore contenuto in \texttt{x} per calcolare il nuovo risultato che è stato assegnato a \texttt{x}. Nel secondo caso, abbiamo sostituito il vecchio valore di \texttt{x} con un nuovo valore (nell'esempio una stringa di caratteri).

\begin{design}[Assegnare valori '<-' vs '=']

Esistono due operatori principali che sono usati per assegnare un valore ad un oggetto: l'operatore \texttt{\textless{}-} e l'operatore \texttt{=}. Entrambi sono validi e spesso la scelta tra i due diventa solo una questione di stile personale.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x_}\DecValTok{1}\NormalTok{ <-}\StringTok{ }\DecValTok{45}
\NormalTok{x_}\DecValTok{2}\NormalTok{ =}\StringTok{ }\DecValTok{45}

\NormalTok{x_}\DecValTok{1} \OperatorTok{==}\StringTok{ }\NormalTok{x_}\DecValTok{2} 
\CommentTok{## [1] TRUE}
\end{Highlighting}
\end{Shaded}

Esistono, tuttavia, alcune buone ragioni per preferire l'uso di \texttt{\textless{}-} rispetto a \texttt{=} (attenti a non confonderlo con l'operatore relazionale \texttt{==}). L'operazione di assegnazione è un'operazione che implica una direzionalità, il chè è reso esplicito dal simbolo \texttt{\textless{}-} mentre il simbolo \texttt{=} non evidenzia questo aspetto e anzi richiama la relazione di uguaglianza in matematica.

La decisione su quale operatore adottare è comunque libera, ma ricorda che una buona norma nella programmazione riguarda la \emph{consistenza}: una volta presa una decisione è bene mantenerla per facilitare la comprensione del codice.

\end{design}

\hypertarget{objects-names}{%
\subsection{Nomi degli oggetti}\label{objects-names}}

La scelta dei nomi degli oggetti sembra un aspetto secondario ma invece ha una grande importanza per facilitare la chiarezza e la comprensione dei codici.

Ci sono alcune regole che discriminano nomi validi da nomi non validi. Il nome di un oggetto:

\begin{itemize}
\tightlist
\item
  deve iniziare con una lettera e può contenere lettere, numeri, underscore (\texttt{\_}), o punti (\texttt{.}).
\item
  potrebbe anche iniziare con un punto (\texttt{.}) ma in tal caso non può essere seguito da un numero.
\item
  non deve contenere caratteri speciali come \texttt{\#}, \texttt{\&}, \texttt{\$}, \texttt{?}, etc.
\item
  non deve essere una parola riservata ovvero quelle parole che sono utilizzate da R con un significato speciale (e.g, \texttt{TRUE}, \texttt{FALSE}, etc.; esegui il comando \texttt{?reserved} per la lista di tutte le parole riservate in R).
\end{itemize}

\begin{warning}[CaSe-SeNsItIvE]

Nota come R sia \textbf{Case-Sensitive}, ovvero distingua tra lettere minuscole e maiuscole. Nel seguente esempio i due nomi sono considerate diversi e pertanto non avviene una sovrascrizione ma due differenti oggetti sono creati:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{My_name <-}\StringTok{ "Monty"}
\NormalTok{my_name <-}\StringTok{ "Python"}

\NormalTok{My_name}
\CommentTok{## [1] "Monty"}
\NormalTok{my_name}
\CommentTok{## [1] "Python"}
\end{Highlighting}
\end{Shaded}

\end{warning}

Inoltre, il nome ideale di un oggetto dovrebbe essere:

\begin{itemize}
\tightlist
\item
  \textbf{auto-descrittivo}: dal solo nome dovrebbe essere possibile intuire il contenuto dell'oggetto. Un nome generico quale \texttt{x} o \texttt{y} ci sarebbero di poco aiuto poichè potrebbero contenere qualsiasi informazione. Invece un nome come \texttt{weight} o \texttt{gender} ci suggerirebbe chiaramente il contenuto dell'oggetto (e.g., il peso o il gender dei partecipanti del nostro studio).
\item
  \textbf{della giusta lunghezza}: non deve essere ne troppo breve (evitare sigle incomprensibili) ma neppure troppo lunghi. La lunghezza corretta è quella che permette al nome di esssere sufficientemente informativo senza aggiungere inutili dettagli. In genere sono sufficienti 2 o 3 parole.
\end{itemize}

\begin{design}[CamelCase vs snake\_case]

Spesso più parole sono usate per ottenere un nome sufficientemente chiaro. Dato che però non è possibile includere spazi in un nome, nasce il problema di come unire più parole senza che il nome diventi incomprensibile, ad esempio \texttt{mediatestcontrollo}.

Esistono diverse convenzioni tra cui:

\begin{itemize}
\tightlist
\item
  \textbf{CamelCase}. L'inizio di una nuova parole viene indicata con l'uso della prima lettera maiuscola. Ad esempio \texttt{mediaTestControllo}.
\item
  \textbf{snake\_case}. L'inizio di una nuova parola viene indicata con l'uso carattere \texttt{\_}. Ad esempio \texttt{media\_test\_controllo}.
\item
  una variante al calssico \textbf{snake\_case} riguarda l'uso del \texttt{.}, ad esempio \texttt{media.test.controllo}. Questo approccio in genere è evitato poichè in molti linguaggi di progtrammazione (ed anche in R in alcune condizioni) il carattere \texttt{.} è un carattere speciale.
\end{itemize}

In genere viene raccomandato di seguire la convenzione \textbf{snake\_case}. Tuttavia, la decisione su quale convenzione adottare è libera, ma ricorda ancora che una buona norma nella programmazione riguarda la \emph{consistenza}: una volta presa una decisione è bene mantenerla per facilitare la comprensione del codice.

\end{design}

\hypertarget{tipologie-dati-e-strutture-dati}{%
\subsection{Tipologie Dati e Strutture Dati}\label{tipologie-dati-e-strutture-dati}}

Per lavorare in modo ottimale in R, è fondamentale conoscere bene e distinuere chiaramente quali sono le tipologie di dati e le strutture degli oggetti usati.

In R abbiamo 4 principali tipologie di dati, ovvero tipologie di valori che possono essere utilizzati:

\begin{itemize}
\tightlist
\item
  \texttt{character} - \emph{Stringhe di caratteri} i cui valori alfannumerici vengono delimitati dalle doppie vigolette \texttt{"Hello\ world!"} o virgolette singole \texttt{\textquotesingle{}Hello\ world!\textquotesingle{}}.
\item
  \texttt{double} - \emph{Valori numerici} con o senza cifre decimali ad esempio \texttt{27} o \texttt{93.46}.
\item
  \texttt{integer} - \emph{Valori interi} definiti apponendo la lettera \texttt{L} al numero desiderato, ad esempio \texttt{58L}.
\item
  \texttt{logical} - \emph{Valori logici} \texttt{TRUE} e \texttt{FALSE} usati nelle operazioni logiche.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{typeof}\NormalTok{(}\StringTok{"Psicostat"}\NormalTok{)}
\CommentTok{## [1] "character"}
\KeywordTok{typeof}\NormalTok{(}\FloatTok{24.04}\NormalTok{)}
\CommentTok{## [1] "double"}
\KeywordTok{typeof}\NormalTok{(1993L)}
\CommentTok{## [1] "integer"}
\KeywordTok{typeof}\NormalTok{(}\OtherTok{TRUE}\NormalTok{)}
\CommentTok{## [1] "logical"}
\end{Highlighting}
\end{Shaded}

In R abbiamo inoltre differenti tipologie di oggetti, ovvero diverse strutture in cui possono essere organizzati i dati:

\begin{itemize}
\tightlist
\item
  \textbf{Vettori}
\item
  \textbf{Matrici}
\item
  \textbf{Dataframe}
\item
  \textbf{Liste}
\end{itemize}

Approfondiremo la loro definizione, le loro caratteristiche ed il loro utilizzo nel corso di tutta la seconda sezione di questo libro TODO.

\hypertarget{functions-def}{%
\section{Funzioni}\label{functions-def}}

Possiamo pensare alle funzioni in R in modo analogo alle classiche funzioni matematiche. Dati dei valori in input, le funzioni eseguono dei specifici calcoli e restituiscono in output il risultato ottenuto.

\includegraphics[width=0.95\textwidth,height=\textheight]{images/functions-graph.png}

Abbiamo già incontrato le nostre prime funzioni per eseguire specifiche operazioni matematiche nel Capitolo \ref{math-operators} come ad esempio \texttt{sqrt()} o \texttt{abs()} usate per ottenere ripettivamente la radice quadrata o il valore assoluto di un numero. Ovviamente le funzioni in R non sono limitate ai soli calcoli matematici ma possono eseguire qualsiasi genere di compito come ad esempio creare grafici e tabelle o manipolare dei dati o dei file. Tuttavia il concetto rimane lo stesso: ricevuti degli oggetti in input, le funzioni compiono determinate azioni e restituiscono dei nuovi oggetti in output.

In realtà incontreremo delle funzioni che non richiedono input o non produrre degli output. Ad esempio \texttt{getwd()} non richiede input oppure la funzione \texttt{rm()} non produce output. Tuttavia questo accade nella minoranza dei casi.

Per eseguire una funzione in R è necessario digitare il nome della funzione ed indicare tra parentesi i valori che vogliamo assegnare agli \textbf{argomenti} della funzione, ovvero i nostri input, separati da virgole. Generalmente si utilizza quindi la seguente sintassi:

\texttt{\textless{}nome-funzione\textgreater{}(\textless{}nome-arg1\textgreater{}\ =\ \textless{}valore-arg1\textgreater{},\ \textless{}nome-arg2\textgreater{}\ =\ \textless{}valore-arg2\textgreater{},...)}

{}

Ad esempio per creare una sequenza di valori con incrementi di 1 posso usare la funzione \texttt{seq()}, i cui argomenti sono \texttt{from} e \texttt{to} ed indicano rispettivamente il valore iniziale ed il valore massimo della sequenza.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# creo una sequenza di valori da 0 a 10 con incrementi di 1}
\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{, }\DataTypeTok{to =} \DecValTok{10}\NormalTok{)}
\CommentTok{##  [1]  0  1  2  3  4  5  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}

\hypertarget{function-arguments}{%
\subsection{Argomenti di una Funzione}\label{function-arguments}}

Nel definire gli argomenti di una funzione non è necessario specificare il nome degli argomenti. Ad esempio il comando precedente può essere eseguito anche specificando solamente i valori.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# creo una sequenza di valori da 0 a 10 con incrementi di 1}
\KeywordTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{)}
\CommentTok{##  [1]  0  1  2  3  4  5  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}

Tuttavia, questo rende più difficile la lettura e la comprensione del codice poichè non è chiaro a quali argomenti si riferiscono i valori. L'ordine con cui vengono definiti i valori in questo caso è iportante, poichè R assume rispetti l'ordine prestabilito degli argomenti. Osserva come invertendo invertendo i valori ovviamente otteniamo risultati differenti da quelli precedenti, ma questo non avviene quando il nome dell'argomento è specificato.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# inverto i valori senza i nomi degli argomenti}
\KeywordTok{seq}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{0}\NormalTok{)}
\CommentTok{##  [1] 10  9  8  7  6  5  4  3  2  1  0}

\CommentTok{# inverto i valori con i nomi degli argomenti}
\KeywordTok{seq}\NormalTok{(}\DataTypeTok{to =} \DecValTok{10}\NormalTok{, }\DataTypeTok{from =} \DecValTok{0}\NormalTok{)}
\CommentTok{##  [1]  0  1  2  3  4  5  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}

Vediamo inoltre come le funzioni possano avere molteplici argomenti, ma che non sia necessario specificare il valore per ognuno di essi. Molti argomenti, infatti, hanno già dei valori prestabiliti di \emph{default} e non richiedo quindi di essere specificati almeno che ovviamente non si vogliano utilizzare impostazioni diverse da quelle di \emph{default}. Oppure lo specificare un dato argomento rispetto ad un altro può definire il comportamento stesso della funzione.

Ad esempio la funzione \texttt{seq()} possiede anche gli argomenti \texttt{by} e \texttt{length.out} che prima non erano stati specificati. \texttt{by} permette di definire l'incremento per ogni elemento successivo della sequenza mentre \texttt{length.out} permette di definire il numero di elementi della sequenza. Vediamo come allo specificare dell'uno o dell'altro agromento (o di entrambi) il comportamento della funzione vari.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{,  }\DataTypeTok{to =} \DecValTok{10}\NormalTok{, }\DataTypeTok{by =} \DecValTok{5}\NormalTok{)}
\CommentTok{## [1]  0  5 10}
\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{,  }\DataTypeTok{to =} \DecValTok{10}\NormalTok{, }\DataTypeTok{length.out =} \DecValTok{5}\NormalTok{)}
\CommentTok{## [1]  0.0  2.5  5.0  7.5 10.0}
\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{,  }\DataTypeTok{to =} \DecValTok{10}\NormalTok{, }\DataTypeTok{length.out =} \DecValTok{5}\NormalTok{, }\DataTypeTok{by =} \DecValTok{4}\NormalTok{)}
\CommentTok{## Error in seq.default(from = 0, to = 10, length.out = 5, by = 4): too many arguments}
\end{Highlighting}
\end{Shaded}

E' pertanto cosigliabile esplicitare sempre gli argomenti di una funzione per rendere chiaro a che cosa si riferiscono i valori indicati. Questo è utlile anche per evitare eventuali comportamenti non voluti delle funzioni ad individuare più facilmente possibili errori.

Gli argomenti di una funzione, inoltre, richiedono specifiche tipologie e strutture di dati e sta a noi assicuraci che i dati siano forniti nel modo corretto. Vediamo ad esempio come la funzione \texttt{mean()} che calcola la media di un insieme di valori, richieda come input un vettore di valori numerici. Approfondiremo il concetto di vettori nel Capitolo TODO, al momento ci basta sapere che possiamo usare la funzione \texttt{c()} per combinare più valori in un unico vettore.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Calcolo la media dei seguenti valori (numerici)}
\KeywordTok{mean}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{12}\NormalTok{)) }\CommentTok{# c() combina più valori in un unico vettore}
\CommentTok{## [1] 9}

\KeywordTok{mean}\NormalTok{(}\DecValTok{10}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{8}\NormalTok{, }\DecValTok{12}\NormalTok{)}
\CommentTok{## [1] 10}
\end{Highlighting}
\end{Shaded}

Notiamo come nel primo caso il risultato sia corretto mentre nel secondo è sbagliato. Questo perchè \texttt{mean()} richiede come primo argomento il vettore su cui calcolare la media. Nel primo caso abbiamo correttamente specificato il vettore di valori usando la funzione \texttt{c()}. Nel secondo caso invece, il primo argomento risulta essere solo il valore \texttt{10} ed R calcola la media di \texttt{10} ovvero \texttt{10}. Gli altri valori sono passati ad altri argomenti che non alterano il comportameto ma neppure ci segnalano di questo importante errore.

Nel seguente esempio, possiamo vedere come \texttt{mean()} richieda che i valori siano numerici. Seppur \texttt{"1"} \texttt{"2"}, e \texttt{"3"} siano dei numeri, l'utilizzo delle doppie virgolette li rende delle stringhe di caratteri e non dei valori numerici e giustamente R non può eseguire una media su dei caratteri.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Calcolo la media dei seguenti valori (caratteri)}
\KeywordTok{mean}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"1"}\NormalTok{, }\StringTok{"2"}\NormalTok{, }\StringTok{"3"}\NormalTok{))}
\CommentTok{## Warning in mean.default(c("1", "2", "3")): argument is not numeric or logical:}
\CommentTok{## returning NA}
\CommentTok{## [1] NA}
\end{Highlighting}
\end{Shaded}

Capiamo quindi che per usare correttamente le funzioni è fondamentale conoscerne gli argomenti e rispettare le tipologie e strutture di dati richieste.

\hypertarget{help-i-need-somebodyhelp}{%
\subsection{Help! I need Somebody\ldots Help!}\label{help-i-need-somebodyhelp}}

Conoscere tutte le funzioni e tutti i loro argomenti è impossibile. Per fortuna R ci viene in soccorso fornendoci per ogni funzione la sua documentazione. Qui vengono fornite tutte le informazioni riguardanti la finalità della funzione, la descrizione dei suoi argomenti, i dettagli riguardanti i suoi possibili utilizzi.

Per accedere alla documentazione possiamo utilizzare il comando \texttt{?\textless{}nome-funzione\textgreater{}} oppure \texttt{help(\textless{}nome-funzione\textgreater{})}. Ad esempio:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{?seq}
\KeywordTok{help}\NormalTok{(seq)}
\end{Highlighting}
\end{Shaded}

Una pagina si aprirà nel pannello ``Help'' in basso a destra con la documentazione della funzione in modo simile a quanto rappresentato in Figura \ref{fig:help-page}.

\begin{figure}

{\centering \includegraphics[width=0.85\linewidth]{images/help-seq} 

}

\caption{Help-page della funzione seq()}\label{fig:help-page}
\end{figure}

Il formato e le informazioni presenti nella pagina seguono delle norme comuni ma non obbligatorie. Infatti, non necessariamente vengono usati sempre tutti i campi e comunque all'autore delle funzioni è lasciato un certo grado di libertà nel personalizzare la documentazione. Tra i campi principali e più comunemente usati abbiamo:

\begin{itemize}
\tightlist
\item
  \textbf{Tiolo} - Titolo esplicativo della finalità della funzione\\
\item
  \textbf{Description} - Descrizione coincisa della funzione
\item
  \textbf{Usage} - Viene mostrata la struttura della funzione con i suoi argomenti e valori di default
\item
  \textbf{Arguments} - Elenco con la descrizione dettagliata di tutti gli argomenti. Qui troviamo per ogni argomento sia le opzioni utilizzabili ed il loro effetto, che la tipologia di valori richiesti
\item
  \textbf{Details} - Descrizione dettagliata della funzione considerando i casi di utilizzo ed eventuali note tecniche
\item
  \textbf{Value} - Descrizione dell'output dalla funzione. Qui troviamo sia la descrizione della struttura dei dati dell'output che la descrizione dei suei elementi utile per interpretare ed utilizzare i rsultati ottenuti
\item
  \textbf{See Also} - Eventuali link ad altre funzioni simili o in relazione con la nostra funzione
\item
  \textbf{Examples} - Esempi di uso della funzione
\end{itemize}

\hypertarget{ricerca-per-parola}{%
\subsubsection*{Ricerca per Parola}\label{ricerca-per-parola}}
\addcontentsline{toc}{subsubsection}{Ricerca per Parola}

Quando non si conosce esattamente il nome di una funzione o si vuole cercare tutte le funzioni e pagine che includono una certa parola, è possibile utilizzare il comando \texttt{??\textless{}parola\textgreater{}} oppure \texttt{help.search(\textless{}parola\textgreater{})}.

R eseguirà una ricerca tra tutta la documentazione disponibile è fornirà un elenco delle pagine che contengono la parola desiderata nel titolo o tra le keywords.

\begin{trick}[Autocompletamento with 'Tab']

La natura dei programmatori è essere pigri e smemorati. Per fortuna ogni \emph{code editor} che si rispetti (i.e., programma per la scrittura di codici) possiede delle utli funzioni di autocompletamento e suggerimento dei comandi che semplificano la scrittura di codici.

In Rstudio, i suggerimenti compaino automaticamente durante la scrittura di un comando oppure possono essere richiamati premendo il tasto \texttt{Tab} in alto a sinistra della tastiera ( \includegraphics[width=0.05\textwidth,height=\textheight]{images/Tab.png} ). Comparirà una finestra con possibili soluzioni di autocompletamento del nome della funzione. Utilizzando le frecce della tastiera possiamo evidenziare lq funzione voluta e premere \texttt{Invio} per autocompletare il comando. Nota come accanto al nome della funzione appare anche un piccolo riquadro giallo con la descrizione della funzione.

\includegraphics[width=0.95\textwidth,height=\textheight]{images/autocomplete-function.png}

Per inserire gli argomenti della funzione possiamo fare affidamento nuovamente ai suggerimenti e alla funzione di autocompletamento. Sarà sufficiente premere nuovamente il tasto \texttt{Tab} e questa volta comparirà una lista degli argomenti con la relativa descrizione. Sarà quindi sufficiente selezionare con le frecce l'argomento desiderato e premere \texttt{Invio}.

\includegraphics[width=0.95\textwidth,height=\textheight]{images/autocomplete-arguments.png}

Notate come la funzione di autocompletamento non sia utilizzata solo per le funzioni ma anche per i nomi degli oggetti. Questo ci consentirà di richiamare velocemente oggetti precedentemente creati evitando di digitare l'intero nome.

\includegraphics[width=0.95\textwidth,height=\textheight]{images/autocomplete-objects.png}

\end{trick}

\hypertarget{working-environment}{%
\chapter{Ambiente di Lavoro}\label{working-environment}}

In queso capitolo introdurremo alcuni concetti molto importanti che riguardano l'ambiente di lavoro in R o RStudio. In particolare parleremo dell'\emph{environment}, della \emph{working directory} e dell'utilizzo dei pacchetti.

\hypertarget{environment}{%
\section{Environment}\label{environment}}

Nel Capitolo \ref{objects-section}, abbiamo visto come sia possibile assegnare dei valori a degli oggetti. Questi oggetti vengono creati nel nostro ambiente di lavoro (o meglio \emph{Environment}) e potranno essere utilizzati in seguito.

Il nostro Enviroment raccoglie quindi tutti gli oggetti che vengono creati durante la nostra sessione di lavoro. E' possibile valutare gli oggetti attualmente presenti osservando il pannello \emph{Environment} in alto a destra (vedi Figura \ref{fig:environment2}) oppure utilizzadno il comando \texttt{ls()}, ovvero \emph{list objects}.

\begin{figure}

{\centering \includegraphics[width=0.6\linewidth]{images/environment} 

}

\caption{*Environment* - Elenco degli oggetti e variabili presenti nel'ambiente di lavoro}\label{fig:environment2}
\end{figure}

All'inizio della sessione di lavoro il nostro Environment sarà vuoto (vedi Figura \ref{environment-empty}). Il comando \texttt{ls()} non restituirà alcun oggeto ma per indicare l'assenza di oggerri userà la risposta \texttt{character(0)}, ovvero un vettore di tipo caratteri di lunghezza zero (vedi Capitolo TODO).

\begin{figure}

{\centering \includegraphics[width=0.6\linewidth]{images/environment-empty} 

}

\caption{*Environment* vuoto ad inizio sessione di lavoro}\label{fig:environment-empty}
\end{figure}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Environment vuoto}
\KeywordTok{ls}\NormalTok{()}
\CommentTok{## character(0)}
\end{Highlighting}
\end{Shaded}

\hypertarget{aggiungere-oggetti-allenvironment}{%
\subsection{Aggiungere Oggetti all'Environment}\label{aggiungere-oggetti-allenvironment}}

Una volta creati degli oggetti, questi saranno presenti nel nostro Environment e il comando \texttt{ls()} restituirà un vettore di caretteri in cui vengono elencati tutti i loro nomi.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Creo oggetti}
\NormalTok{x <-}\StringTok{  }\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{6}\NormalTok{,}\DecValTok{8}\NormalTok{)}
\NormalTok{y <-}\StringTok{  }\DecValTok{27}
\NormalTok{word <-}\StringTok{ "Hello Word!"}

\CommentTok{# Lista nomi oggetti nell'Environment}
\KeywordTok{ls}\NormalTok{()}
\CommentTok{## [1] "word" "x"    "y"}
\end{Highlighting}
\end{Shaded}

Nel pannello in alto a destra (vedi Figura \ref{fig:environment-object}), possiamo trovare un elenco degli oggetti attualmente presenti nel nostro Environment. Insieme al nome vengono riportate anche alcune utili inforamzioni a seconda del tipo di oggetto. Vediamo come nel nostro esempio, nel caso di variabili con un singolo valore (e.g., \texttt{word} e \texttt{y}) venganno presentati direttamente gli stessi valori. Mentre, nel caso di vettori (e.g., \texttt{x}) vengano fornite anche informazioni riguardanti la tipologia di vettore e la sua dimensione (vedi Capitolo TODO), nell'esempio abbiimao un vettore numerico (\texttt{num}) di 4 elementi (\texttt{{[}1:4{]}}).

\begin{figure}

{\centering \includegraphics[width=0.6\linewidth]{images/environment-objects} 

}

\caption{*Environment* contenente gli oggetti creati}\label{fig:environment-object}
\end{figure}

\hypertarget{rimuovere-oggetti-dallenvironment}{%
\subsection{Rimuovere Oggetti dall'Environment}\label{rimuovere-oggetti-dallenvironment}}

Per rimuovere un oggetto dal proprio environment è possibile utilizzare il comando \texttt{remove()} oppure la sua abbreviazione \texttt{rm()}, indicando tra parentesi il nome dell'oggetto che si intende rimuovere. E' possibile indicare più di un oggetto separando i loro nomi con la virgola.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Rimuovo un oggetto}
\KeywordTok{rm}\NormalTok{(word)}
\KeywordTok{ls}\NormalTok{()}
\CommentTok{## [1] "x" "y"}

\CommentTok{# Rimuovo più oggetti contemporaneamente}
\KeywordTok{rm}\NormalTok{(x,y)}
\KeywordTok{ls}\NormalTok{()}
\CommentTok{## character(0)}
\end{Highlighting}
\end{Shaded}

\begin{trick}[rm(list=ls())]

Qualora fosse necessario eliminare tutti gli oggetti attualmete presenti nel nosto ambiente di lavoro è possibile ricorrere alla formula \texttt{rm(list=ls())}. In questo modo si avrà la certezza di pulire l'ambiente da ogni oggetto e di ripristinarlo alle condizioni iniziali della sessione.

\end{trick}

\begin{design}[Mantenere Ordinato l'Environment]

Avere cura di mantenre il proprio Environment ordinato ed essere consapevoli degli oggetti attualmente presenti è importante. Questo ci permette di evitare di compiere due errori comuni.

\begin{itemize}
\tightlist
\item
  \textbf{Utilizzare oggetti non ancora creati}. In questo caso l'errore è facilemente individuabile dat che sarà lo stesso R ad avvisarci che \emph{``object `' not found''}. In questo caso dovremmo semplicemente eseguire il comando per creare l'oggetto richieto.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{oggetto_non_esistente}
\CommentTok{## Error in eval(expr, envir, enclos): object 'oggetto_non_esistente' not found}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \textbf{Utilizzare oggetti con ``\emph{vecchi}'' valori}. Se non si ha cura di mantenere ordinato il proprio ambiente di lavoro potrebbe accadere che diversi oggetti vengano creati durante successive sessioni di lavoro. A questo punto si corre il rischio di perdere il controllo rispetto al vero contenuto degli oggetti e potremmo quindi utilizzare degli oggetti pensando che contengano un certo valore, quando invece si riferisono a tutt'altro. Questo comporta che qualsiasi nostro risultato perda di significato. Bisogna prestare molta attenzione perchè R non potrà avvisarci di questo errore (per lui sono solo numeri), siamo noi che dobbiamo essere consapevoli del fatto che i comandi eseguiti abbiano senso oppure no.
\end{itemize}

Per mantere un Environmet ordinato vi consigliamo innanzitutto di non salvare automaticamente il vostro \emph{workspace} quando terminate una sessione di lavoro. E' possibile settare tale opzione nelle impostazioni generali di R selezionando \emph{``Never''} alla voce \emph{``save workspace to .RData on exit''} come riportato nella Figura seguente.

\includegraphics[width=0.75\textwidth,height=\textheight]{images/save-rdata.png}

Questo vi permetterà di iniziare ogni nuova sessione di lavoro in un Environment vuoto, evitando che vecchi oggetti si accumulino nel corso delle diverse sesssioni di lavoro. Durante le vostre sessioni, inoltre, sarà utile eseguire il comando \texttt{rm(list=ls())} quando inizierete un nuovo compito in modo da eliminare tutti i vecchi oggetti.

\hypertarget{environment-una-memoria-a-breve-termine}{%
\subsubsection*{Environment una Memoria a Breve Termine}\label{environment-una-memoria-a-breve-termine}}
\addcontentsline{toc}{subsubsection}{Environment una Memoria a Breve Termine}

Notiamo quindi come l'Environment sia qualcosa di transitorio. Gli oggetti vengono salvati nella memoria primaria del computer (RAM, possiamo pensarla in modo analogo alla memoria a breve termine dei modelli cognitivi) e verranno cancellati al comando \texttt{rm(list=ls())} o al termine di ogni sessione di lavoro.

Il fatto di partire ogni volta da un Environment vuoto, vi costringerà a raccogliere tutti i passi delle vostre analisi all'interno di uno script in modo ordinato evitando di fare affidamento su vecchi oggetti. Tutti gli oggetti necessari durante le analisi, infattii, dovranno essere ricreati ad ogni sessione, garantendo la riproducibilità e correttezza del lavro (almeno dal punto di vista di programmazione). Idealmente dovrebbe essere posibile, in una sessione di lavoro, partire da un Environment vuoto ed eseguire in ordine tutti i comandi contenuti in uno script fino ad ottenere i risultati desiderati.

E' facile intuire come in certe situazioni questa non sia la soluzione più efficiente. Alcuni comandi, infatti, potrebbero richiedere molti minuti (o anche giorni) per essere eseguiti. In questi casi sarebbe conveniente, pertanto, salvare i risultati ottenuti per poterli utilizzare anche in sessioni successive, senza la necessità di dover eseguire nuovamente tutti i comadi. Vedremo nel Capitolo TODO come sarà possibile salvare permanentemente gli oggetti creati nella memoria secondaria del computer (hard-disk, nella nostra analogia la memoria a lungo termine) e come caricarli in una successiva sessione di lavoro.

\end{design}

\hypertarget{working-directory}{%
\section{Working Directory}\label{working-directory}}

Il concetto di \emph{working directory} è molto importante ma spesso poco conosciuto. La \emph{working directory} è la posizione all'interno del computer in cui ci troviamo durante la nostra sessione di lavoro e da cui eseguiamo i nostri comandi.

\hypertarget{organizzazione-computer}{%
\subsection{Organizzazione Computer}\label{organizzazione-computer}}

L'idea intuitiva che abbiamo comunemente del funzionamento del computer è fuorviante. Spesso si pensa che il Desktop rispecchi l'organizzazione del nostro intero computer e che tutte le azioni siano gestite attraverso l'interfaccia punta-e-clicca a cui ormai siamo abituati dai moderni sistemi operativi.

Senza entrare nel dettaglio, è più corretto pensare all'organizzazione del cumputer come ad un insieme di cartelle e sottocartelle che contengono tutti i nostri file e al funzionamento del computer come ad un insieme di processi (o comandi) che vengono eseguiti. Gli stessi programmi che installiamo non sono altro che delle cartelle in cui sono contenuti tutti gli script che determinano il loro funzionamento. Anche il Desktop non è altro che una semplice cartella mentre quello che vediamo noi è un programma definito dal sistema operativo che visualizza il contenuto di quella cartella sul nostro schermo e ci permette di interfacciarci con il mouse.

Tutto quello che è presente nel nostro computer, compresi i nostri file, i programmi e lo stesso sistema operativo in uso, tutto è organizzato in un articolato sistema di cartelle e sottocartelle. Approsimativamente possiamo pensare all'organizzazione del nostro computer in modo simile alla Figura \ref{fig:file-system} (da: \url{https://en.wikipedia.org/wiki/Operating_system}).

\begin{figure}

{\centering \includegraphics[width=0.35\linewidth]{images/File-System} 

}

\caption{Organizzazione Computer (da Wikipedia vedi link nel testo)}\label{fig:file-system}
\end{figure}

Ai livelli più bassi troviamo tutti i file di sistema ai quali gli utenti possono accedere solo con speciali autorizzazioni. Al livello superiore troviamo tutte i file riguardanti i programmi e applicazioni installati che in genere sono utilizzabili da più utenti sullo stesso computer. Infine troviamo tutte le cartelle e file che riguardano lo specifico utente.

\hypertarget{absolute-path-e-relative-path}{%
\subsection{Absolute Path e Relative Path}\label{absolute-path-e-relative-path}}

Questo ampio preambolo riguardante l'organizzazione in cartelle e sottocartelle, ci serve perchè è la struttura che il computer utilizza per orientarsi tra tutti file quando esegue dei comandi attraverso un'interfaccia a riga di comando (e.g., R). Se vogliamo ad esempio caricare dei dati da uno specifico file in R devo fornire il \emph{path} (o indirizzo) corretto che mi indichi esattamente la posizione del file all'interno della struttura di cartelle del computer. Ad esempio, immaginiamo di avere dei dati \texttt{My-data.Rda} salvato nella cartella \texttt{Introduction2R} nel proprio Desktop.

\begin{verbatim}
Desktop
 |
 |-  Introduction2R
 |    |
 |    |- Dati
 |    |   |- My-data.Rda
\end{verbatim}

Per indicare la posizione del File potrei utilizzare un:

\begin{itemize}
\tightlist
\item
  \textbf{absolute path} - la posizione \emph{``assoluta''} del file rispetto alla \emph{root directory} del sistema ovvero la cartella principale dell'intero computer.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Mac}
\StringTok{"/Users/<username>/Desktop/Introduction2R/Dati/My-data.Rda"}

\CommentTok{# Windows Vista}
\StringTok{"c:\textbackslash{}Users\textbackslash{}<username>\textbackslash{}Desktop\textbackslash{}Introduction2R\textbackslash{}Dati\textbackslash{}My-data.Rda"}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \textbf{relative path} - la posizione del file rispetto alla nostra attuale posizione nel computer da cui stiamo eseguendo il comando, ovvero rispetto alla \textbf{working directory} della nostra sessione di lavoro. In questo riprendendo il precedente esempio se la nostra working directory fosse la cartella \texttt{Desktop/Introduction2R} avremmo i seguenti relative path:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Mac}
\StringTok{"Dati/My-data.Rda"}

\CommentTok{# Windows Vista}
\StringTok{"Dati\textbackslash{}My-data.Rda"}
\end{Highlighting}
\end{Shaded}

Nota come sia preferibile l'utilizzo dei relative path poichè gli absolute path sono unici per il singolo computer di riferimento e non possono essere quindi utilizzati su altri computer.

\begin{warning}["Error: No such file or directory"]

Qualora si utilizzasse un relative path per indicare la posizione di un file, è importante che la working directory attualment in uso sia effettivamente quella prevista. Se ci trovassimo in una divesa cartella, ovviamente il ``relative path'' indicato non sarebbe più valido e R ci mostrerebbe un messaggio di errore.

Riprendendo l'esempio precedente, supponiamo che la nostra attuale working directory sia \texttt{Desktop} invece di \texttt{Desktop/Introduction2R}. Eseguendo il comadno \texttt{load()} per caricare i dati utilizzando il relative path ora non più valido ottengo:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{load}\NormalTok{(}\StringTok{"Dati/My-data.Rda"}\NormalTok{)}
\CommentTok{## Warning in readChar(con, 5L, useBytes = TRUE): cannot open compressed file}
\CommentTok{## 'Dati/My-data.Rda', probable reason 'No such file or directory'}
\CommentTok{## Error in readChar(con, 5L, useBytes = TRUE): cannot open the connection}
\end{Highlighting}
\end{Shaded}

Il messaggio di errore mi indica che R non è stato in grado di trovare il file seguendo le mie indicazioni. E' come se chiedessi al computer di aprire il frigo ma attualmente si trovasse in camera, devo prima dargli le indicazioni per raggiungere la cucina altrimenti mi risponderebbe \emph{``frigo non trovato''}. Risulta pertanto fondamentale essere sempre consapevoli di quale sia l'attuale working directory in cui si sta svolgendo la sessione di lavoro.

Ovviamente otterrei lo stesso errore anche usando un absolute path se questo contenesse degli errori.

\end{warning}

\begin{design}[The Garden of Forking Paths]

Come avrai notato dagli esempi precedenti, sia la struttura in cui vengono organizzati i file nel computer sia la sintassi utilizzata per indicare i path è differente in base al sistema operativo utilizzato.

\hypertarget{mac-os-e-linux}{%
\subsubsection*{Mac OS e Linux}\label{mac-os-e-linux}}
\addcontentsline{toc}{subsubsection}{Mac OS e Linux}

\begin{itemize}
\tightlist
\item
  Il carattere utilizzato per separare la cartelle nella definizione del path è \texttt{"/"}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"Introduction2R/Dati/My-data.Rda"}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Iniziando il path con il carattere \texttt{"/"} si indica la root-directory:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"/Users/<username>/Desktop/Introduction2R/Dati/My-data.Rda"}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Iniziando il path con il carattere \texttt{"\textasciitilde{}"} si indica la cartella \emph{home} dell'utente ovvero \texttt{/Users/\textless{}username\textgreater{}/}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"~/Desktop/Introduction2R/Dati/My-data.Rda"}
\end{Highlighting}
\end{Shaded}

\hypertarget{windows-1}{%
\subsubsection*{Windows}\label{windows-1}}
\addcontentsline{toc}{subsubsection}{Windows}

\begin{itemize}
\tightlist
\item
  Il carattere utilizzato per separare la cartelle nella definizione del path è \texttt{"\textbackslash{}"}:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\StringTok{"Introduction2R\textbackslash{}Dati\textbackslash{}My-data.Rda"}
\end{Highlighting}
\end{Shaded}

\end{design}

\hypertarget{working-directory-in-r}{%
\subsection{Working Directory in R}\label{working-directory-in-r}}

Vediamo ora i comandi utilizzati in R per valutare e cambiare la working directory nella propria sessione di lavoro.

\hypertarget{attuale-working-directory}{%
\subsubsection*{Attuale Working Directory}\label{attuale-working-directory}}
\addcontentsline{toc}{subsubsection}{Attuale Working Directory}

In R è possibile valutare l'attuale working directory utilizzando il comando \texttt{getwd()} che restituirà l'absolute path dell'attuale posizione.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getwd}\NormalTok{()}
\CommentTok{## [1] "/Users/<username>/Desktop/Introduction2R"}
\end{Highlighting}
\end{Shaded}

In alternativa, l'attuale working directory è anche riportata in alto a sinistra della Console come mostrato in Figura \ref{fig:current-wd}.

\begin{figure}

{\centering \includegraphics[width=0.95\linewidth]{images/current-wd} 

}

\caption{Workig directory dell'attuale sessione di lavoro}\label{fig:current-wd}
\end{figure}

Premendo la freccia al suo fianco il pannello \emph{Files} in basso a destra sarà reindirizzato direttamento alla workig directory dell'attuale sessione di lavoro. In questo modo sarà facile navigare tra i file e cartelle presenti al suo interno (vedi Figura \ref{fig:current-folder}).

\begin{figure}

{\centering \includegraphics[width=0.65\linewidth]{images/current-folder} 

}

\caption{Workig directory dell'attuale sessione di lavoro}\label{fig:current-folder}
\end{figure}

\hypertarget{cambiare-working-directory}{%
\subsubsection*{Cambiare Working Directory}\label{cambiare-working-directory}}
\addcontentsline{toc}{subsubsection}{Cambiare Working Directory}

Per cambiare la working directory è possibile utilizzare il comando \texttt{setwd()} indicando il path (absolute o relative) della nuova working directory. Nota come, nel caso in cui venga indicato un relative path, questo dovrà indicare la posizione della nuova working directory rispetto alla vecchia working directory.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getwd}\NormalTok{()}
\CommentTok{## [1] "/Users/<username>/Desktop/Introduction2R"}

\KeywordTok{setwd}\NormalTok{(}\StringTok{"Dati/"}\NormalTok{)}

\KeywordTok{getwd}\NormalTok{()}
\CommentTok{## [1] "/Users/<username>/Desktop/Introduction2R/Dati"}
\end{Highlighting}
\end{Shaded}

In alternativa è possibile selezionare l'opzione \emph{``Choose Directory''} dal menù \emph{``Session''} \textgreater{} \emph{``Set Working Directory''} come mostrato in Figura \ref{fig:set-wd}. Verrà quindi richiesto di selezionare la working directory desiderata e preme ``\emph{Open}''.

\begin{figure}

{\centering \includegraphics[width=0.95\linewidth]{images/set-wd} 

}

\caption{Definire la working directory}\label{fig:set-wd}
\end{figure}

\begin{trick}[Show me the Path]

Nota come sia possibile nel digitare il path sfruttare l'autocompletamento. All'interno delle virgolette \texttt{""} premi il tasto \texttt{Tab} per visualizzare i suggerimenti dei path relativi alla attuale working directory.

\includegraphics[width=0.75\textwidth,height=\textheight]{images/path-autocomplete.png}

E' possibile inoltre utilizzare i caratteri speciali \texttt{"./"} e \texttt{"../"} per indicare rispettivamente l'attuale working directory e la cartella del livello superiore (i.e., \emph{parent folder}) che include l'attuale working directory. \texttt{"../"} ci permette quindi di navigare a ritroso dalla nostra attuale posizione tra le cartelle del computer.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{getwd}\NormalTok{()}
\CommentTok{## [1] "/Users/<username>/Desktop/Introduction2R"}

\KeywordTok{setwd}\NormalTok{(}\StringTok{"../"}\NormalTok{)}

\KeywordTok{getwd}\NormalTok{()}
\CommentTok{## [1] "/Users/<username>/Desktop/"}
\end{Highlighting}
\end{Shaded}

\end{trick}

\hypertarget{packages}{%
\section{R-packages}\label{packages}}

Uno dei grandi punti di forza di R è quella di poter estendere le proprie funzioni di base in modo semplice ed intuitivo utilizzando nuovi pacchetti. Al momento esistono oltre \textbf{17'000} pachetti disponibili gratuitamente sul CRAN (la repository ufficiale di R). Questi pacchetti sono stati sviluppati dall'immensa comunity di R per svolgere ogni sorta di compito. Si potrebbe dire quindi che in R ogni cosa sia possibile, basta trovare il giusto pacchetto (oppure crearlo!).

Quando abbiamo installato R in automatico sono stati installati una serie di pacchetti che costituiscono la \textbf{system library}, ovvero tutti quei pacchetti di base che permettono il fuzionamento di R. Tuttavia, gli altri pacchetti non sono disponibili da subito. Per utilizzare le funzioni di altri pacchetti, è necessario seguire una procedura in due step come rappresentato in Figura \ref{fig:packages-process}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\item
  \textbf{Scaricare ed installare i pacchetti sul nostro computer}. I pacchetti sono disponibili gratuitamente online nella reopsitory del CRAN, una sorta di archivio. Vengono quindi scaricati ed installati nella nostra \emph{library}, ovvero la raccolta di tutti i pacchetti di R disponibili sul nostro computer.
\item
  \textbf{Caricare il paccheto nella sessione di lavoro}. Anche se il paccheto è installato nella nostra library non siamo ancora pronti per utilizzare le sue funzioni. Sarà necessario prima caricare il pacchetto nella nostra sessione di lavoro. Solo ora le funzionni del pacchetto saranno effetivamente disponibili per essere usate.
\end{enumerate}

\begin{figure}

{\centering \includegraphics[width=0.95\linewidth]{images/packages-process} 

}

\caption{Utilizzare i paccheti in R}\label{fig:packages-process}
\end{figure}

Questo procedimento in due step potrebbe sembrare poco intuitivo. \emph{``Perchè dover caricare qualcosa che è già installato?''} La risposta è molto semplice ci serve per mantenere efficiente e sotto controllo la nostra sessione di lavoro. Infatti non avremo mai bisogno di tutti i pacchetti installati ma a seconda dei compiti da eseguire utilizzeremo di volta in volta solo alcuni pacchetti specifici. Se tutti i pacchetti fossero caricati automaticamente ogni volta sarebbe un inutile spreco di memoria e si creerebbero facilmente dei conflitti. Ovvero, alcune funzioni di diversi pacchetti potrebbero avere lo stesso nome ma scopi diversi. Sarebbe quindi molto facile ottenere errori o comunque risultati non validi.

Vediamo ora come eseguire queste operazioni in R.

\hypertarget{install.packages}{%
\subsection{install.packages()}\label{install.packages}}

Per installare dei pacchetti dal CRAN nella nostra library è possibile eseguire il comando \texttt{install.packages()} indicando tra parentesi il nome del pacchetto desiderato.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Un ottimo pacchetto per le analisi statistiche di John Fox}
\CommentTok{# un grandissimo statistico...per gli amici Jonny la volpe ;)}
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"car"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

In alternativa è possibile utilizzare il pulsante \emph{``Install''} nella barra in alto a sinistra del pannello Packages ( vedi Figura \ref{fig:packages-install}), indicando successivamente il nome del pacchetto desiderato.

\begin{figure}

{\centering \includegraphics[width=0.65\linewidth]{images/packages-install} 

}

\caption{Installare paccektti tramite interfacci RStudio}\label{fig:packages-install}
\end{figure}

Nota come installare un pacchetto potrebbe comportare l'installazione di più pacchetti. Questo perchè verranno automaticamente installate anche le \emph{dependencies} del pacchetto, ovverro, tutti i pacchetti usati internamente dal pacchetto di interesse che quindi necessari per il suo corretto funzionaemnto (come in un gioco di matrioske).

Una volta installato il pacchetto, questo comarirà nella library ovvero la lista dei pacchetti disponibili mostrata nel pannello Packages (vedi Figura \ref{fig:library-car}).

\begin{figure}

{\centering \includegraphics[width=0.65\linewidth]{images/library-car} 

}

\caption{Il pacchetto car è ora disponibile nella library}\label{fig:library-car}
\end{figure}

\hypertarget{library}{%
\subsection{library()}\label{library}}

Per utilizzare le funzioni di un pacchetto già presente nella notra library, dobbiamo ora caricarlo nella nostra sessione di lavoro. Per fare ciò, posssiamo utilizzare il comando \texttt{library()} indicando tra parentesi il nome del pacchetto richiesto.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{library}\NormalTok{(car)}
\end{Highlighting}
\end{Shaded}

In alternativa è possibile spuntare il riquadro alla sinistra del nome del pacchetto dal pannello Packages come mostrato in Figura \ref{fig:load-package}. Nota tuttavia come questa procedura sia sconsigliata. Infatti, ogni azione punta-e-clicca dovrebbe essere eseguita ad ogni sessione mentre l'utilizzo di comandi inclusi nello script garantisce la loro esecuzione automatica.

\begin{figure}

{\centering \includegraphics[width=0.65\linewidth]{images/load-package} 

}

\caption{Caricare un pacchetto nella sessione di lavoro}\label{fig:load-package}
\end{figure}

Ora siamo finalmente pronti per utilizzare le funzioni del pacchetto nella nostra sessione di lavro.

\begin{trick}[package::function()]

Esiste un piccolo trucco per utilizzare la funzione di uno specifico pacchetto senza dover caricare il pacchetto nella propria sessione. Per fare questo è possibile usare la sintassi:

\begin{Shaded}
\begin{Highlighting}[]
\OperatorTok{<}\NormalTok{nome}\OperatorTok{-}\NormalTok{pacchetto}\OperatorTok{>}\ErrorTok{::<}\NormalTok{nome}\OperatorTok{-}\NormalTok{funzione}\OperatorTok{>}\NormalTok{()}

\CommentTok{# Esempio con la funzione Anova del pacchetto car}
\NormalTok{car}\OperatorTok{::}\KeywordTok{Anova}\NormalTok{()}
\end{Highlighting}
\end{Shaded}

L'utilizzo dei \texttt{::} ci permette di richiamare direttamente la funzione desiderata. La differennza tra l'uso di \texttt{library()} e l'uso di \texttt{::} riguarda aspetti abbastanza avanzati di R (per un approfondimento vedi \url{https://r-pkgs.org/namespace.html}). In estrema sintesi, possiamo dire che in alcuni casi è preferibile non caricare un'intero pacchetto se di questo abbiamo bisogno di un'unica funzione.

\end{trick}

\hypertarget{aggiornare-e-rimuovere-pacchetti}{%
\subsection{Aggiornare e Rimuovere Pacchetti}\label{aggiornare-e-rimuovere-pacchetti}}

Anche i pacchettti come ogni altro software vengono aggiornati nel corso del tempo fornendo nuove funzionalità e risolvendo eventuli problemi. Per aggiornare i pacchetti alla versione più recente è possibile eseguire il comando \texttt{update.packages()} senza inidare nulla tra le parentesi.

In alternativa è possibile premere il pulsante \emph{``Update''} nella barra in alto a sinistra del pannello Packages ( vedi Figura \ref{fig:library-version}), indicando successivamente i pachetti che si desidera aggiornare. Nota come nella lista dei pacchetti venga riportata l'attuale versione alla voce \emph{``Version''}.

\begin{figure}

{\centering \includegraphics[width=0.65\linewidth]{images/library-version} 

}

\caption{Aggiornare i pacchetti}\label{fig:library-version}
\end{figure}

Nel caso in cui si vogli invece rimuover uno specifico pacchetto, è possibile eseguire il comando \texttt{remove.packages()} indicando tra le parentesi il nome del pacchetto.

In alternativa è possibile premere il pulsante \texttt{x} alla destra del paccehettto nel pannello Packages come mostrao in Figura \ref{fig:library-remove}.

\begin{figure}

{\centering \includegraphics[width=0.65\linewidth]{images/library-remove} 

}

\caption{Rimuovere un pacchetto}\label{fig:library-remove}
\end{figure}

\hypertarget{documantazione-pacchetti}{%
\subsection{Documantazione Pacchetti}\label{documantazione-pacchetti}}

Ogni pacchetto include la documentazione delle proprie funzioni e delle \emph{vignette} ovvero dei brevi tutorial che mostrano degli esempi di applicazione e utilizzo del pacchetto.

\begin{itemize}
\item
  \textbf{Documentazione funzione} - Per accedere alla documentazione di una funzione è sufficiente utilizzare il comando \texttt{?\textless{}nome-funzione\textgreater{}} oppure \texttt{help(\textless{}nome-funzione\textgreater{})}. Ricorda è necessario avere prima caricato il pacchetto altrimenti la funzione non risulta ancora disponibile. In alternativa si potrebbe estendere la ricerca utilizzando il comando \texttt{??}.
\item
  \textbf{Vignette} - Per ottenere la lista di tutte le vignette di un determinato pacchetto è possibile utilizzare il comando \texttt{browseVignettes(package\ =\ \textless{}nome-pacchetto\textgreater{})\textquotesingle{}}. Mentre, per accedere ad una specifica vignetta, si utilizza il comando \texttt{vignette("\textless{}name-vignetta\textgreater{}")}.
\item
  \textbf{Documentazione intero pacchetto} - Premendo il nome del pacchetto dal pannello Packages in basso a destra, è possibile accedere alla lista di tutte le informazioni relative al pacchetto come riportato in Figura \ref{fig:package-documentation}. Vengono prima forniti i link per le vignette ed altri file relativi alle caratteristiche del pacchetto. Successivamente sono presentate in ordine alfabetico tutte le funzioni.
\end{itemize}

\begin{figure}

{\centering \includegraphics[width=0.65\linewidth]{images/package-documentation} 

}

\caption{Documetazione del pacchetto car}\label{fig:package-documentation}
\end{figure}

Ricordate tuttavia che in ogni caso la più grande risorsa di informazioni è come sempre google. Spesso i pacchetti più importanti hanno addirittura un proprio sito in cui raccolgono molto materiale utile. Ma comunque in ogni caso in internet sono sempre disponibili moltissimi tutorial ed esempi.

\begin{design}[Github]

Il CRAN non è l'unica risorsa da cui è possibile installare dei pacchetti di R tuttavia è quella ufficiale e garantisce un certo standard e stabilità dei pacchetti presenti. In internet esistono molte altre repository che raccolgono paccetti di R (e software in generale) tra cui una delle più popolari è certamente GitHub (\url{https://github.com/}).

Github viene utilizzato come piattaforma di sviluppo per molti pacchetti di R ed è quindi possibile trovarve le ultime versioni di sviluppo dei pacchetti con gli aggirnamenti più recenti o anche nuovi pacchetti non ancora disponibili sul CRAN. Va sottolineato tuttavia, come quete siano appunto delle versioni di sviluppo e quindi potrebbero presentare maggiori problemi. Inoltre per installare i pacchetti in questo modo, è richiesta l'installzione di \textbf{R tools} (vedi \emph{``Approfondimento: R Tools''} nel Capitolo \ref{install-r}).

Per installare un pacchetto direttamente da Github è posibile utilizzare il comando \texttt{install\_github()} del pacchetto \texttt{devtools}, indicanto tra parentesi la l'url della repository desiderata.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{install.packages}\NormalTok{(}\StringTok{"devtools"}\NormalTok{)}

\CommentTok{# ggplot2 il miglior pacchetto per grafici}
\NormalTok{devtools}\OperatorTok{::}\KeywordTok{install_github}\NormalTok{(}\StringTok{"https://github.com/tidyverse/ggplot2"}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\end{design}

\hypertarget{working-session}{%
\chapter{Sessione di Lavoro}\label{working-session}}

In questo capitolo, discuteremo di alcuni aspetti generali delle sessioni di lavoro in R. Descriveremo delle buone abitudini riguardanti l'organizzazione degli scripts e l'uso degli \emph{RStudio Projects} per essere ordinati ed efficaci nel proprio lavoro. Infine approfondiremo l'uso dei messaggi di R ed in particolare come comportarsi in caso di errori.

\hypertarget{organizzazione-script}{%
\section{Organizzazione Script}\label{organizzazione-script}}

Abbiamo visto che idealmente tutti i passaggi delle nostre analisi devono essere raccolti in modo ordinato all'interno di uno script. Eseguendo in ordine linea per linea i comandi, dovrebbe essere possibile svolgere tutte le analisi fino ad ottenere i risultati desiderati.

Vediamo ora una serie di buone regole per organizzare in modo ordinato il codice all'interno di uno script e facilitare la sua lettura.

\hypertarget{creare-delle-sezioni}{%
\subsection{Creare delle Sezioni}\label{creare-delle-sezioni}}

Per mantenere chiara l'oreganizzazione degli script e facilitare la sua comprensione, è utile suddividere il codice in sezioni dove vengono eseguiti i diversi step delle analisi. In RStudio è possibile creare una sezione aggiungendo al termine di una linea di commento i caratteri \texttt{\#\#\#\#} o \texttt{-\/-\/-\/-}. Il testo del commento verrà considerao il titolo della sezione e comparirà una piccola freccia a lato del numero di riga. E' possibile utilizzare a piacere i caratteri \texttt{\#} o \texttt{-} per creare lo stile desiderato, l'importante è che la linea si concluda con almeno quattro caratteri identici.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Sezione 1 ####}

\CommentTok{# Sezione 2 ----}

\CommentTok{#----    Sezione 3    ----}

\CommentTok{####   Sezione non valida   --##}
\end{Highlighting}
\end{Shaded}

A titolo del tutto esemplificativo prendiamo in esempio la divisione in sezioni utilizzata nello script in Figura \ref{fig:script-template}.

\begin{figure}

{\centering \includegraphics[width=0.85\linewidth]{images/script-template} 

}

\caption{Esempio di suddivisione in sezioni di uno script}\label{fig:script-template}
\end{figure}

\begin{itemize}
\tightlist
\item
  \textbf{Titolo} - Un titolo esplicativo del contenuto dello script. E' possibile utilizzare altri caratteri all'interno dei commenti per creare l'effetto desiderato.
\item
  \textbf{Intorduzione} - Descrizione e utili informazioni che riguardano sia l'obbiettivo del lavoro che l'esecuzione del codice (e.g., dove sono disponibili i dati, eventuali specifiche tecniche). Potrebbe essere utile anche indicare l'autore e la data del lavoro.
\item
  \textbf{Setting} - Sezione fondamentale in cui si predispone l'abiente di lavoro. Le operazioni da svolgere sono:

  \begin{enumerate}
  \def\labelenumi{\arabic{enumi}.}
  \tightlist
  \item
    \texttt{rm(list\ =\ ls())} per pulire l'Environment da eventuali oggetti in modo da eseguire lo script partendo da un ambiente vuoto (vedi Capitolo \ref{environment}).
  \item
    \texttt{setwd()} per settare la working directory per assicuraci che i comandi siano eseguiti dalla correttta posizione nel nostro computer (vedi Capitolo \ref{working-directory}).
  \item
    \texttt{library()} per caricare i pacchetti utilizzati nel corso delle analisi (vedi Capitolo \ref{packages}).
  \end{enumerate}
\item
  \textbf{Caricare e Pulire i Dati} - Generica sezione in cui eseguire l'importazione e pulizia dei dati.
\item
  \textbf{Codifica e Scoring dei Dati} - Generica sezione in cui eseguire la codifica ed eventuale scoring dei dati.
\item
  \textbf{Analisi Descrittive} - Generica sezione in cui eseguire le analisi descrittive.
\item
  \textbf{Analisi Inferenziali} - Generica sezione in cui eseguire le analisi inferenziali
\end{itemize}

Oltre che a mantenere ordinato e chiaro il codice, suddividere il proprio script in sezioni ci permette anche di navigare facilmente tra le diverse parti del codice. Possiamo infatti sfruttare l'indice che automaticamente viene creato. L'indice è consultabile premendo il tasto in alto a destra dello script da cui successivamente selezionare la sezione desiderata (vedi Figura \ref{fig:toc-side}).

\begin{figure}

{\centering \includegraphics[width=0.85\linewidth]{images/toc-side} 

}

\caption{Indice in alto per navigazione sezioni}\label{fig:toc-side}
\end{figure}

In alternativa, è possibile utilizzare il menù in basso a sinistra dello script (vedi Figura \ref{fig:toc-bottom}).

\begin{figure}

{\centering \includegraphics[width=0.85\linewidth]{images/toc-bottom} 

}

\caption{Menù in basso per navigazione sezioni}\label{fig:toc-bottom}
\end{figure}

Infine, un altro vantaggio è quello di poter compattare o espandere le sezioni di codice all'interno dell'editor, utilizzando le frecce a lato del numero di riga (vedi Figura \ref{fig:section-closed}).

\begin{figure}

{\centering \includegraphics[width=0.85\linewidth]{images/section-closed} 

}

\caption{Compattare ed espandere le sezioni di codice}\label{fig:section-closed}
\end{figure}

\hypertarget{sintassi}{%
\subsection{Sintassi}\label{sintassi}}

Elenchiamo qui altre buone norme nella scrittura del codice che ne facilitano la comprensione.

\hypertarget{commenti}{%
\subsubsection*{Commenti}\label{commenti}}
\addcontentsline{toc}{subsubsection}{Commenti}

L'uso dei commenti è molto importante, ci permette di documentare le varie parti del codice e chiarire eventuli comandi difficili da capire. Tuttavia, non è necessario commentare ogni singola riga di codice ed anzi è meglio evitare di commentare laddove i comandi sono facilemtne interpetabili semplicemnte leggendo il codice.

La capacità di scrivere commenti utili ed eviare quelli rindondanti si impara con l'esperienza. In generale un commento non dovrebbe indicare \emph{``che cosa''} ma piuttosto il \emph{``perchè''} di quella parte di codice. Infatti il cosa è facilmente interpretabile dal codice stesso mentre il perchè potrebbe essere meno ovvio e soprattutto più utile per la comprensione dell'intero script. Ad esempio:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\DecValTok{10} \CommentTok{# assegno a x il valore 10}
\NormalTok{x <-}\StringTok{ }\DecValTok{10} \CommentTok{# definisco massimo numero risposte}
\end{Highlighting}
\end{Shaded}

Il primo commento è inutile poichè è facilmente comprensibile dal codice stesso, mentre il secondo commento è motlo utile perchè chiarisce il significato della variabile e mi faciliterà nella comprensione del codice.

\hypertarget{nomi-oggetti}{%
\subsubsection*{Nomi Oggetti}\label{nomi-oggetti}}
\addcontentsline{toc}{subsubsection}{Nomi Oggetti}

Abbiamo visto nel Capitolo \ref{objects-names} le regole che discriminano nomi validi da nomi non validi e le convenzioni da seguire nella definizione di un nome. Ricordiamo qui le caratterisiche che un nome deve avere per facilitare la comprensione del codice. Il nome di un oggetto deve essere:

\begin{itemize}
\tightlist
\item
  \textbf{auto-descrittivo} - Dal solo nome dovrebbe essere possibile intuire il contenuto dell'oggetto. E' meglio quindi evitare nomi generici (quali \texttt{x} o \texttt{y}) ed utilizzare invece nomi che chiaramente descrivano il contenuto dell'oggetto.
\item
  \textbf{della giusta lunghezza} - Non deve essere ne troppo breve (evitare sigle incomprensibili) ma neppure troppo lunghi. In genere sono sufficienti 2 o 3 parole per descrivere chiaramente un oggetto.
\end{itemize}

E' inoltre importante essere \textbf{consistenti} nella scelta dello stile con cui si nominano le variabili. In genere è preferibile usare lo \textbf{snake\_case} rispetto al \textbf{CamelCase}, ma la scelta è comunque libera. Tuttavia, una volta presa una decisione, è bene mantenerla per facilitare la comprensione del codice.

\hypertarget{esplicitare-argomenti}{%
\subsubsection*{Esplicitare Argomenti}\label{esplicitare-argomenti}}
\addcontentsline{toc}{subsubsection}{Esplicitare Argomenti}

Abbiamo visto nel Capitolo \ref{function-arguments} l'importanza di esplicitare il nome degli argomenti quando vengono utilizzati nelle funzioni. Specificando a che cosa si riferiscono i vari valori facilitiamo la lettura e la comprensione del codice. Ad esempio:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{, }\DecValTok{10}\NormalTok{, }\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

Potrebbe non essere chiaro se intendiamo una sequennza tra 0 e 10 di lunghezza 2 o a intervalli di 2. Specificando gli argomenti evitiamo incomprensioni e possibili errori.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{, }\DataTypeTok{to =} \DecValTok{10}\NormalTok{, }\DataTypeTok{by =} \DecValTok{2}\NormalTok{)}
\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{, }\DataTypeTok{to =} \DecValTok{10}\NormalTok{, }\DataTypeTok{length.out =} \DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\hypertarget{spazi-indentazione-ed-allineamento}{%
\subsubsection*{Spazi, Indentazione ed allineamento}\label{spazi-indentazione-ed-allineamento}}
\addcontentsline{toc}{subsubsection}{Spazi, Indentazione ed allineamento}

Al contrario di molti altri software, R non impone regole severe nell'utilizzo di spazi, indentazioni ed allineamenti ed in genere è molto permissivo per quanto riguarda la sintassi del codice. Tuttavia è importante ricordare che:

\begin{quote}
Good coding style is like using correct punctuation. You can manage without it, but it sure makes things easier to read. Hadley Wickham
\end{quote}

Prendiamo ad esempio le seguenti linee di codice, che includono delle funzioni avanzate di R:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Stile 1}
\NormalTok{k=}\DecValTok{10}\NormalTok{;}\ControlFlowTok{if}\NormalTok{(k}\OperatorTok{<}\DecValTok{5}\NormalTok{)\{x<-}\DecValTok{5}\OperatorTok{:}\DecValTok{15}\NormalTok{\}}\ControlFlowTok{else}\NormalTok{\{x<-}\KeywordTok{seq}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{16}\NormalTok{,}\DecValTok{4}\NormalTok{)\};y=}\DecValTok{7}\OperatorTok{*}\DecValTok{2-12}\NormalTok{;}\KeywordTok{mean}\NormalTok{(x}\OperatorTok{/}\NormalTok{y)}
\CommentTok{## [1] 4}

\CommentTok{# Stile 2}
\NormalTok{k <-}\StringTok{  }\DecValTok{10}

\ControlFlowTok{if}\NormalTok{ (k }\OperatorTok{<}\StringTok{ }\DecValTok{5}\NormalTok{)\{}
\NormalTok{  x <-}\StringTok{ }\DecValTok{5}\OperatorTok{:}\DecValTok{15}
\NormalTok{\} }\ControlFlowTok{else}\NormalTok{ \{}
\NormalTok{  x<-}\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{, }\DataTypeTok{to =} \DecValTok{16}\NormalTok{, }\DataTypeTok{by =} \DecValTok{4}\NormalTok{)}
\NormalTok{\}}

\NormalTok{y <-}\StringTok{ }\DecValTok{7} \OperatorTok{*}\StringTok{ }\DecValTok{2} \OperatorTok{-}\StringTok{ }\DecValTok{12}

\KeywordTok{mean}\NormalTok{(x }\OperatorTok{/}\StringTok{ }\NormalTok{y)}
\CommentTok{## [1] 4}
\end{Highlighting}
\end{Shaded}

Come puoi notare otteniamo in entrambi i casi gli stessi risultati, per R non c'è alcuna differenza. Tuttavia, l'uso di spazi, una corretta indentazione ed un appropriato allineamento facilita la lettura e comprensione del codice.

In genere sono valide le seguenti norme:

\begin{itemize}
\tightlist
\item
  Aggiungi degli \textbf{spazi} intorno agli operatori (\texttt{+}, \texttt{-}, \texttt{\textless{}-}, etc.) per separargli dagli argomenti ad eccezione di \texttt{:}.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Good}
\DecValTok{35} \OperatorTok{/}\StringTok{ }\DecValTok{5} \OperatorTok{+}\StringTok{ }\DecValTok{7}
\NormalTok{x <-}\StringTok{ }\DecValTok{0}\OperatorTok{:}\DecValTok{10}

\CommentTok{# Bad}
\DecValTok{35}\OperatorTok{/}\DecValTok{5}\OperatorTok{+}\DecValTok{7}
\NormalTok{x<-}\DecValTok{0} \OperatorTok{:}\StringTok{ }\DecValTok{10}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Nelle funzioni aggiungi degli \textbf{spazi} intorno al simbolo \texttt{=} che separa il nome degli argomenti e il loro valore. Aggiungi uno spazio dopo ogni virogola ma non separare il nome della funzione dalla parentesi sinistra.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Good}
\KeywordTok{seq}\NormalTok{(}\DataTypeTok{from =} \DecValTok{0}\NormalTok{, }\DataTypeTok{to =} \DecValTok{10}\NormalTok{, }\DataTypeTok{by =} \DecValTok{2}\NormalTok{)}

\CommentTok{# Bad}
\KeywordTok{seq}\NormalTok{ (}\DataTypeTok{from=}\DecValTok{0}\NormalTok{,}\DataTypeTok{to=}\DecValTok{10}\NormalTok{,}\DataTypeTok{by=}\DecValTok{2}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  Usa la corretta \textbf{indentazione} per i blocchi di codice posti all'interno delle parentesi graffe. Il livello di indentazione deve rispecchiare la struttura di annidamento del codice.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Good}
\ControlFlowTok{for}\NormalTok{ (...) \{       }\CommentTok{# loop più esterno}
\NormalTok{  ...}
  \ControlFlowTok{for}\NormalTok{ (...) \{     }\CommentTok{# loop interno}
\NormalTok{    ...}
    \ControlFlowTok{if}\NormalTok{ (...) \{    }\CommentTok{# isruzione condizionale}
\NormalTok{      ...}
\NormalTok{    \}}
\NormalTok{  \}}
\NormalTok{\}}

\CommentTok{# Bad}
\ControlFlowTok{for}\NormalTok{ (...) \{       }\CommentTok{# loop più esterno}
\NormalTok{...}
\ControlFlowTok{for}\NormalTok{ (...) \{     }\CommentTok{# loop interno}
\NormalTok{...}
\ControlFlowTok{if}\NormalTok{ (...) \{    }\CommentTok{# isruzione condizionale}
\NormalTok{...}
\NormalTok{\}}
\NormalTok{\}}
\NormalTok{\}}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \textbf{Allinea} gli argomenti di una funzione se questi spaziano più righe.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Good}
\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ ...,}
           \DataTypeTok{name =}\NormalTok{ ...,}
           \DataTypeTok{age =}\NormalTok{ ...,}
           \DataTypeTok{sex =}\NormalTok{ ...)}

\CommentTok{# Bad}
\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{id =}\NormalTok{ ..., }\DataTypeTok{name =}\NormalTok{ ...,}
\DataTypeTok{age =}\NormalTok{ ..., }\DataTypeTok{sex =}\NormalTok{ ...)}
\end{Highlighting}
\end{Shaded}

\begin{design}[Tutta una Questione di Stile]

Potente trovare ulteriori norme e consigli riguardo lo stile nella scrittura del codice al seguente link \url{https://irudnyts.github.io/r-coding-style-guide/}

\end{design}

\hypertarget{r-projects}{%
\section{R projects}\label{r-projects}}

TODO

\hypertarget{piuxf9-di-uno-script}{%
\subsection{Più di uno script}\label{piuxf9-di-uno-script}}

\begin{itemize}
\item
  idea di organizzare in vairi script, cartelle
\item
  working directory tutto in funzione alla cartella
\end{itemize}

\hypertarget{messages-warnings-e-errors}{%
\section{Messages, Warnings e Errors}\label{messages-warnings-e-errors}}

R utilizza la console per comunicare con noi durante le nostre sessioni di lavoro. Oltre a fornirci i risultati dei nostri comandi, R ci segnala anche altre utili informazioni attraverso diverse tipologie di messaggi. In particolare abbiamo:

\begin{itemize}
\tightlist
\item
  \textbf{Messages}: dei semplici messaggi che ci possono aggiornare ad esempio sullo stato di avanzamento di un dato compito oppure fornire suggerimenti sull'uso di una determinata funzione o pacchetto (spesso vengono mostrati quando viene caricato un pacchetto).
\item
  \textbf{Warnings}: questi messaggi sono utlizzati da R per dirci che c'è stato qualche cosa di strano che ha messo in allerta R. R ci avvisa che, sebbene il comando sia stato eseguito ed abbiamo ottenuto un risultato, ci sono stati dei comportamenti inusuali o magari eventuali correzioni apportate in automatico. Nel caso di warnings non ci dobbiamo allramre, è importante controllare che i comandi siano corretti e che abbiamo effetivamente ottenuto il risultato desiderato. Una volta sicuri dei risultati possiamo procedere tranquillamente.
\item
  \textbf{Errors}: R ci avvisa di eventuali errori e problemi che non permettono di eseguire il comando. in questo caso non otterremo nnessun risultato ma sarà necessario capire e risolvere il problema per poi rieseguire nuovamente il comando e procedere.
\end{itemize}

Notiamo quindi come non tutti i messaggi che R ci manda sono dei messaggi di errore. E' quindi importante non spaventarsi ma leggere con attenzione i messaggi, molte volte si tratta semplicemente di avvertimenti o suggerimenti.

Tuttavia gli errori rappresentano sempre il maggiore dei problemi perchè non è possibile procedere nel lavoro senza averli prima risolti. E' importante ricordare che i messaggi di errore non sono delle critiche che R ci rivolge perchè sbagliamo. Al contrario, sono delle richieste di aiuto fatte da R perchè non sa come comportarsi. Per quanto super potente, R è un seplice programma che non può interpretare le nostre richieste ma si basa sull'uso dei comandi che seguono una rigida sintassi. A volte è sufficiente una virgola mancante o un charattere al posto di un numero per mandare in confusione R e richiedere il nostro intervento risolutore.

\hypertarget{risolvere-gli-errori}{%
\subsection{Risolvere gli Errori}\label{risolvere-gli-errori}}

Quando si approccia la scrittura di codice, anche molto semplice, la cosa che sicuramente capiterà più spesso sarà riscontrare messaggi di \textbf{errore} e quindi trovare il modo per risolverli.

\begin{quote}
Qualche programmatore esperto direbbe che l'essenza stessa di programmare è in realtà risolvere gli errori che il codice produce.
\end{quote}

L'\textbf{errore non è quindi un difetto o un imprevisto}, ma parte integrante della scrittura del codice. L'importante è capire come gestirlo.

Abbiamo tutti le immagini in testa di programmatori da film che scrivono codice alla velocità della luce, quando nella realtà dobbiamo spesso affrontare \textbf{bug}, \textbf{errori di output} o altri problemi vari. Una serie di skills utili da imparare sono:

\begin{itemize}
\tightlist
\item
  Comprendere a fondo gli \textbf{errori} (non banale)
\item
  Sapere \textbf{come e dove cercare una soluzione} (ancora meno banale)
\item
  In caso non si trovi una soluzione direttamente, chiedere aiuto in modo efficace
\end{itemize}

\hypertarget{comprendere-gli-errori}{%
\subsubsection*{Comprendere gli errori}\label{comprendere-gli-errori}}
\addcontentsline{toc}{subsubsection}{Comprendere gli errori}

Leggere con attenzione i messaggi di errore è molto importante. R è solitamente abbastanza esplicito nel farci capire il problema. Ad esempio usare una funzione di un pacchetto che non è stato caricato di solito fornisce un messaggio del tipo \texttt{Error\ in\ funzione\ :\ could\ not\ find\ function\ "funzione"}.

Tuttavia, in altre situazioni i messaggi potrebbero non essere altrettanto chiari. Seppur esplicito R è anche molto sintetico e quindi l'utilzzo di un linguaggio molto specifico (e almeno inizialmente poco familiare), potrebbe rendere difficile capire il loro significato o addirittura renderli del tutto incomprensibili. Man mano che diventerete più esperti in R, diventerà sempre più semplice ed immmediato capire quale sia il problema e anche come risolverlo. Ma nel caso non si conosca la soluzione è necessario cercarla in altro modo.

\hypertarget{problema-google-soluzione}{%
\subsubsection*{Problema + Google = Soluzione}\label{problema-google-soluzione}}
\addcontentsline{toc}{subsubsection}{Problema + Google = Soluzione}

In qualsiasi situazione Google è il nostro miglior amico.

Cercando infatti il messaggio di errore/warning su Google, al 99\% avremo altre persone che hanno avuto lo stesso problema e probabilmente anche una soluzione.

\begin{tip}[Ricerca su Google]

Il modo migliore per cercare è copiare e incollare su Google direttamente l'output di errore di R come ad esempio \texttt{Error\ in\ funzione\ :\ could\ not\ find\ function\ "funzione"} piuttosto che descrivere a parole il problema. I messaggi di errore sono standard per tutti, la tua descrizione invece no.

\end{tip}

Cercando in questo modo vedrete che molti dei risultati saranno esattamente riferiti al vostro errore:

\includegraphics{images/stack_question.png}

\hypertarget{chiedere-una-soluzione}{%
\subsubsection*{Chiedere una soluzione}\label{chiedere-una-soluzione}}
\addcontentsline{toc}{subsubsection}{Chiedere una soluzione}

Se invece il vostro probelma non è un messaggio di errore ma un utilizzo specifico di R allora il consiglio è di usare una ricerca del tipo: \texttt{argomento\ +\ breve\ descrizione\ problema\ +\ R}. Nelle sezioni successive vedrete nel dettaglio altri aspetti della programmazione ma se volete ad esempio calcolare la \textbf{media} in R potrete scrivere \texttt{compute\ mean\ in\ R}.
Mi raccomando, fate tutte le ricerche in \textbf{inglese} perchè le possibilità di trovare una soluzione sono molto più alte.

Dopo qualche ricerca, vi renderete conto che il sito che vedrete più spesso si chiama \href{https://stackoverflow.com/}{\textbf{Stack Overflow}}. Questo è una manna dal cielo per tutti i programmatori, a qualsiasi livello di expertise. E' una community dove tramite domande e risposte, si impara a risolvere i vari problemi ed anche a trovare nuovi modi di fare la stessa cosa. E' veramente utile oltre che un ottimo modo per imparare.

L'ultimo punto di questa piccola guida alla ricerca di soluzioni, riguarda il fatto di dover non solo cercare ma anche chiedere. Dopo aver cercato vari post di persone che richiedevano aiuto per un problema noterete che le domande e le risposte hanno sempre una struttura simile. Questo non è solo un fatto stilistico ma anzi è molto utile per uniformare e rendere chiara la domanda ma sopratutto la risposta, in uno spirito di condivisione. C'è anche una \href{https://stackoverflow.com/help/how-to-ask}{guida dedicata} per scrivere la domanda perfetta.

In generale\footnote{Fonte: \href{https://codeblog.jonskeet.uk/2010/08/29/writing-the-perfect-question/}{Writing the perfect question - Jon Skeet}}:

\begin{itemize}
\tightlist
\item
  Titolo: un super riassunto del problema
\item
  Contesto: linguaggio (es. R), quale sistema operativo (es. Windows)
\item
  Descrizione del problema/richiesta: in modo chiaro e semplice ma non troppo generico
\item
  Codice ed eventuali dati per capire il problema
\end{itemize}

L'ultimo punto di questa lista è forse il più importante e si chiama in gergo tecnico \href{https://community.rstudio.com/t/faq-whats-a-reproducible-example-reprex-and-how-do-i-create-one/5219}{\textbf{REPREX}} (\textbf{Rep}roducible \textbf{Ex}ample). E' un tema leggermente più avanzato ma l'idea di fondo è quella di fornire tutte le informazioni possibili per poter riprodurre (e quindi eventualmente trovare una soluzione) il codice di qualcuno nel proprio computer.

Se vi dico ``R non mi fa creare un nuovo oggetto, quale è l'errore?'' è diverso da dire ``il comando \texttt{oggetto\ -\textgreater{}\ 10} mi da questo errore \texttt{Error\ in\ 10\ \textless{}-\ oggetto\ :\ invalid\ (do\_set)\ left-hand\ side\ to\ assignment}, come posso risolvere?''

\begin{trick}[reprex]

Ci sono anche diversi pacchetti in R che rendono automatico creare questi esempi di codice da poter condividere, come il pacchetto \href{https://www.tidyverse.org/help/}{\texttt{reprex}}.

\end{trick}

\hypertarget{part-struttura-dati}{%
\part*{Struttura Dati}\label{part-struttura-dati}}
\addcontentsline{toc}{part}{Struttura Dati}

\hypertarget{introduzione}{%
\chapter*{Introduzione}\label{introduzione}}
\addcontentsline{toc}{chapter}{Introduzione}

Working in progress.

\hypertarget{vector}{%
\chapter{Vettori}\label{vector}}

Working in progress

\hypertarget{creazione-di-vettori}{%
\section{Creazione di Vettori}\label{creazione-di-vettori}}

In R per definire un vettore si utilizza il comando \texttt{\textless{}nome-vettore\textgreater{}\ \textless{}-\ c(\textless{}oggetti\textgreater{})}. Ricorda che gli elementi devono essere separati da una virgola.

\hypertarget{esercizi-2}{%
\subsection*{Esercizi}\label{esercizi-2}}
\addcontentsline{toc}{subsection}{Esercizi}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Crea il vettore \texttt{x} contenente i numeri 4, 6, 12, 34, 8
\item
  Crea il vettore \texttt{y} contenente tutti i numeri pari compresi tra 1 e 25 (\texttt{?seq()})
\item
  Crea il vettore \texttt{z} contenente tutti i primi 10 multipli di 7 partendo da 13 (\texttt{?seq()})
\item
  Crea il vettore \texttt{s} in cui le lettere \texttt{"A"},\texttt{"B"} e \texttt{"C"} vengono ripetute nel medesimo ordine 4 volte (\texttt{?rep()}).
\item
  Crea il vettore \texttt{t} in cui le letter \texttt{"A"},\texttt{"B"} e \texttt{"C"} vengono ripetute ognuna 4 volte (\texttt{?rep()}).
\end{enumerate}

\hypertarget{selezione-elementi-di-un-vettore}{%
\section{Selezione Elementi di un Vettore}\label{selezione-elementi-di-un-vettore}}

In R per selezioneare gli elementi di un vettore si deve indicare all'interno delle parentesi quadre la \textbf{posizione degli elementi} da selezionare, non il valore dell'elemento stesso:

\texttt{\textless{}nome-vettore\textgreater{}{[}\textless{}indice-posizione\textgreater{}{]}}\textbackslash{}
In alternativa si puù definire la condizione logica che gli elementi che si vogliono selezionare devono rispettare.

Per *\textbackslash textbf\{\textbf{eliminare degli elementi} da un vettore si utilizza all'interno delle parentesi quadre l'operatore ``-'' insieme agli indici di posizione degli elementi da eliminare (esempio: \texttt{x{[}c(-2,-4){]}} oppure \texttt{x{[}-c(2,4){]}}).

\hypertarget{esercizi-3}{%
\subsection*{Esercizi}\label{esercizi-3}}
\addcontentsline{toc}{subsection}{Esercizi}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Del vettore \texttt{x} seleziona il 2°, 3° e 5° elemento
\item
  Del vettore \texttt{y} seleziona tutti i valori minori di 13 o maggiori di 19
\item
  Del vettore \texttt{z} seleziona tutti i valori compresi tra 24 e 50
\item
  Elimina dal vettore \texttt{z} i valori 28 e 42
\item
  Del vettore \texttt{s} seleziona tutti gli elementi uguali ad ``A''
\item
  Del vettore \texttt{t} seleziona tutti gli elementi diversi da ``B''.
\end{enumerate}

\hypertarget{funzioni-ed-operazioni-tra-vettori}{%
\section{Funzioni ed Operazioni tra Vettori}\label{funzioni-ed-operazioni-tra-vettori}}

Per compiere operazioni tra vettori è necessario che essi abbiano identica lunghezza.

\begin{table}[!h]

\caption{\label{tab:table-vector-operators}Operazioni con vettori}
\centering
\begin{tabular}[t]{l|l}
\hline
Operazione & Nome\\
\hline
\texttt{<nuovo-vettore> <- c(<vettore1>, <vettore2>)} & Per unire più vettori in un unico vettore\\
\hline
\texttt{length(<nome-vettore>)} & Per valutare il numero di elementi contenuti in un vettore\\
\hline
\texttt{vettore1 + vettore2} & Somma di due vettori\\
\hline
\texttt{vettore1 - vettore2} & Differenza tra due vettori\\
\hline
\texttt{vettore1 * vettore2} & Prodotto tra due vettori\\
\hline
\texttt{vettore1 / vettore2} & Rapporto tra due vettori\\
\hline
\end{tabular}
\end{table}

\textbf{Nota:} In R il prodotto e rapporto tra vettori sono eseguiti elemento per elemento (al contrario di molti altri software).

\hypertarget{esercizi-4}{%
\subsection*{Esercizi}\label{esercizi-4}}
\addcontentsline{toc}{subsection}{Esercizi}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Crea il vettore \texttt{j} unendo i vettori \texttt{x} ed \texttt{z}.
\item
  Elimina gli ultimi tre elementi del vettore \texttt{j} e controlla che i vettori \texttt{j} e \texttt{y} abbiano la stessa lunghezza.
\item
  Calcola la somma tra i vettori \texttt{j} e \texttt{y}.
\item
  Moltiplica il vettore z per una costante \texttt{k=3}.
\item
  Calcola il prodotto tra i primi 10 elementi del vettore \texttt{y} ed il vettore \texttt{z}.
\end{enumerate}

\hypertarget{data-type}{%
\section{Data Type}\label{data-type}}

Working in progress.

Tipi di vettori

In R ci sono 4 tipi differenti di vettori: numerici, logici, caratteri e fattori.

\hypertarget{vettori-numerici}{%
\subsection{Vettori Numerici}\label{vettori-numerici}}

I vettori numerici sono utilizzati per compiere operazioni aritmetiche, in R sono indicati come \texttt{num}. In R ci sono è possibil e specificare se i numeri contenuti nel vettore sono numeri interi, avremmo quindi un vettore di valori interi (indicato in R come \texttt{int}). Per fare ciò è possibile aggiungere \texttt{L} ad ogni valore numerico nel definire il vettore oppure usare la funzione \texttt{as.integer()} per trasformare un vettore numerico in un vettore intero.

\textbf{Esempio:}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x <-}\StringTok{ }\KeywordTok{c}\NormalTok{(4L, 6L, 12L, 34L, 8L)}

\NormalTok{x <-}\StringTok{ }\KeywordTok{as.integer}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{, }\DecValTok{6}\NormalTok{, }\DecValTok{12}\NormalTok{, }\DecValTok{34}\NormalTok{, }\DecValTok{8}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\textbf{Nota}: per trasformare un vettore intero in un vettore numerico è possibile usare la funzione \texttt{as.numeric()}.

\hypertarget{vettori-logici}{%
\subsection{Vettori logici}\label{vettori-logici}}

I vettori logici sono formati dai volori \texttt{TRUE} e \texttt{FALSE}, che possono essere abbreviati rispettivamente in \texttt{T} e \texttt{F}. In R i vettori logici sono indicati come \texttt{logi}. In genere, i vettori logici sono il risultato delle operazioni in cui viene chiesto ad R di valutare la condizione logica di una proposizione.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{x}\OperatorTok{>}\DecValTok{10}
\CommentTok{## [1] FALSE FALSE  TRUE  TRUE FALSE}
\end{Highlighting}
\end{Shaded}

\textbf{Nota:} in R, come in molti altri software di programmazione, \texttt{TRUE} assume il valore numerico \texttt{1} e \texttt{FALSE} assume il valore \texttt{0}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{sum}\NormalTok{(x}\OperatorTok{>}\DecValTok{10}\NormalTok{)}
\CommentTok{## [1] 2}
\end{Highlighting}
\end{Shaded}

E' possibile trasformare un vettore numerico in un vettor logico attraverso la funzione \texttt{as.logical()}, gli \texttt{0} assumeranno il valore \texttt{FALSE} mentre qualsiasi altro numero assumerà il valore \texttt{TRUE}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.logical}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{,.}\DecValTok{034}\NormalTok{,}\OperatorTok{-}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{8}\NormalTok{))}
\CommentTok{## [1]  TRUE FALSE  TRUE  TRUE FALSE  TRUE}
\end{Highlighting}
\end{Shaded}

\hypertarget{vettori-di-caratteri}{%
\subsection{Vettori di caratteri}\label{vettori-di-caratteri}}

I vettori di caratteri contengono stringhe di caratteri e sono indicati in R con `chr\}. Non è possibile eseguire operazioni aritmetiche con vettori di caratteri ma solo valutare se due stringhe sono uguali o differenti.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{j<-}\KeywordTok{c}\NormalTok{(}\StringTok{"Hello"}\NormalTok{,}\StringTok{"World"}\NormalTok{,}\StringTok{"hello"}\NormalTok{,}\StringTok{"world"}\NormalTok{)}
\NormalTok{j}\OperatorTok{==}\StringTok{"hello"}
\CommentTok{## [1] FALSE FALSE  TRUE FALSE}
\end{Highlighting}
\end{Shaded}

Per trasformare un vettore qualsiasi in una vettore di caratteri e possibile usare la funzione \texttt{as.character()}.

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.character}\NormalTok{(x)}
\CommentTok{## [1] "4"  "6"  "12" "34" "8"}
\KeywordTok{as.character}\NormalTok{(x}\OperatorTok{>}\DecValTok{10}\NormalTok{)}
\CommentTok{## [1] "FALSE" "FALSE" "TRUE"  "TRUE"  "FALSE"}
\end{Highlighting}
\end{Shaded}

\hypertarget{valori-speciali}{%
\subsection{Valori speciali}\label{valori-speciali}}

\hypertarget{factors}{%
\chapter{Fattori}\label{factors}}

Working in progress.

I fattori sono utilizzati per definire delle variabili categoriali, sono indicati in R con \texttt{Factor}. Per creare una variabile categoriale in R si utilizza la funzione:

\texttt{nome\_variabile\textless{}-factor(c(...,\ data,\ ...),\ levels=c(...))}

L'opzione \texttt{levels=c(...)} è usata per specificare quali sono i possibili livelli della variabile categoriale. E' possibile modificare o aggiungere nuovi livelli della variabile anche in un secondo momento utilizzando la funzione:

\texttt{levels(nome\_fattore)\textless{}-\ c(...,\ nuovi\_livelli,\ ...)}

\textbf{Nota}: nel creare un fattore R associa ad ogni livello un valore in ordine crescente e assegna agli elementi del vettore il loro volore numerico a seconda del proprio livello. Pertanto se un fattore è trasformato in un vettore numerico vengono restituiti tali valori numerici e non i livelli anche nel caso fossero dei numeri. Prendiamo per esempio la variabile \texttt{anni\_istruzione}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{anni_istruzione<-}\KeywordTok{factor}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{11}\NormalTok{,}\DecValTok{8}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{8}\NormalTok{,}\DecValTok{11}\NormalTok{,}\DecValTok{4}\NormalTok{,}\DecValTok{11}\NormalTok{,}\DecValTok{8}\NormalTok{))}
\NormalTok{anni_istruzione}
\CommentTok{## [1] 11 8  4  8  11 4  11 8 }
\CommentTok{## Levels: 4 8 11}
\KeywordTok{as.numeric}\NormalTok{(anni_istruzione)}
\CommentTok{## [1] 3 2 1 2 3 1 3 2}
\end{Highlighting}
\end{Shaded}

Per riottenere gli estti valori numerici è necessario eseguire:

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{as.numeric}\NormalTok{(}\KeywordTok{as.character}\NormalTok{(anni_istruzione))}
\CommentTok{## [1] 11  8  4  8 11  4 11  8}
\end{Highlighting}
\end{Shaded}

\hypertarget{esercizi-5}{%
\subsection*{Esercizi}\label{esercizi-5}}
\addcontentsline{toc}{subsection}{Esercizi}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Crea la variabile categoriale \texttt{sex} così definita:
\end{enumerate}

\begin{verbatim}
## [1] M F M F M F F F M
## Levels: F M
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Rinomina i livelli della variabile \texttt{sex} rispettivamente in \texttt{"donne"} e \texttt{"uomini"}.
\item
  Crea la variabile categoriale \texttt{intervento} così definita:
\end{enumerate}

\begin{verbatim}
## [1] CBT         Psicanalisi CBT         Psicanalisi CBT         Psicanalisi
## [7] Controllo   Controllo   CBT        
## Levels: CBT Controllo Psicanalisi
\end{verbatim}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{3}
\tightlist
\item
  Correggi nella variabile \texttt{intervento} la 7° e 8° osservazione con la voce \texttt{Farmaci}.
\item
  Aggiungi alla variabile \texttt{intervento} le seguenti nuove osservazioni:
\end{enumerate}

\begin{verbatim}
## [1] "Farmaci"   "Controllo" "Farmaci"
\end{verbatim}

\hypertarget{matrix}{%
\chapter{Matrici}\label{matrix}}

\hypertarget{creazione-di-una-matrice}{%
\section{Creazione di una matrice}\label{creazione-di-una-matrice}}

La matrice è una struttura di dati \textbf{bidimensionale} che può contenere solo una tipologia di dato. Nel capitolo \ref{data-type} sono state introdotte le varie tipologie di dato e come per i vettori, possiamo avere delle matrici di soli numeri o di soli caratteri. Il comando per creare una matrice in R è \texttt{matrix()} e contiene diversi argomenti:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{nome_matrice <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(data, }\DataTypeTok{nrow =} \StringTok{"numero righe"}\NormalTok{, }\DataTypeTok{ncol =} \StringTok{"numero colonne"}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  L'argomento \texttt{data} sono i valori con cui vogliamo popolare la matrice e sono considerati come un vettore.
\item
  Gli argomenti \texttt{nrow} e \texttt{ncol} sono rispettivamente il numero di colonne e il numero di righe della matrice
\item
  L'argomento \texttt{byrow} indica se la matrice deve essere popolata per riga oppure per colonna.
\end{itemize}

Creiamo come esempio una matrice vuota con soli valori \texttt{NA} con 5 righe e 5 colonne

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DataTypeTok{data =} \OtherTok{NA}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{5}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{mat}
\CommentTok{##      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{## [1,]   NA   NA   NA   NA   NA}
\CommentTok{## [2,]   NA   NA   NA   NA   NA}
\CommentTok{## [3,]   NA   NA   NA   NA   NA}
\CommentTok{## [4,]   NA   NA   NA   NA   NA}
\CommentTok{## [5,]   NA   NA   NA   NA   NA}
\end{Highlighting}
\end{Shaded}

L'argomento \texttt{byrow\ =\ FALSE} è il default per il comando \texttt{matrix()} quindi R popola le matrici per colonna, se non espressamente richiesto.
A questo punto popoliamo la matrice con i valori che vanno da 1 a 25.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Dati per popolare la matrice}
\NormalTok{vec <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{25}
\NormalTok{vec}
\CommentTok{##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25}

\CommentTok{# Matrice popolata per riga}
\NormalTok{mat_bycol <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ vec, }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{5}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{TRUE}\NormalTok{)}
\NormalTok{mat_bycol}
\CommentTok{##      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{## [1,]    1    2    3    4    5}
\CommentTok{## [2,]    6    7    8    9   10}
\CommentTok{## [3,]   11   12   13   14   15}
\CommentTok{## [4,]   16   17   18   19   20}
\CommentTok{## [5,]   21   22   23   24   25}

\CommentTok{# Matrice popolata per colonna}
\NormalTok{mat_byrow <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DataTypeTok{data =}\NormalTok{ vec, }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{5}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{mat_byrow}
\CommentTok{##      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{## [1,]    1    6   11   16   21}
\CommentTok{## [2,]    2    7   12   17   22}
\CommentTok{## [3,]    3    8   13   18   23}
\CommentTok{## [4,]    4    9   14   19   24}
\CommentTok{## [5,]    5   10   15   20   25}
\end{Highlighting}
\end{Shaded}

Come si vede la matrice ora è popolata dai numeri che abbiamo creato e viene di default, popolata per colonna. Allo stesso modo possiamo semplicemente impostare \texttt{byrow\ =\ TRUE} per popolare la matrice per riga.

E' importante tenere in considerazione che l'argomento \texttt{data} deve essere compatibile con gli argomenti \texttt{nrow} e \texttt{ncol}. In altre parole \textbf{non posso fornire più o meno dati di quelli che la matrice può contenere}. E' invece possibile specificare qualsiasi combinazione di righe e colonne rispettando che il numero totale di elementi corrisponda agli spazi disponibili.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{16}

\CommentTok{# Numero non compatibile}
\NormalTok{mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(vec, }\DataTypeTok{ncol =} \DecValTok{5}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}
\CommentTok{## Warning in matrix(vec, ncol = 5, nrow = 5, byrow = FALSE): data length [16] is}
\CommentTok{## not a sub-multiple or multiple of the number of rows [5]}
\NormalTok{mat}
\CommentTok{##      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{## [1,]    1    6   11   16    5}
\CommentTok{## [2,]    2    7   12    1    6}
\CommentTok{## [3,]    3    8   13    2    7}
\CommentTok{## [4,]    4    9   14    3    8}
\CommentTok{## [5,]    5   10   15    4    9}

\CommentTok{# Matrice non quadrata con lo stesso vettore}
\NormalTok{mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(vec, }\DataTypeTok{ncol =} \DecValTok{2}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{8}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{mat}
\CommentTok{##      [,1] [,2]}
\CommentTok{## [1,]    1    9}
\CommentTok{## [2,]    2   10}
\CommentTok{## [3,]    3   11}
\CommentTok{## [4,]    4   12}
\CommentTok{## [5,]    5   13}
\CommentTok{## [6,]    6   14}
\CommentTok{## [7,]    7   15}
\CommentTok{## [8,]    8   16}
\end{Highlighting}
\end{Shaded}

Abbiamo visto che possiamo facilmente popolare una matrice con un vettore. Allo stesso modo possiamo vettorizzare una matrice (in altri termini ``srotolare'' la matrice) per ritornare al vettore originale. Con il comando \texttt{c(matrice)} oppure forzando la tipologia di oggetto a vettore con \texttt{vector(matrice)} o \texttt{as.vector(matrice)}.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Da matrice a vettore}
\KeywordTok{c}\NormalTok{(mat)}
\CommentTok{##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16}
\KeywordTok{as.vector}\NormalTok{(mat)}
\CommentTok{##  [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16}
\end{Highlighting}
\end{Shaded}

\begin{tip}[Matrice di caratteri]

La matrice è una tipologia di oggetto molto importante sia in R ma anche nella matematica, ad esempio nell'algebra lineare. Come vedremo ci sono diverse operazioni matematice (somma, moltiplicazione, inversione, etc.) che si possono eseguire. Abbiamo inoltre accennato che la matrice può contenere anche valori non numerici.

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Creare una matrice di caratteri}

\NormalTok{chr_mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(}\DataTypeTok{data =} \StringTok{"chr"}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{5}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{chr_mat}
\CommentTok{##      [,1]  [,2]  [,3]  [,4]  [,5] }
\CommentTok{## [1,] "chr" "chr" "chr" "chr" "chr"}
\CommentTok{## [2,] "chr" "chr" "chr" "chr" "chr"}
\CommentTok{## [3,] "chr" "chr" "chr" "chr" "chr"}
\CommentTok{## [4,] "chr" "chr" "chr" "chr" "chr"}
\CommentTok{## [5,] "chr" "chr" "chr" "chr" "chr"}

\CommentTok{# Popolare una matrice di caratteri}
\NormalTok{vec_chr <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\StringTok{"a"}\NormalTok{, }\StringTok{"b"}\NormalTok{, }\StringTok{"c"}\NormalTok{, }\StringTok{"d"}\NormalTok{, }\StringTok{"e"}\NormalTok{, }\StringTok{"f"}\NormalTok{, }\StringTok{"g"}\NormalTok{, }\StringTok{"h"}\NormalTok{, }\StringTok{"i"}\NormalTok{, }\StringTok{"l"}\NormalTok{, }\StringTok{"m"}\NormalTok{, }\StringTok{"n"}\NormalTok{, }\StringTok{"o"}\NormalTok{, }\StringTok{"p"}\NormalTok{, }\StringTok{"q"}\NormalTok{, }\StringTok{"r"}\NormalTok{)}

\NormalTok{chr_mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(vec_chr, }\DataTypeTok{nrow =} \DecValTok{4}\NormalTok{, }\DataTypeTok{ncol =} \DecValTok{4}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{chr_mat}
\CommentTok{##      [,1] [,2] [,3] [,4]}
\CommentTok{## [1,] "a"  "e"  "i"  "o" }
\CommentTok{## [2,] "b"  "f"  "l"  "p" }
\CommentTok{## [3,] "c"  "g"  "m"  "q" }
\CommentTok{## [4,] "d"  "h"  "n"  "r"}
\end{Highlighting}
\end{Shaded}

Per questo tipo di matrice valgono tutte le proprietà che vedremo o abbiamo visto fino ad ora. Tuttavia, non è molto frequente l'utilizzo di matrici di caratteri visto che chiaramente tutte le operazioni comuni non sono possibili.

\end{tip}

\hypertarget{esercizi-6}{%
\subsection*{Esercizi}\label{esercizi-6}}
\addcontentsline{toc}{subsection}{Esercizi}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Crea la matrice \texttt{A} così definita:
\end{enumerate}

\[
\begin{matrix}
2 & 34 & 12 & 7\\
46 & 93 & 27 & 99\\
23  & 38 & 7 & 04
\end{matrix}
\]

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{1}
\tightlist
\item
  Crea la matrice \texttt{B} contenente tutti i primi 12 numeri dispari disposti su 4 righe e 3 colonne.
\item
  Crea la matrice \texttt{C} contenente i primi 12 multipli di 9 disposti su 3 righe e 4 colonne.
\item
  Crea la matrice \texttt{D} formata da 3 colonne in cui le lettere \texttt{"A"},\texttt{"B"} e \texttt{"C"} vengano ripetute 4 volte ciascuna rispettivamente nella prima, seconda e terza colonna.
\item
  Crea la matrice \texttt{E} formata da 3 righe in cui le lettere \texttt{"A"},\texttt{"B"} e \texttt{"C"} vengano ripetute 4 volte ciascuna rispettivamente nella prima, seconda e terza riga.
\end{enumerate}

\hypertarget{mat-prop}{%
\section{Proprietà della matrice}\label{mat-prop}}

La matrice essendo \textbf{bidimensionale} è formata da due elementi, righe e colonne. Sapendo il numero di righe e colonne infatti sappiamo la quantità di elementi nella matrice. Per ottenere queste informazioni possiamo usare i comandi \texttt{ncol()} e \texttt{nrow()}.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{25}
\NormalTok{mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(vec, }\DataTypeTok{ncol =} \DecValTok{5}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}

\CommentTok{# Numero di righe}
\KeywordTok{nrow}\NormalTok{(mat)}
\CommentTok{## [1] 5}

\CommentTok{# Numero di colonne}
\KeywordTok{ncol}\NormalTok{(mat)}
\CommentTok{## [1] 5}
\end{Highlighting}
\end{Shaded}

Come avete notato, la matrice viene principalmente gestita tramite indici numerici, nella sezione successiva vedremo come accedere ad ogni elemento di una matrice. In R, possiamo però anche assegnare dei nomi alle proprietà (o dimensioni) della matrice. Con i comandi \texttt{rownames()} e \texttt{colnames()} possiamo accedere ai nomi di righe e colonne o assegnarne di nuovi. Un comando più rapido è \texttt{dimnames()} che restituisce direttamente i nomi di riga e/o colonna.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{25}
\NormalTok{mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(vec, }\DataTypeTok{ncol =} \DecValTok{5}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}

\CommentTok{# Nome di righe}
\KeywordTok{rownames}\NormalTok{(mat)}
\CommentTok{## NULL}

\CommentTok{# Nome di colonne}
\KeywordTok{colnames}\NormalTok{(mat)}
\CommentTok{## NULL}
\end{Highlighting}
\end{Shaded}

Non essendo impostati, ottieniamo un \texttt{NULL} come output. Se impostare i nomi di righe e/o colonne, è sufficiente assegnare a \texttt{rownames(matrice)} o \texttt{colnames(matrice)} un vettore di caratteri della stessa lunghezza della dimensione che stiamo rinominando. Se impostiamo un unico carattere, tutte le righe/colonne avranno lo stesso valore. Questo ci fa capire che R richiede che tutte le righe/colonne abbiano un nome.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{25}
\NormalTok{mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(vec, }\DataTypeTok{ncol =} \DecValTok{5}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}

\KeywordTok{dimnames}\NormalTok{(mat)}
\CommentTok{## NULL}

\CommentTok{# Assegnamo i nomi}

\NormalTok{row_names <-}\StringTok{ }\NormalTok{letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{]}
\NormalTok{col_names <-}\StringTok{ }\NormalTok{letters[}\DecValTok{6}\OperatorTok{:}\DecValTok{10}\NormalTok{]}

\KeywordTok{colnames}\NormalTok{(mat) <-}\StringTok{ }\NormalTok{col_names}
\KeywordTok{rownames}\NormalTok{(mat) <-}\StringTok{ }\NormalTok{row_names}
\KeywordTok{dimnames}\NormalTok{(mat)}
\CommentTok{## [[1]]}
\CommentTok{## [1] "a" "b" "c" "d" "e"}
\CommentTok{## }
\CommentTok{## [[2]]}
\CommentTok{## [1] "f" "g" "h" "i" "j"}
\NormalTok{mat}
\CommentTok{##   f  g  h  i  j}
\CommentTok{## a 1  6 11 16 21}
\CommentTok{## b 2  7 12 17 22}
\CommentTok{## c 3  8 13 18 23}
\CommentTok{## d 4  9 14 19 24}
\CommentTok{## e 5 10 15 20 25}
\end{Highlighting}
\end{Shaded}

\hypertarget{indicizzazione-di-matrici}{%
\section{Indicizzazione di matrici}\label{indicizzazione-di-matrici}}

L'aspetto sicuramente più importante (e divertente) riguardo le matrici è accedere ai vari elementi. Indipendentemente da cosa la matrice contenga infatti possiamo pensare ai valori come ad una griglia dove l'incrocio tra righe \(i\) e colonne \(j\) crea una cella unica \(ij\) che contiene uno specifico valore. Un modo utile per capire questo concetto è immaginare una matrice \(i \times j\) dove ogni elemento è il numero di riga \(i\) e il numero di colonna \(j\):

\begin{verbatim}
##      [,1] [,2] [,3] [,4] [,5]
## [1,] "11" "12" "13" "14" "15"
## [2,] "21" "22" "23" "24" "25"
## [3,] "31" "32" "33" "34" "35"
## [4,] "41" "42" "43" "44" "45"
## [5,] "51" "52" "53" "54" "55"
\end{verbatim}

In questa matrice è chiaro che il primo elemento è nella prima riga e nella prima colonna, il secondo elemento (per riga) è nella prima riga e nella seconda colonna e così via.

Questo introduce un aspetto fondamentale di come funzionano le matrici e i vettori (e come vedremo anche i \texttt{dataframe}) ovvero si può fare riferimento agli indici di riga e colonna per accedere a qualsiasi elemento.

In sostanza, per accedere ad una matrice usiamo le parentesi quadre \texttt{matrice{[}{]}} e in ordine forniamo il numero di riga e il numero di colonna. L'ordine \texttt{{[}riga,\ colonna{]}} è arbitrario e deve essere rispettato.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{25}
\NormalTok{mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(vec, }\DataTypeTok{ncol =} \DecValTok{5}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}

\NormalTok{mat}
\CommentTok{##      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{## [1,]    1    6   11   16   21}
\CommentTok{## [2,]    2    7   12   17   22}
\CommentTok{## [3,]    3    8   13   18   23}
\CommentTok{## [4,]    4    9   14   19   24}
\CommentTok{## [5,]    5   10   15   20   25}

\CommentTok{# Selezioniamo l'elemento alla riga 3 e colonna 5}

\NormalTok{mat[}\DecValTok{3}\NormalTok{,}\DecValTok{5}\NormalTok{]}
\CommentTok{## [1] 23}

\CommentTok{# Selezioniamo l'elemento alla riga 10 e colonna 1}

\NormalTok{mat[}\DecValTok{10}\NormalTok{,}\DecValTok{1}\NormalTok{]}
\CommentTok{## Error in mat[10, 1]: subscript out of bounds}
\end{Highlighting}
\end{Shaded}

Come vedete, possiamo accedere a qualsiasi elemento. Se indichiamo un indice che non è presente nella matrice in oggetto, chiaramente otteniamo un errore.

\hypertarget{indicizzazione-avanzata}{%
\section{Indicizzazione avanzata}\label{indicizzazione-avanzata}}

Oltre a selezionare uno specifico elemento possiamo essere interessati a selezionare più elementi insieme. La sintassi rimane la stessa quindi \texttt{matrice{[}riga,\ colonna{]}} ma possiamo combinare le conoscenze sui vettori e sulla creazione di oggetti. Quello che possiamo fare:

\begin{itemize}
\tightlist
\item
  Selezionare \textbf{tutti gli elementi di una riga o colonna}
\item
  Selezionare la \textbf{diagonale} della matrice
\item
  Selezionare \textbf{solo alcune righe e/o colonne}
\item
  Selezionare elementi con \textbf{operazioni logiche}
\end{itemize}

Per selezionare \textbf{tutti} gli elementi di una riga o colonna si usa la sintassi \texttt{matrice{[},\ colonna{]}} o \texttt{matrice{[}riga,\ {]}} per selezionare rispettivamente tutte le righe ma solo una o più colonne e tutte le colonne ma solo una o più righe. Lasciando vuoto il posto prima o dopo la virgola diciamo ad R di selezionare tutto.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{25}
\NormalTok{mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(vec, }\DataTypeTok{ncol =} \DecValTok{5}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}

\NormalTok{mat}
\CommentTok{##      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{## [1,]    1    6   11   16   21}
\CommentTok{## [2,]    2    7   12   17   22}
\CommentTok{## [3,]    3    8   13   18   23}
\CommentTok{## [4,]    4    9   14   19   24}
\CommentTok{## [5,]    5   10   15   20   25}

\CommentTok{# Selezioniamo tutta la prima riga}

\NormalTok{mat[}\DecValTok{1}\NormalTok{, ]}
\CommentTok{## [1]  1  6 11 16 21}

\CommentTok{# Selezioniamo tutta la terza colonna}

\NormalTok{mat[, }\DecValTok{2}\NormalTok{]}
\CommentTok{## [1]  6  7  8  9 10}
\end{Highlighting}
\end{Shaded}

\begin{tip}[Matrici e vettori]

Selezionando solo una riga/colonna ci rendiamo conto che otteniamo una cosa molto simile ad un \textbf{vettore}. Infatti, un vettore può essere anche visto come una matrice con una sola riga o colonna. In R comunque sia il vettore che una matrice con una sola dimensione sono trattati allo stesso modo.

\end{tip}

Riguardo la \textbf{diagonale} di una matrice essa può essere vista, dal punto di vista prettamente pratico, come l'insieme di elementi associati allo stesso indice di riga e colonna. Il comando \texttt{diag(matrice)} permette di estrarre la diagonale di una matrice e trattarla come un semplice vettore:

\begin{Shaded}
\begin{Highlighting}[]

\CommentTok{# Matrice quadrata}
\NormalTok{vec <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{25}
\NormalTok{mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(vec, }\DataTypeTok{ncol =} \DecValTok{5}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}

\NormalTok{mat}
\CommentTok{##      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{## [1,]    1    6   11   16   21}
\CommentTok{## [2,]    2    7   12   17   22}
\CommentTok{## [3,]    3    8   13   18   23}
\CommentTok{## [4,]    4    9   14   19   24}
\CommentTok{## [5,]    5   10   15   20   25}

\KeywordTok{diag}\NormalTok{(mat)}
\CommentTok{## [1]  1  7 13 19 25}

\CommentTok{# Matrice non quadrata}

\NormalTok{vec <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{16}
\NormalTok{mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(vec, }\DataTypeTok{ncol =} \DecValTok{2}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{8}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{mat}
\CommentTok{##      [,1] [,2]}
\CommentTok{## [1,]    1    9}
\CommentTok{## [2,]    2   10}
\CommentTok{## [3,]    3   11}
\CommentTok{## [4,]    4   12}
\CommentTok{## [5,]    5   13}
\CommentTok{## [6,]    6   14}
\CommentTok{## [7,]    7   15}
\CommentTok{## [8,]    8   16}

\KeywordTok{diag}\NormalTok{(mat)}
\CommentTok{## [1]  1 10}
\end{Highlighting}
\end{Shaded}

Per selezionare più righe e colonne insieme possiamo usare diversi metodi. Essenzialmente se devo selezionare più elementi devo fornire ad R più indici insieme. E' chiaro però che la notazione \texttt{matrice{[}riga,\ colonna{]}} non è direttamente compatibile se vogliamo più elementi. La scrittura \texttt{matrice{[}riga1,\ riga2,\ colonna{]}} infatti è sbagliata perchè R si aspetta una sola virgola che separa righe e colonne. Il modo più rapido è quindi combinare gli indici che vogliamo in un vettore (usando il comando \texttt{c()} ad esempio) e poi selezionare gli elementi. Se le colonne sono indicizzate come numeri in successione, ad esempio seleziono le prime 3 colonne posso utilizzare la scrittura compatta \texttt{1:3} che è equivalente a \texttt{c(1,2,3)}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{25}
\NormalTok{mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(vec, }\DataTypeTok{ncol =} \DecValTok{5}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{mat}
\CommentTok{##      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{## [1,]    1    6   11   16   21}
\CommentTok{## [2,]    2    7   12   17   22}
\CommentTok{## [3,]    3    8   13   18   23}
\CommentTok{## [4,]    4    9   14   19   24}
\CommentTok{## [5,]    5   10   15   20   25}

\CommentTok{# Prime 2 righe e prime 2 colonne}

\NormalTok{mat[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{), }\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{)]}
\CommentTok{##      [,1] [,2]}
\CommentTok{## [1,]    1    6}
\CommentTok{## [2,]    2    7}

\CommentTok{# Riga 1 e 4, colonna 4 e 5}

\NormalTok{mat[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{4}\NormalTok{), }\KeywordTok{c}\NormalTok{(}\DecValTok{4}\NormalTok{,}\DecValTok{5}\NormalTok{)]}
\CommentTok{##      [,1] [,2]}
\CommentTok{## [1,]   16   21}
\CommentTok{## [2,]   19   24}

\CommentTok{# Prime tre righe e quinta colonna}

\NormalTok{mat[}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{, }\DecValTok{5}\NormalTok{]}
\CommentTok{## [1] 21 22 23}
\end{Highlighting}
\end{Shaded}

Essendo la matrice (principalmente) formata da elementi numerici, possiamo anche eseguire le principali operazioni sia matematiche (e.g.~somma, differenza, moltiplicazione) ma anche quelle logiche come ``quali elementi della matrice sono maggiori di x?''.

Allo stesso modo possiamo selezionare (e quindi estrarre) gli elementi che rispettano una certa condizione usando la sintassi \texttt{matrice{[}operazione\ logica{]}}. Le operazioni logiche complesse sono molto utili sopratutto con i \texttt{dataframe} come vedremo nelle prossime sezioni.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{25}
\NormalTok{mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(vec, }\DataTypeTok{ncol =} \DecValTok{5}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{mat}
\CommentTok{##      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{## [1,]    1    6   11   16   21}
\CommentTok{## [2,]    2    7   12   17   22}
\CommentTok{## [3,]    3    8   13   18   23}
\CommentTok{## [4,]    4    9   14   19   24}
\CommentTok{## [5,]    5   10   15   20   25}

\CommentTok{# Quali elementi sono > 5}
\NormalTok{mat }\OperatorTok{>}\StringTok{ }\DecValTok{5}
\CommentTok{##       [,1] [,2] [,3] [,4] [,5]}
\CommentTok{## [1,] FALSE TRUE TRUE TRUE TRUE}
\CommentTok{## [2,] FALSE TRUE TRUE TRUE TRUE}
\CommentTok{## [3,] FALSE TRUE TRUE TRUE TRUE}
\CommentTok{## [4,] FALSE TRUE TRUE TRUE TRUE}
\CommentTok{## [5,] FALSE TRUE TRUE TRUE TRUE}

\CommentTok{# Quali elementi sono < 1}
\NormalTok{mat }\OperatorTok{>}\StringTok{ }\DecValTok{5}
\CommentTok{##       [,1] [,2] [,3] [,4] [,5]}
\CommentTok{## [1,] FALSE TRUE TRUE TRUE TRUE}
\CommentTok{## [2,] FALSE TRUE TRUE TRUE TRUE}
\CommentTok{## [3,] FALSE TRUE TRUE TRUE TRUE}
\CommentTok{## [4,] FALSE TRUE TRUE TRUE TRUE}
\CommentTok{## [5,] FALSE TRUE TRUE TRUE TRUE}

\CommentTok{# Quali elementi sono = 0}
\NormalTok{mat }\OperatorTok{==}\StringTok{ }\DecValTok{5}
\CommentTok{##       [,1]  [,2]  [,3]  [,4]  [,5]}
\CommentTok{## [1,] FALSE FALSE FALSE FALSE FALSE}
\CommentTok{## [2,] FALSE FALSE FALSE FALSE FALSE}
\CommentTok{## [3,] FALSE FALSE FALSE FALSE FALSE}
\CommentTok{## [4,] FALSE FALSE FALSE FALSE FALSE}
\CommentTok{## [5,]  TRUE FALSE FALSE FALSE FALSE}

\CommentTok{# Selezioniamo gli elementi}

\NormalTok{mat[mat }\OperatorTok{>}\StringTok{ }\DecValTok{5}\NormalTok{]}
\CommentTok{##  [1]  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25}

\NormalTok{mat[mat }\OperatorTok{==}\StringTok{ }\DecValTok{0}\NormalTok{]}
\CommentTok{## integer(0)}
\end{Highlighting}
\end{Shaded}

Un ultimo aspetto da considerare, anche se non molto diffuso consiste nell'\textbf{indicizzare una matrice in base ai nomi delle righe e/o colonne}. Come abbiamo visto nella sezione \ref{mat-prop} possiamo assegnare dei nomi (quindi delle stringhe) alle righe e colonne. Possiamo quindi selezionare la riga 1 sia con il suo indice \texttt{matrice{[}1,\ {]}} ma anche con il nome assegnato \texttt{matrice{[}"nome",{]}}. Queste sono operazioni fondamentali con i \textbf{dataframe} ma meno utili con le matrici.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{25}
\NormalTok{mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(vec, }\DataTypeTok{ncol =} \DecValTok{5}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{row_names <-}\StringTok{ }\NormalTok{letters[}\DecValTok{1}\OperatorTok{:}\DecValTok{5}\NormalTok{]}
\NormalTok{col_names <-}\StringTok{ }\NormalTok{letters[}\DecValTok{6}\OperatorTok{:}\DecValTok{10}\NormalTok{]}
\KeywordTok{colnames}\NormalTok{(mat) <-}\StringTok{ }\NormalTok{col_names}
\KeywordTok{rownames}\NormalTok{(mat) <-}\StringTok{ }\NormalTok{row_names}
\NormalTok{mat}
\CommentTok{##   f  g  h  i  j}
\CommentTok{## a 1  6 11 16 21}
\CommentTok{## b 2  7 12 17 22}
\CommentTok{## c 3  8 13 18 23}
\CommentTok{## d 4  9 14 19 24}
\CommentTok{## e 5 10 15 20 25}

\CommentTok{# Selezioniamo la riga "a"}

\NormalTok{mat[}\StringTok{"a"}\NormalTok{, ]}
\CommentTok{##  f  g  h  i  j }
\CommentTok{##  1  6 11 16 21}

\CommentTok{# Selezioniamo le colonne "i" e "j"}

\NormalTok{mat[, }\KeywordTok{c}\NormalTok{(}\StringTok{"i"}\NormalTok{, }\StringTok{"j"}\NormalTok{)]}
\CommentTok{##    i  j}
\CommentTok{## a 16 21}
\CommentTok{## b 17 22}
\CommentTok{## c 18 23}
\CommentTok{## d 19 24}
\CommentTok{## e 20 25}
\end{Highlighting}
\end{Shaded}

\hypertarget{combinare-matrici}{%
\section{Combinare matrici}\label{combinare-matrici}}

Abbiamo visto nel capitolo \ref{vector} come si possano fare diverse operazioni tra vettori, in particolare combinare ovvero unire vettori diversi. Anche per le matrici è possibile combinare matrici diverse, rispettando alcune regole:

\begin{itemize}
\tightlist
\item
  Posso unire matrici per riga ovvero aggiungo una o più righe ad una matrice, oppure per colonna ovvero aggiungo una o più colonne
\item
  Posso unire matrici che abbiamo la stessa dimensione (i.e., numero di righe e/o colonne) rispetto alla dimensione che voglio combinare
\item
  Le matrici che unisco devono essere della stessa tipologia (numeri o caratteri)
\end{itemize}

Se partiamo da una matrice \texttt{mat} per unire a \texttt{mat} un'altra matrice \texttt{new\_mat} possiamo usare il comando \texttt{cbind(mat,\ new\_mat)} se vogliamo unire le due matrici per colonna invece \texttt{rbind(mat,\ new\_mat)} se vogliamo unire per riga. E' utile pensare all'unione come un collage tra matrici, in figura\ref{fig:mat-comb} è presente uno schema utile per capire visivamente questo concetto.

\begin{figure}

{\centering \includegraphics[width=0.5\linewidth]{images/matrix_comb} 

}

\caption{Schema per la combinazione di matrici}\label{fig:mat-comb}
\end{figure}

Vediamo in R:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{vec <-}\StringTok{ }\DecValTok{1}\OperatorTok{:}\DecValTok{25}
\NormalTok{mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(vec, }\DataTypeTok{ncol =} \DecValTok{5}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}

\CommentTok{# Nuova matrice da aggiungere}
\NormalTok{new_vec <-}\StringTok{ }\DecValTok{11}\OperatorTok{:}\DecValTok{20}
\NormalTok{new_mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(new_vec, }\DataTypeTok{ncol =} \DecValTok{2}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{5}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}

\NormalTok{mat}
\CommentTok{##      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{## [1,]    1    6   11   16   21}
\CommentTok{## [2,]    2    7   12   17   22}
\CommentTok{## [3,]    3    8   13   18   23}
\CommentTok{## [4,]    4    9   14   19   24}
\CommentTok{## [5,]    5   10   15   20   25}
\NormalTok{new_mat}
\CommentTok{##      [,1] [,2]}
\CommentTok{## [1,]   11   16}
\CommentTok{## [2,]   12   17}
\CommentTok{## [3,]   13   18}
\CommentTok{## [4,]   14   19}
\CommentTok{## [5,]   15   20}

\CommentTok{# Combiniamo per colonna}

\KeywordTok{cbind}\NormalTok{(mat, new_mat)}
\CommentTok{##      [,1] [,2] [,3] [,4] [,5] [,6] [,7]}
\CommentTok{## [1,]    1    6   11   16   21   11   16}
\CommentTok{## [2,]    2    7   12   17   22   12   17}
\CommentTok{## [3,]    3    8   13   18   23   13   18}
\CommentTok{## [4,]    4    9   14   19   24   14   19}
\CommentTok{## [5,]    5   10   15   20   25   15   20}

\CommentTok{# Combiniamo per riga}

\KeywordTok{rbind}\NormalTok{(mat, new_mat)}
\CommentTok{## Error in rbind(mat, new_mat): number of columns of matrices must match (see arg 2)}

\CommentTok{# Scambiamo il numero di colonne e righe, per far combaciare le due matrici}

\NormalTok{new_vec <-}\StringTok{ }\DecValTok{11}\OperatorTok{:}\DecValTok{20}
\NormalTok{new_mat <-}\StringTok{ }\KeywordTok{matrix}\NormalTok{(new_vec, }\DataTypeTok{ncol =} \DecValTok{5}\NormalTok{, }\DataTypeTok{nrow =} \DecValTok{2}\NormalTok{, }\DataTypeTok{byrow =} \OtherTok{FALSE}\NormalTok{)}
\NormalTok{mat}
\CommentTok{##      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{## [1,]    1    6   11   16   21}
\CommentTok{## [2,]    2    7   12   17   22}
\CommentTok{## [3,]    3    8   13   18   23}
\CommentTok{## [4,]    4    9   14   19   24}
\CommentTok{## [5,]    5   10   15   20   25}
\NormalTok{new_mat}
\CommentTok{##      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{## [1,]   11   13   15   17   19}
\CommentTok{## [2,]   12   14   16   18   20}

\KeywordTok{rbind}\NormalTok{(mat, new_mat)}
\CommentTok{##      [,1] [,2] [,3] [,4] [,5]}
\CommentTok{## [1,]    1    6   11   16   21}
\CommentTok{## [2,]    2    7   12   17   22}
\CommentTok{## [3,]    3    8   13   18   23}
\CommentTok{## [4,]    4    9   14   19   24}
\CommentTok{## [5,]    5   10   15   20   25}
\CommentTok{## [6,]   11   13   15   17   19}
\CommentTok{## [7,]   12   14   16   18   20}
\end{Highlighting}
\end{Shaded}

Possiamo combinare quindi per riga/colonna solo se le righe/colonne delle due matrici sono equivalenti. Otteniamo un errore quando cerchiamo di combinare matrici di dimensioni diverse.

Un ultimo aspetto utile è l'estensione dei comandi \texttt{cbind()} ed \texttt{rbind()}. Fino ad ora li abbiamo utilizzati con due elementi: matrice di partenza e matrice da aggiungere ma possono essere utilizzati con elementi multipli. Se vogliamo combinare \(n\) matrici possiamo usare il comando \texttt{cbind(mat1,\ mat2,\ mat3,\ ...)} o \texttt{rbind(mat1,\ mat2,\ mat3,\ ...)}. In questo caso il risultato finale dipende dall'ordine degli argomenti quindi prima la \texttt{mat1}, poi la \texttt{mat2} e così via.

Ci sono molte altre operazioni da eseguire con le matrici. La tabella \ref{tab:table-matrix-operators} riassume quelle che abbiamo visto e anche alcune operazioni più legate al mondo dell'algebra.

\begin{table}[!h]

\caption{\label{tab:table-matrix-operators}Operazioni con matrici}
\centering
\begin{tabular}[t]{l|l}
\hline
Operazione & Nome\\
\hline
\texttt{<nuova-matrice> <- cbind(<matrice1>, <matrice2>)} & Per unire due matrici creando nuove colonne (le matrici devono avere lo stesso numero di righe)\\
\hline
\texttt{<nuova-matrice> <- rbind(<matrice1>, <matrice2>)} & Per unire due matrici creando nuove righe (le matrici devono avere lo stesso numero di colonne)\\
\hline
\texttt{nrow(<nome-matrice>)} & Per valutare il numero di righe della matrice\\
\hline
\texttt{ncol(<nome-matrice>)} & Per valutare il numero di colonne della matrice\\
\hline
\texttt{dim(<nome-matrice>)} & Per valutare la dimensione della matrice (righe e colonne)\\
\hline
\texttt{t(<nome-matrice>)} & Per ottenere la trasposta della matrice\\
\hline
\texttt{diag(<nome-matrice>)} & Ottenere un vettore con gli elementi della diagonale della matrice\\
\hline
\texttt{det(<nome-matrice>)} & Ottenere il determinante della matrice (la matrice deve essere quadrata)\\
\hline
\texttt{solve(<nome-matrice>)} & Ottenere l'inversa della matrice\\
\hline
\texttt{colnames(<nome-matrice>)} & Nomi delle colonne della matrice\\
\hline
\texttt{rownames(<nome-matrice>)} & Nomi delle righe della matrice\\
\hline
\texttt{matrice1 + matrice2} & Somma elemento per elemento di due matrici\\
\hline
\texttt{matrice1 - matrice2} & Differenza elemento per elemento tra due matrici\\
\hline
\texttt{matrice1 * matrice2} & Prodotto elemento per elemento tra due matrici\\
\hline
\texttt{matrice1 / matrice2} & Rapporto elemento per elemento tra due matrici\\
\hline
\texttt{matrice1 \%*\% matrice2} & Prodotto matriciale\\
\hline
\end{tabular}
\end{table}

\hypertarget{esercizi-7}{%
\subsection*{Esercizi}\label{esercizi-7}}
\addcontentsline{toc}{subsection}{Esercizi}

Utilizzando la matrice creata \texttt{A} creata negli esercizi precedenti:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Utilizzando gli indici di riga e di colonna selziona il numero 27 della matrice \texttt{A}
\item
  Selziona gli elementi compresi tra la seconda e quarta riga, seconda e terza colonna della matrice \texttt{B}
\item
  Seleziona solo gli elementi pari della matrice \texttt{A} (Nota: utilizza l'operazione resto \texttt{\%\%})
\item
  Elimina dalla matrice \texttt{C} la terza riga e la terza colonna
\item
  Seleziona tutti gli elementi della seconda e terza riga della matrice \texttt{B}
\item
  Seleziona tutti gli elementi diversi da ``B'' appartenenti alla matrice \texttt{D}
\item
  Crea la matrice \texttt{G} unendo alla matrice \texttt{A} le prime due colonne della matrice \texttt{C}
\item
  Crea la matrice \texttt{H} unendo alla matrice \texttt{C} le prime due righe della matrice trasposta di \texttt{B}
\item
  Ridefinisci la matrice \texttt{A} eliminando la seconda colonna. Ridefinisci la matrice \texttt{B} eliminando la prima riga. Verifica che le matrici così ottenute abbiano la stessa dimensione.
\item
  Commenta i differenti risultati che otteniamo nelle operazioni \texttt{A*B}, \texttt{B*A}, \texttt{A\%*\%B} e \texttt{B\%*\%A}.
\item
  Assegna i seguenti nomi alle colonne e alle righe della matrice \texttt{C}: \texttt{"col\textbackslash{}\_1",\ "col\textbackslash{}\_2",\ "col\textbackslash{}\_3",\ "col\textbackslash{}\_4",\ "row\textbackslash{}\_1",\ "row\textbackslash{}\_2",\ "row\textbackslash{}\_3"}.
\end{enumerate}

\hypertarget{dataframe}{%
\chapter{Dataframe}\label{dataframe}}

Il \texttt{dataframe} è uno degli oggetti più interessanti ed anche utilizzati del linguaggio R. Inoltre, se vi capiterà di utilizzare altri linguaggi di programmazione sopratutto mirati all'analisi dati (Matlab ad esempio) noterete come vi mancherà un oggetto potente e intuitivo come il dataframe.

Come vedremo ci sono molte somiglianze tra il \texttt{dataframe} e la \texttt{matrice}. Quando necessario, si farà riferimento al capitolo precedente per far notare quali aspetti sono in comune tra queste due strutture di dati.

Il \texttt{dataframe} come dice il nome fa riferimento ad una struttura per i dati. Dati in questo caso è volutamente generico perchè il dataframe rispetto alla matrice può contenere nello stesso oggetto, tipi diversi di dato come fattori, caratteri e numeri. Può essere utile pensare al dataframe esattamente come ad una normale tabella che si può creare un un foglio di calcolo (Excel) dove possiamo mettere \emph{nomi}, \emph{date}, \emph{numeri}, etc.

La struttura di base di un dataframe è quindi la stessa di una matrice ma contiene i nomi delle colonne (e anche delle righe eventualmente) di default. Un esempio di dataframe è rappresentato nella tabella \ref{tab:ex-dataframe}

\begin{table}

\caption{\label{tab:ex-dataframe}Esempio di dataframe}
\centering
\begin{tabular}[t]{c|c|c|c|c|c}
\hline
colonna1 & colonna2 & colonna3 & colonna4 & colonna5 & colonna6\\
\hline
-2.04 & 1.16 & -0.51 & -0.28 & -0.94 & a\\
\hline
-0.13 & 2.09 & -0.38 & 0.96 & -0.45 & b\\
\hline
-0.18 & -1.02 & -0.46 & -2.24 & -0.27 & c\\
\hline
-1.02 & -0.43 & -1.63 & 0.96 & 1.16 & d\\
\hline
0.20 & 0.16 & -0.17 & 0.23 & 0.71 & e\\
\hline
0.65 & 0.54 & -3.52 & 1.37 & 0.16 & f\\
\hline
-1.04 & 1.19 & 0.88 & 0.17 & 0.01 & g\\
\hline
0.97 & 0.23 & 1.33 & -0.48 & -0.50 & h\\
\hline
-0.04 & -0.04 & 0.05 & 0.61 & -1.49 & i\\
\hline
0.20 & -0.39 & -1.71 & 1.46 & -0.91 & j\\
\hline
\end{tabular}
\end{table}

Come si vede abbiamo colonne con un nome che contengono sia numeri che caratteri. Questo non era chiaramente possibile con le matrici.

\hypertarget{creazione-di-un-dataframe}{%
\section{Creazione di un dataframe}\label{creazione-di-un-dataframe}}

Il comando per creare un dataframe è il comando \texttt{data.frame()} tuttavia la creazione è leggermente diversa rispetto alla matrice. Pensando all'analogia con il foglio di calcolo Excel, intuitivamente è più facile immaginare la creazione di una dataframe mettendo insieme colonne relativamente indipendenti (dove una può contenere dei nomi, un'altra delle date e così via) piuttosto che un insieme di numeri inseriti per riga o per colonna come per le matrici.

Infatti il modo di creare un \texttt{dataframe} è priprio questo ovvero specificando \texttt{nomecolonna\ =\ valori} all'interno del comando \texttt{data.frame()}. Vediamo un esempio in R:

\begin{Shaded}
\begin{Highlighting}[]

\NormalTok{dat <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  
  \DataTypeTok{Id =} \KeywordTok{c}\NormalTok{(}\StringTok{"subj_1"}\NormalTok{,}\StringTok{"subj_2"}\NormalTok{,}\StringTok{"subj_3"}\NormalTok{),}
  \DataTypeTok{age =} \KeywordTok{c}\NormalTok{(}\DecValTok{21}\NormalTok{,}\DecValTok{23}\NormalTok{,}\DecValTok{19}\NormalTok{),}
  \DataTypeTok{sex =} \KeywordTok{c}\NormalTok{(}\StringTok{"F"}\NormalTok{,}\StringTok{"M"}\NormalTok{,}\StringTok{"F"}\NormalTok{),}
  \DataTypeTok{item1 =} \KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{),}
  \DataTypeTok{item2 =} \KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{),}
  \DataTypeTok{item3 =} \KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{)}
  
\NormalTok{)}

\NormalTok{dat}
\CommentTok{##       Id age sex item1 item2 item3}
\CommentTok{## 1 subj_1  21   F     2     0     2}
\CommentTok{## 2 subj_2  23   M     1     2     0}
\CommentTok{## 3 subj_3  19   F     1     1     1}
\end{Highlighting}
\end{Shaded}

In questo caso abbiamo creato un ipotetico dataframe dove in ogni riga abbiamo un soggetto e ogni colonna rappresenta una data caratteristica del soggetto come il genere, l'età e così via.

Un aspetto importante adesso è proprio quello che il dataframe è stato pensato per gestire dati complessi ed eterogenei come quelli che si trovano in un'analisi di dati reale. Una convenzione molto utile da ricordare infatti è quella che le righe di un dataframe rappresentano le \textbf{osservazioni} (ad esempio persone) e le colonne rappresentano \textbf{variabili} ovvero delle proprietà misurate su quelle osservazioni.

Una distinzione fondamentale nella pratica di analisi dei dati è quella tra dati in forma \textbf{long} (oppure lunga) o dati in forma \textbf{wide} (oppure larga). Non c'è un formato corretto o sbagliato ma dipende dal tipo di analisi e dal software o pacchetto che si utilizza. Alcune operazioni o analisi richiedono il dataset in forma \textbf{long} altre in forma \textbf{wide}. Mantenendo l'esempio di soggetti e caratteristiche misurate sui soggetti i due formati sono definiti come:

\begin{itemize}
\tightlist
\item
  \textbf{Wide}: ogni singola riga rappresenta un soggetto e ogni sua risposta o variabile misurata sarà riportata in una diversa colonna. Il dataset creato in precedenza era infatti proprio nel formato wide:
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data_wide<-}\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{Id=}\KeywordTok{c}\NormalTok{(}\StringTok{"subj_1"}\NormalTok{,}\StringTok{"subj_2"}\NormalTok{,}\StringTok{"subj_3"}\NormalTok{),}
  \DataTypeTok{age=}\KeywordTok{c}\NormalTok{(}\DecValTok{21}\NormalTok{,}\DecValTok{23}\NormalTok{,}\DecValTok{19}\NormalTok{),}
  \DataTypeTok{sex=}\KeywordTok{c}\NormalTok{(}\StringTok{"F"}\NormalTok{,}\StringTok{"M"}\NormalTok{,}\StringTok{"F"}\NormalTok{),}
  \DataTypeTok{item_1=}\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{),}
  \DataTypeTok{item_2=}\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{),}
  \DataTypeTok{item_3=}\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{)}
\NormalTok{  )}

\NormalTok{data_wide}
\CommentTok{##       Id age sex item_1 item_2 item_3}
\CommentTok{## 1 subj_1  21   F      2      0      2}
\CommentTok{## 2 subj_2  23   M      1      2      0}
\CommentTok{## 3 subj_3  19   F      1      1      1}
\end{Highlighting}
\end{Shaded}

\begin{itemize}
\tightlist
\item
  \textbf{Long}: ogni singola riga rappresenta una singola osservazione. Quindi i dati di ogni soggetto saranno riportati su più righe e le variabili che non cambiano tra le osservazioni saranno ripetute.
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data_long<-}\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{Id=}\KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"subj_1"}\NormalTok{,}\StringTok{"subj_2"}\NormalTok{,}\StringTok{"subj_3"}\NormalTok{),}\DataTypeTok{each=}\DecValTok{3}\NormalTok{),}
                      \DataTypeTok{age=}\KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\DecValTok{21}\NormalTok{,}\DecValTok{23}\NormalTok{,}\DecValTok{19}\NormalTok{),}\DataTypeTok{each=}\DecValTok{3}\NormalTok{),}
                      \DataTypeTok{sex=}\KeywordTok{rep}\NormalTok{(}\KeywordTok{c}\NormalTok{(}\StringTok{"F"}\NormalTok{,}\StringTok{"M"}\NormalTok{,}\StringTok{"F"}\NormalTok{),}\DataTypeTok{each=}\DecValTok{3}\NormalTok{),}
                      \DataTypeTok{item=}\KeywordTok{rep}\NormalTok{(}\DecValTok{1}\OperatorTok{:}\DecValTok{3}\NormalTok{,}\DecValTok{3}\NormalTok{),}
                      \DataTypeTok{response=}\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{))}
\NormalTok{data_long}
\CommentTok{##       Id age sex item response}
\CommentTok{## 1 subj_1  21   F    1        2}
\CommentTok{## 2 subj_1  21   F    2        1}
\CommentTok{## 3 subj_1  21   F    3        1}
\CommentTok{## 4 subj_2  23   M    1        0}
\CommentTok{## 5 subj_2  23   M    2        2}
\CommentTok{## 6 subj_2  23   M    3        1}
\CommentTok{## 7 subj_3  19   F    1        2}
\CommentTok{## 8 subj_3  19   F    2        0}
\CommentTok{## 9 subj_3  19   F    3        1}
\end{Highlighting}
\end{Shaded}

Come potete vedere, nel dataset in forma \textbf{long} ogni soggetto ha 3 righe perchè oltre al genere e l'età che sono uniche, ci sono 3 variabili diverse misurate sulla stessa persona.

\begin{tip}[Long o Wide?]

I dati in forma long e wide hanno delle proprietà diverse sopratutto in riferimento all'utilizzo. La tipologia di dato e il risultato finale è esattamente lo stesso tuttavia alcuni software o alcuni pacchetti di R funzionano solo con dataset organizzati in un certo modo.
Il consiglio però è di abituarsi il più possibile a ragionare in forma \textbf{long} perchè la maggior parte dei moderni pacchetti per l'analisi dati e per la creazione di grafici richiedono i dati in questo formato. Ci sono comunque delle funzioni (più avanzate) per passare velocemente da un formato all'altro.

\end{tip}

Come per le \texttt{matrici}, anche i dataframe richiedono che tutte le colonne (variabili) abbiano lo stesso numero di elementi.

\textbf{Nota:} di default R considera una variabile stringa all'interno di un DataFrame come una variabile categoriale. E' possibile cambiare questa opzione specificando \texttt{stringsAsFactors=FALSE}.

\hypertarget{esercizi-8}{%
\subsection*{Esercizi}\label{esercizi-8}}
\addcontentsline{toc}{subsection}{Esercizi}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Crea il dataframe \texttt{data\_wide} riportato precedentemente
\item
  Crea il dataframe \texttt{data\_long} riportato precedentemente
\end{enumerate}

\hypertarget{proprietuxe0-di-un-dataframe}{%
\section{Proprietà di un dataframe}\label{proprietuxe0-di-un-dataframe}}

In modo simile alle matrici, i dataframe contengono dei metadati per assegnare dei nomi alle righe \texttt{rownames()} e alle colonne \texttt{colnames()}. Inoltre il dataframe ha una dimensione intesa come numero di righe e colonne esattamente come la matrice. Di default il dataframe richiede dei nomi solo alle colonne ma è possibile anche nominare le righe. Utilizzando il dataframe precedente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data_long}
\CommentTok{##       Id age sex item response}
\CommentTok{## 1 subj_1  21   F    1        2}
\CommentTok{## 2 subj_1  21   F    2        1}
\CommentTok{## 3 subj_1  21   F    3        1}
\CommentTok{## 4 subj_2  23   M    1        0}
\CommentTok{## 5 subj_2  23   M    2        2}
\CommentTok{## 6 subj_2  23   M    3        1}
\CommentTok{## 7 subj_3  19   F    1        2}
\CommentTok{## 8 subj_3  19   F    2        0}
\CommentTok{## 9 subj_3  19   F    3        1}

\CommentTok{# Controllo dei nomi}

\KeywordTok{rownames}\NormalTok{(data_long)}
\CommentTok{## [1] "1" "2" "3" "4" "5" "6" "7" "8" "9"}
\KeywordTok{colnames}\NormalTok{(data_long)}
\CommentTok{## [1] "Id"       "age"      "sex"      "item"     "response"}
\KeywordTok{names}\NormalTok{(data_long) }\CommentTok{# nel caso dei dataframe questo è analogo a colnames()}
\CommentTok{## [1] "Id"       "age"      "sex"      "item"     "response"}

\CommentTok{# Dimensioni}

\KeywordTok{nrow}\NormalTok{(data_long)}
\CommentTok{## [1] 9}
\KeywordTok{ncol}\NormalTok{(data_long)}
\CommentTok{## [1] 5}
\end{Highlighting}
\end{Shaded}

\hypertarget{indicizzazione-di-dataframe}{%
\section{Indicizzazione di dataframe}\label{indicizzazione-di-dataframe}}

Ancora di più che per le matrici, è nell'indicizzazione che si vede la vera potenza dei dataframe. Rimandendo su un'indicizzazione tramiti indici di riga e colonna il funzionamento è esattamente analogo a quello della matrice, quindi \texttt{dataframe{[}riga,\ colonna{]}}:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data_long}
\CommentTok{##       Id age sex item response}
\CommentTok{## 1 subj_1  21   F    1        2}
\CommentTok{## 2 subj_1  21   F    2        1}
\CommentTok{## 3 subj_1  21   F    3        1}
\CommentTok{## 4 subj_2  23   M    1        0}
\CommentTok{## 5 subj_2  23   M    2        2}
\CommentTok{## 6 subj_2  23   M    3        1}
\CommentTok{## 7 subj_3  19   F    1        2}
\CommentTok{## 8 subj_3  19   F    2        0}
\CommentTok{## 9 subj_3  19   F    3        1}

\CommentTok{# Seleziono 1 riga e 4 colonna}

\NormalTok{data_long[}\DecValTok{1}\NormalTok{,}\DecValTok{4}\NormalTok{]}
\CommentTok{## [1] 1}

\CommentTok{# Seleziono 1 riga e tutte le colonne}

\NormalTok{data_long[}\DecValTok{1}\NormalTok{, ]}
\CommentTok{##       Id age sex item response}
\CommentTok{## 1 subj_1  21   F    1        2}

\CommentTok{# Seleziono righe 1 e 3 e tutte le colonne}

\NormalTok{data_long[}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{), ]}
\CommentTok{##       Id age sex item response}
\CommentTok{## 1 subj_1  21   F    1        2}
\CommentTok{## 3 subj_1  21   F    3        1}
\end{Highlighting}
\end{Shaded}

La reale differenza tra matrici e dataframe sta nel poter accedere direttamente alle colonne tramite il loro nome e utilizzando l'operatore \texttt{\$}. Con la scrittura \texttt{dataframe\$nomevariabile} accediamo direttamente a quella specifica colonna senza utilizzare indici e parentesi quadre.

\begin{Shaded}
\begin{Highlighting}[]

\CommentTok{# Seleziono la variabile ID (soggetto)}
\NormalTok{data_long}\OperatorTok{$}\NormalTok{Id}
\CommentTok{## [1] "subj_1" "subj_1" "subj_1" "subj_2" "subj_2" "subj_2" "subj_3" "subj_3"}
\CommentTok{## [9] "subj_3"}

\CommentTok{# Seleziono la variabile Sex}
\NormalTok{data_long}\OperatorTok{$}\NormalTok{sex}
\CommentTok{## [1] "F" "F" "F" "M" "M" "M" "F" "F" "F"}

\CommentTok{# Analogalmente}
\NormalTok{data_long[, }\DecValTok{1}\NormalTok{] }\CommentTok{# seleziono id con indice di colonna}
\CommentTok{## [1] "subj_1" "subj_1" "subj_1" "subj_2" "subj_2" "subj_2" "subj_3" "subj_3"}
\CommentTok{## [9] "subj_3"}
\NormalTok{data_long[, }\DecValTok{3}\NormalTok{] }\CommentTok{# seleziono sex con indice di colonna}
\CommentTok{## [1] "F" "F" "F" "M" "M" "M" "F" "F" "F"}
\end{Highlighting}
\end{Shaded}

Un ulteriore differenza rispetto alle matrici è quella della \textbf{combinazione di dataframe} o della \textbf{creazione di nuove righe o colonne}. Sono sempre valide le indicazioni riguardo a \texttt{cbind()} e \texttt{rbind()} ma nel caso di nuove colonne è possibile utilizzare l'operatore \texttt{\$}. Con la scrittura \texttt{dataframe\$name\ \textless{}-\ new\_var} otteniamo che nel dataframe in oggetto ci sarà una nuova colonna chiamata \texttt{name} che prende i valori all'interno di \texttt{new\_var}.

Attenzione che mentre la scrittura \texttt{dataframe\$name\ \textless{}-\ new\_var} aggiunge direttamente la colonna al dataframe, usando \texttt{cbind()} dobbiamo assegnare l'operazione ad un nuovo oggetto \texttt{dataframe\ \textless{}-\ cbind(dataframe,\ new\_var)}. In quest'ultimo caso il nome della colonna sarà \texttt{new\_var}. Se vogliamo anche rinominare la colonna possiamo usare la sintassi \texttt{cbind(dataframe,\ "nome"\ =\ new\_var)} oppure chiamare l'oggetto direttamente con il nome desiderato:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data_wide}
\CommentTok{##       Id age sex item_1 item_2 item_3}
\CommentTok{## 1 subj_1  21   F      2      0      2}
\CommentTok{## 2 subj_2  23   M      1      2      0}
\CommentTok{## 3 subj_3  19   F      1      1      1}

\CommentTok{# Aggiungiamo una colonna item4 al nostro dataset}

\NormalTok{new_var <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{)}

\NormalTok{data_wide}\OperatorTok{$}\NormalTok{item_}\DecValTok{4}\NormalTok{ <-}\StringTok{ }\NormalTok{new_var}

\CommentTok{# Equivalente a}

\NormalTok{data_wide}\OperatorTok{$}\NormalTok{item_}\DecValTok{4}\NormalTok{ <-}\StringTok{ }\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{, }\DecValTok{4}\NormalTok{, }\DecValTok{7}\NormalTok{)}

\CommentTok{# Equivalente a }

\KeywordTok{cbind}\NormalTok{(data_wide, new_var) }\CommentTok{# senza specificare il nome}
\CommentTok{##       Id age sex item_1 item_2 item_3 item_4 new_var}
\CommentTok{## 1 subj_1  21   F      2      0      2      3       3}
\CommentTok{## 2 subj_2  23   M      1      2      0      4       4}
\CommentTok{## 3 subj_3  19   F      1      1      1      7       7}
\KeywordTok{cbind}\NormalTok{(data_wide, }\StringTok{"item_4"}\NormalTok{ =}\StringTok{ }\NormalTok{new_var) }\CommentTok{# specificando anche il nome}
\CommentTok{##       Id age sex item_1 item_2 item_3 item_4 item_4}
\CommentTok{## 1 subj_1  21   F      2      0      2      3      3}
\CommentTok{## 2 subj_2  23   M      1      2      0      4      4}
\CommentTok{## 3 subj_3  19   F      1      1      1      7      7}
\end{Highlighting}
\end{Shaded}

Leggermente più complessa (e inusuale) è l'aggiunta di righe ad un dataframe. Al contrario della matrice che di base non aveva nomi per le colonne e solo numeri o stringhe come tipologia di dato, per combinare per riga due dataframe dobbiamo avere:

\begin{itemize}
\tightlist
\item
  Lo stesso numero di colonne (come per le matrici)
\item
  Lo stesso nome delle colonne tra i due dataframe
\end{itemize}

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{data_wide}
\CommentTok{##       Id age sex item_1 item_2 item_3 item_4}
\CommentTok{## 1 subj_1  21   F      2      0      2      3}
\CommentTok{## 2 subj_2  23   M      1      2      0      4}
\CommentTok{## 3 subj_3  19   F      1      1      1      7}

\CommentTok{# Nuovo dataset con le stesse colonne ma chiamate in un modo diverso}

\NormalTok{new_row <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{Id =} \StringTok{"subj_4"}\NormalTok{,}
  \DataTypeTok{gender =} \StringTok{"M"}\NormalTok{, }\CommentTok{# gender invece che sex}
  \DataTypeTok{age =} \DecValTok{44}\NormalTok{,}
  \DataTypeTok{item_1 =} \DecValTok{2}\NormalTok{,}
  \DataTypeTok{item_2 =} \DecValTok{7}\NormalTok{,}
  \DataTypeTok{item_3 =} \DecValTok{3}\NormalTok{,}
  \DataTypeTok{item_4 =} \DecValTok{1}
\NormalTok{)}

\NormalTok{new_row}
\CommentTok{##       Id gender age item_1 item_2 item_3 item_4}
\CommentTok{## 1 subj_4      M  44      2      7      3      1}

\KeywordTok{rbind}\NormalTok{(data_wide, new_row) }\CommentTok{# Errore}
\CommentTok{## Error in match.names(clabs, names(xi)): names do not match previous names}

\CommentTok{# Nuovo dataset con le stesse colonne con il nome corretto}

\NormalTok{new_row <-}\StringTok{ }\KeywordTok{data.frame}\NormalTok{(}
  \DataTypeTok{Id =} \StringTok{"subj_4"}\NormalTok{,}
  \DataTypeTok{sex =} \StringTok{"M"}\NormalTok{,}
  \DataTypeTok{age =} \DecValTok{44}\NormalTok{,}
  \DataTypeTok{item_1 =} \DecValTok{2}\NormalTok{,}
  \DataTypeTok{item_2 =} \DecValTok{7}\NormalTok{,}
  \DataTypeTok{item_3 =} \DecValTok{3}\NormalTok{,}
  \DataTypeTok{item_4 =} \DecValTok{1}
\NormalTok{)}

\NormalTok{new_row}
\CommentTok{##       Id sex age item_1 item_2 item_3 item_4}
\CommentTok{## 1 subj_4   M  44      2      7      3      1}

\KeywordTok{rbind}\NormalTok{(data_wide, new_row) }\CommentTok{# Corretto}
\CommentTok{##       Id age sex item_1 item_2 item_3 item_4}
\CommentTok{## 1 subj_1  21   F      2      0      2      3}
\CommentTok{## 2 subj_2  23   M      1      2      0      4}
\CommentTok{## 3 subj_3  19   F      1      1      1      7}
\CommentTok{## 4 subj_4  44   M      2      7      3      1}
\end{Highlighting}
\end{Shaded}

\hypertarget{indicizzazione-avanzata-1}{%
\section{Indicizzazione avanzata}\label{indicizzazione-avanzata-1}}

Quello che avevamo accennato per le matrici rispetto all'indicizzazione avanzata per \emph{nome} e per \emph{operazioni logiche} qui è invece molto utile e rilevante. Quando trattiamo dati che non sono solo numerici e sopratutto hanno delle proprietà come ``soggetti'', ``età'', ``genere'', è intuitivo pensare un modo altrettanto logico e intuitivo di lavorare con queste strutture di dati. Per rendere il tutto più intuitivo facciamo un esempio con un dataset fittizio dove sono inseriti i nostri amici su Facebook ed alcune caratteristiche su di loro in particolare:

\begin{itemize}
\tightlist
\item
  Nome
\item
  Età (\texttt{age})
\item
  Genere (\texttt{sex})
\item
  Data iscrizione a Facebook (\texttt{facebook})
\item
  Numero di fratelli/sorelle (\texttt{nsiblings})
\item
  Numero di foto assieme a noi (\texttt{foto})
\end{itemize}

Vediamo il dataset in R:

\begin{verbatim}
##         nome age sex facebook nsiblings foto
## 1    Filippo  17   M       17         0   13
## 2    Claudio  51   M       51         4   14
## 3   Giovanni  55   M       55         2   11
## 4  Francesco  23   M       23         3   18
## 5      Luigi  18   M       18         5   17
## 6    Giacomo  34   M       34         1    2
## 7  Gianmarco  49   M       49         4   20
## 8      Bruna  47   F       47         3   12
## 9     Franco  44   M       44         3    7
## 10   Elettra  56   F       56         5    0
## 11     Livia  32   F       32         2    2
## 12      Anna  56   F       56         3    2
## 13      Luca  25   M       25         5    2
## 14    Giulia  52   F       52         4   18
## 15     Alice  42   F       42         4   15
\end{verbatim}

Ora se volessimo usare l'indicizzazione standard possiamo semplicemente usare la sintassi solita \texttt{dataframe{[}riga/e,\ colonna/e{]}}. Tuttavia se volessimo trovare tutte le informazioni associate alla nostra amica \textbf{Elettra}, usare gli indici di riga/colonna diventa scomodo. Quello che è stato introdotto nei capitolo iniziali rispetto agli operatori logici qui diventa molto rilevante. Possiamo infatti ``interrogare'' il nostro dataframe dicendo di farci vedere tutte le informazioni che rispettano una specifica richiesta.

La sintassi ``Tutte le informazioni riguardo Elettra'' diventa \textbf{tutte le colonne (informazioni) solo per la riga dove il nome è Elettra}. In R questo può essere controllato in questo modo:

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# nomi sono nella colonna "nome"}
\NormalTok{dat}\OperatorTok{$}\NormalTok{nome}
\CommentTok{##  [1] "Filippo"   "Claudio"   "Giovanni"  "Francesco" "Luigi"     "Giacomo"  }
\CommentTok{##  [7] "Gianmarco" "Bruna"     "Franco"    "Elettra"   "Livia"     "Anna"     }
\CommentTok{## [13] "Luca"      "Giulia"    "Alice"}
\end{Highlighting}
\end{Shaded}

\begin{Shaded}
\begin{Highlighting}[]
\CommentTok{# Per sapere quale riga corrisponde ad elettra}
\NormalTok{dat}\OperatorTok{$}\NormalTok{nome }\OperatorTok{==}\StringTok{ "Elettra"}
\CommentTok{##  [1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE  TRUE FALSE FALSE}
\CommentTok{## [13] FALSE FALSE FALSE}

\KeywordTok{which}\NormalTok{(dat}\OperatorTok{$}\NormalTok{nome }\OperatorTok{==}\StringTok{ "Elettra"}\NormalTok{) }\CommentTok{# Elettra è la riga 10}
\CommentTok{## [1] 10}
\end{Highlighting}
\end{Shaded}

Praticamente con \texttt{dat\$nome\ ==\ "Elettra"} otteniamo una serie di \texttt{TRUE} e \texttt{FALSE} in base a se il nome è ``Elettra'' oppure no. Combinando questo con l'indicizzazione classica \texttt{dataframe{[}riga/e,\ colonna/e{]}} possiamo usare gli operatori logici per interrogare il dataset.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat[dat}\OperatorTok{$}\NormalTok{nome }\OperatorTok{==}\StringTok{ "Elettra"}\NormalTok{, ]}
\CommentTok{##       nome age sex facebook nsiblings foto}
\CommentTok{## 10 Elettra  56   F       56         5    0}
\end{Highlighting}
\end{Shaded}

Ora la sintassi \texttt{dataframe{[}riga/e,\ colonna/e{]}} assume un significato molto diverso ovvero:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dataframe[operazioni_logiche_righe, operazioni_logiche_colonne]}
\end{Highlighting}
\end{Shaded}

Utilizzando gli operatori booleani \textbf{AND}(\texttt{\$}) \textbf{OR}(\texttt{\textbar{}}) e \textbf{NOT}(\texttt{!}) possiamo inoltre combinare più operazioni logiche insieme per ottenere indicizzazioni più complesse, ma sempre intuitive dal punto di vista della scrittura. Ad esempio: ``Gli amici con età maggiore di 20 anni e con più di 5 foto assieme a noi''. In questo caso un amico per ottenere un valore \texttt{TRUE} ed essere così inserito nei risultati deve rispettare due condizioni:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat[dat}\OperatorTok{$}\NormalTok{age }\OperatorTok{>}\StringTok{ }\DecValTok{20} \OperatorTok{&}\StringTok{ }\NormalTok{dat}\OperatorTok{$}\NormalTok{foto }\OperatorTok{>}\StringTok{ }\DecValTok{5}\NormalTok{, ]}
\CommentTok{##         nome age sex facebook nsiblings foto}
\CommentTok{## 2    Claudio  51   M       51         4   14}
\CommentTok{## 3   Giovanni  55   M       55         2   11}
\CommentTok{## 4  Francesco  23   M       23         3   18}
\CommentTok{## 7  Gianmarco  49   M       49         4   20}
\CommentTok{## 8      Bruna  47   F       47         3   12}
\CommentTok{## 9     Franco  44   M       44         3    7}
\CommentTok{## 14    Giulia  52   F       52         4   18}
\CommentTok{## 15     Alice  42   F       42         4   15}
\end{Highlighting}
\end{Shaded}

Possiamo chiaramente eseguire selezioni sulle colonne, per esempio sapere solo il numero di fratelli/sorelle degli amici che rispettano la condizione precedente:

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{dat[dat}\OperatorTok{$}\NormalTok{age }\OperatorTok{>}\StringTok{ }\DecValTok{20} \OperatorTok{&}\StringTok{ }\NormalTok{dat}\OperatorTok{$}\NormalTok{foto }\OperatorTok{>}\StringTok{ }\DecValTok{5}\NormalTok{, }\StringTok{"nsiblings"}\NormalTok{]}
\CommentTok{## [1] 4 2 3 4 3 3 4 4}
\end{Highlighting}
\end{Shaded}

Un ultimo aspetto da notare riguarda il tipo di output che otteniamo. Se la nostra selezione comprende più di 1 riga/colonna otteniamo un \texttt{dataframe} che è considerato un subset di quello iniziale. Se come nell'ultimo esempio otteniamo una singola colonna (o variabile) allora il risultato è un semplice vettore.

\begin{Shaded}
\begin{Highlighting}[]
\NormalTok{res1 <-}\StringTok{ }\NormalTok{dat[dat}\OperatorTok{$}\NormalTok{age }\OperatorTok{>}\StringTok{ }\DecValTok{20} \OperatorTok{&}\StringTok{ }\NormalTok{dat}\OperatorTok{$}\NormalTok{foto }\OperatorTok{>}\StringTok{ }\DecValTok{5}\NormalTok{, ]}
\NormalTok{res2 <-}\StringTok{ }\NormalTok{dat[dat}\OperatorTok{$}\NormalTok{age }\OperatorTok{>}\StringTok{ }\DecValTok{20} \OperatorTok{&}\StringTok{ }\NormalTok{dat}\OperatorTok{$}\NormalTok{foto }\OperatorTok{>}\StringTok{ }\DecValTok{5}\NormalTok{, }\StringTok{"nsiblings"}\NormalTok{]}

\KeywordTok{str}\NormalTok{(res1) }\CommentTok{# è un dataframe}
\CommentTok{## 'data.frame':    8 obs. of  6 variables:}
\CommentTok{##  $ nome     : chr  "Claudio" "Giovanni" "Francesco" "Gianmarco" ...}
\CommentTok{##  $ age      : int  51 55 23 49 47 44 52 42}
\CommentTok{##  $ sex      : chr  "M" "M" "M" "M" ...}
\CommentTok{##  $ facebook : int  51 55 23 49 47 44 52 42}
\CommentTok{##  $ nsiblings: int  4 2 3 4 3 3 4 4}
\CommentTok{##  $ foto     : int  14 11 18 20 12 7 18 15}
\KeywordTok{str}\NormalTok{(res2) }\CommentTok{# è un vettore}
\CommentTok{##  int [1:8] 4 2 3 4 3 3 4 4}
\end{Highlighting}
\end{Shaded}

Allo stesso modo di selezionare una specifica colonna o riga possiamo eliminare una osservazione. Il concetto di eliminazione o sovrascrittura in R è diverso da quello di un normale file perchè tutte le operazioni che facciamo solitamente portano a tre strade:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Eseguiamo le operazioni in modalità ``volatile'' senza assegnare il risultato
\item
  Creiamo un nuovo oggetto \texttt{B} che deriva da applicare ad \texttt{A} una certa operazione \texttt{B\ \textless{}-\ funzione(A)}
\item
  Assegnamo ad \texttt{A} una serie di operazioni su se stesso, di fatto sovrascrivendo l'oggetto \texttt{A\ \textless{}-\ funzione(A)}
\end{enumerate}

Nel caso dei dataframe possiamo usare l'operatore \texttt{-} (meno) per escludere una certa selezione:

\begin{verbatim}
##       Id age sex item_1 item_2 item_3 item_4
## 2 subj_2  23   M      1      2      0      4
## 3 subj_3  19   F      1      1      1      7
##       Id age item_1 item_2 item_3 item_4
## 1 subj_1  21      2      0      2      3
## 2 subj_2  23      1      2      0      4
## 3 subj_3  19      1      1      1      7
##       Id sex item_1 item_2 item_3 item_4
## 2 subj_2   M      1      2      0      4
\end{verbatim}

E' possibile anche escludere (ed eliminare in un certo senso) delle informazioni usando gli operatori logici in gli operatori \textbf{NOT}(\texttt{!}) e diverso da (\texttt{!=}):

\begin{Shaded}
\begin{Highlighting}[]

\CommentTok{# Seleziono tutto tranne il soggetto 2}

\NormalTok{data_wide[}\OperatorTok{!}\NormalTok{data_wide}\OperatorTok{$}\NormalTok{Id }\OperatorTok{==}\StringTok{ "subj_2"}\NormalTok{, ] }\CommentTok{# modo 1}
\CommentTok{##       Id age sex item_1 item_2 item_3 item_4}
\CommentTok{## 1 subj_1  21   F      2      0      2      3}
\CommentTok{## 3 subj_3  19   F      1      1      1      7}

\NormalTok{data_wide[data_wide}\OperatorTok{$}\NormalTok{Id }\OperatorTok{!=}\StringTok{ "subj_2"}\NormalTok{, ] }\CommentTok{# modo 2}
\CommentTok{##       Id age sex item_1 item_2 item_3 item_4}
\CommentTok{## 1 subj_1  21   F      2      0      2      3}
\CommentTok{## 3 subj_3  19   F      1      1      1      7}
\end{Highlighting}
\end{Shaded}

\begin{warning}[Attenzione ad eliminare]

L'utilizzo dell'operatore \texttt{-} è sempre in qualche modo pericoloso, sopratutto se l'oggetto che viene creato (o sovrascritto) viene poi utilizzato in altre operazioni. Eliminare delle informazioni, tranne quando è veramente necessario, non è mai una buona cosa. Se dovete selezionare una parte dei dati è sempre meglio creare un nuovo dataframe (o un nuovo oggetto in generale) e mantendere una versione di quello originale sempre disponibile.

\end{warning}

Nella tabella \ref{tab:frame-tab} è contenuto un riassunto delle principali operazioni che si possono eseguire con i dataframe:

\begin{table}[!h]

\caption{\label{tab:frame-tab}Operazioni con dataframe}
\centering
\begin{tabular}[t]{l|l}
\hline
Operazione & Nome\\
\hline
\texttt{nome\_DataFrame <- cbind(nome\_DataFrame, nuova\_variabile)} \\ \texttt{nome\_DataFrame\$nome\_variabile <- dati} & Per aggiungere una nuova variabile al DataFrame (deve avere lo stesso numero di righe)\\
\hline
\texttt{nome\_DataFrame <- rbind(nome\_DataFrame, nuova\_variabile)} & Per aggiungere delle osservazioni (i nuovi dati devono essere coerenti con la struttura del DataFrame)\\
\hline
\texttt{nrow(nome\_DataFrame)} & Per valutare il numero di osservazioni del DataFrame\\
\hline
\texttt{ncol(nome\_DataFrame)} & Per valutare il numero di variabili del DataFrame\\
\hline
\texttt{colnames(nome\_DataFrame)} & Nomi delle colonne del DataFrame\\
\hline
\texttt{rownames(nome\_DataFrame)} & Nomi delle righe del DataFrame\\
\hline
\end{tabular}
\end{table}

\hypertarget{esercizi-9}{%
\subsection*{Esercizi}\label{esercizi-9}}
\addcontentsline{toc}{subsection}{Esercizi}

Facendo riferimento ai dataframe \texttt{data\_long} e \texttt{data\_wide}:

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Utilizzando gli \textbf{indici numerici} di riga e di colonna seleziona i dati del soggetto \texttt{subj\_2} riguardanti le variabili \texttt{item} e \texttt{response} dal DataFrame \texttt{data\_long}.
\item
  Compi la stessa selezione dell'esercizio precedente usando però questa volta una condizione logica per gli indici di riga e indicando direttamente il nome delle variabili per gli indici di colonna.
\item
  Considerando il DataFrame \texttt{data\_wide} seleziona le variabili \texttt{Id} e \texttt{sex} dei soggetti che hanno risposto 1 alla variabile \texttt{item\_1}.
\item
  Considerando il DataFrame \texttt{data\_long} seleziona solamente i dati riguardanti le ragazze con etè superiore ai 20 anni.
\item
  Elimina dal DataFrame \texttt{data\_long} le osservazioni riguardanti il soggetto \texttt{subj\_2} e la variabile \texttt{"sex"}.
\item
  Aggiungi sia al DataFrame \texttt{data\_wide} che \texttt{data\_long} la variabile numerica \texttt{"memory\_pre"}.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{Id=}\KeywordTok{c}\NormalTok{(}\StringTok{"subj_1"}\NormalTok{,}\StringTok{"subj_2"}\NormalTok{,}\StringTok{"subj_3"}\NormalTok{),}
                      \DataTypeTok{memory_pre=}\KeywordTok{c}\NormalTok{(}\DecValTok{3}\NormalTok{,}\DecValTok{2}\NormalTok{,}\DecValTok{1}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{6}
\tightlist
\item
  Aggiungi sia al DataFrame \texttt{data\_wide} che \texttt{data\_long} la variabile categoriale \texttt{"gruppo"}.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{Id=}\KeywordTok{c}\NormalTok{(}\StringTok{"subj_1"}\NormalTok{,}\StringTok{"subj_2"}\NormalTok{,}\StringTok{"subj_3"}\NormalTok{),}
                      \DataTypeTok{gruppo=}\KeywordTok{c}\NormalTok{(}\StringTok{"trattamento"}\NormalTok{,}\StringTok{"trattemento"}\NormalTok{,}\StringTok{"controllo"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{7}
\tightlist
\item
  Aggiungi al DataFrame \texttt{data\_wide} i dati del soggetto \texttt{subj\_4} e \texttt{subj\_5}.
\end{enumerate}

\begin{Shaded}
\begin{Highlighting}[]
\KeywordTok{data.frame}\NormalTok{(}\DataTypeTok{Id=}\KeywordTok{c}\NormalTok{(}\StringTok{"subj_4"}\NormalTok{,}\StringTok{"subj_5"}\NormalTok{),}
           \DataTypeTok{age=}\KeywordTok{c}\NormalTok{(}\DecValTok{25}\NormalTok{,}\DecValTok{22}\NormalTok{),}
           \DataTypeTok{sex=}\KeywordTok{c}\NormalTok{(}\StringTok{"F"}\NormalTok{,}\StringTok{"M"}\NormalTok{),}
           \DataTypeTok{item_1=}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{1}\NormalTok{),}
           \DataTypeTok{item_2=}\KeywordTok{c}\NormalTok{(}\DecValTok{0}\NormalTok{,}\DecValTok{1}\NormalTok{),}
           \DataTypeTok{item_3=}\KeywordTok{c}\NormalTok{(}\DecValTok{2}\NormalTok{,}\DecValTok{0}\NormalTok{),}
           \DataTypeTok{memory_pre=}\KeywordTok{c}\NormalTok{(}\DecValTok{1}\NormalTok{,}\DecValTok{3}\NormalTok{),}
           \DataTypeTok{gruppo=}\KeywordTok{c}\NormalTok{(}\StringTok{"trattemento"}\NormalTok{,}\StringTok{"controllo"}\NormalTok{))}
\end{Highlighting}
\end{Shaded}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\setcounter{enumi}{8}
\tightlist
\item
  Considerando il DataFrame \texttt{datawide} calcola la variabile \texttt{"memory\_post"} data dalla somma degli item.
\item
  Considerando il DataFrame \texttt{data\_wide} cambia i nomi delle variabili \texttt{item\_1}, \texttt{item\_2} e \texttt{item\_3} rispettivamente in \texttt{problem\_1}, \texttt{problem\_2} e \texttt{problem\_3}.
\end{enumerate}

\hypertarget{list}{%
\chapter{Liste}\label{list}}

Working in progress.

\hypertarget{creazione-di-liste}{%
\section{Creazione di Liste}\label{creazione-di-liste}}

Le liste sono degli speciali oggi in R che permettono di contenere al loro interno altri oggetti indipendentemente dalla loro tipologia. Possiamo quindi avere nella stessa lista sia vettori, sia matrici sia DataFrames.

In R per definire una lista si utilizza il comando:

\textless- list(nome\_oggetto\_1 = oggetto\_1, \ldots, nome\_oggetto\_n = oggetto\_n)

All'interno si possono riportare vari oggettiche si vogliono inserire con i relativi nomi, separati da virgole.

\hypertarget{esercizi-10}{%
\subsection*{Esercizi}\label{esercizi-10}}
\addcontentsline{toc}{subsection}{Esercizi}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Crea la lista \texttt{esperimento\_1} contenente:

  \begin{itemize}
  \tightlist
  \item
    DataFrame \texttt{data\_wide}
  \item
    la matrice \texttt{A}
  \item
    il vettore \texttt{x}
  \item
    la variabile \texttt{info\ =\ "Prima\ raccolta\ dati"}
  \end{itemize}
\item
  Crea la lista \texttt{esperimento\_2} contenente:

  \begin{itemize}
  \tightlist
  \item
    DataFrame \texttt{data\_long}
  \item
    la matrice \texttt{C}
  \item
    il vettore \texttt{y}
  \item
    la variabile \texttt{info\ =\ "Seconda\ raccolta\ dati"}
  \end{itemize}
\end{enumerate}

\hypertarget{selezione-di-elementi-di-una-lista}{%
\section{Selezione di Elementi di una Lista}\label{selezione-di-elementi-di-una-lista}}

In R per selezioneare gli elementi di una lista si possono usare le doppie parentesi quadre indicando l'indice della posizione dell'oggetto che si vuole selezionare:

\texttt{nome\_lista{[}{[}indice\_posizione{]}{]}}
In alternativa, se i nomi degli oggetti sono stati specificati, è possibile utilizzare l'operatore ``\$'' e il nome dell'oggetto da selezionare all'interno della lista:

\texttt{nome\_lista\$nome\_oggetto}
In seguito per accedere a specifici elementi all'interno degli oggetti si utilizzano le stesse norme precedentemente presentate a seconda del tipo di oggetto.

\textbf{Esempio:}
- \texttt{esperimento\_1{[}{[}2{]}{]}{[},2{]}}
- \texttt{esperimento\_1\$data\_wide\$age}

\textbf{Nota:} per definire o cambiare i nomi degli oggetti contenuti in una lista è possibile utilizzare la funzione: \texttt{names(nome\_lista)\ \textless{}-\ c(nome\_oggetto\_1,\ ...,\ nome\_oggetto\_n)}

\hypertarget{esercizi-11}{%
\subsection*{Esercizi}\label{esercizi-11}}
\addcontentsline{toc}{subsection}{Esercizi}

\begin{enumerate}
\def\labelenumi{\arabic{enumi}.}
\tightlist
\item
  Utilizzando gli \textbf{indici numerici} di posizione selziona i dati dei soggetti \texttt{subj\_1} e \texttt{subj\_4} riguardanti le variabili \texttt{age},\texttt{sex} e \texttt{gruppo} dal DataFrame \texttt{data\_wide} contenuto nella lista \texttt{esperimento\_1}.
\item
  Compi la stessa selezione dell'esercizio precedente usando però questa volta il nome dell'oggetto per selezionare il DateFrame dalla lista.
\item
  Considerando la lista \texttt{esperimento\_2} seleziona gli oggetti \texttt{data\_long}, \texttt{y} e \texttt{info}
\item
  Cambia i nomi degli oggetti contenuti nella lista \texttt{esperimento\_2} rispettivamente in \texttt{"dati\_esperimento"}, \texttt{"matrice\_VCV"}, \texttt{"codici\_Id"} e \texttt{"note"}
\end{enumerate}

\hypertarget{part-algoritmi}{%
\part*{Algoritmi}\label{part-algoritmi}}
\addcontentsline{toc}{part}{Algoritmi}

\hypertarget{introduzione-1}{%
\chapter*{Introduzione}\label{introduzione-1}}
\addcontentsline{toc}{chapter}{Introduzione}

Working in progress.

\hypertarget{functions}{%
\chapter{Definizione di Funzioni}\label{functions}}

Working in progress.

\hypertarget{coditionals}{%
\chapter{Programmazione Condizionale}\label{coditionals}}

Working in progress.

\hypertarget{loop}{%
\chapter{Attenti al loop}\label{loop}}

Working in progress.

\hypertarget{part-case-study}{%
\part*{Case study}\label{part-case-study}}
\addcontentsline{toc}{part}{Case study}

\hypertarget{introduzione-2}{%
\chapter*{Introduzione}\label{introduzione-2}}
\addcontentsline{toc}{chapter}{Introduzione}

Working in progress.

\hypertarget{attachment}{%
\chapter{Caso Studio I: Attaccamento}\label{attachment}}

Working in progress.

\hypertarget{infobox}{%
\section{Infobox}\label{infobox}}

Illustrations included in \texttt{images/} are retrieved from \href{https://rstudio4edu.github.io/rstudio4edu-book/}{rstudio4edu-book} under \href{https://creativecommons.org/licenses/by-nc/2.0/}{CC-BY-NC}. Remember to include an \emph{Attributions} section in the book and repository's README file.

\begin{tip}[My title]

Lorem ipsum dolor sit amet consectetur adipisicing elit. Maxime mollitia,
molestiae quas vel sint commodi repudiandae consequuntur voluptatum laborum
numquam blanditiis harum quisquam eius sed odit fugiat iusto fuga praesentium
optio, eaque rerum!

\end{tip}

\begin{warning}[My title]

Lorem ipsum dolor sit amet consectetur adipisicing elit. Maxime mollitia,
molestiae quas vel sint commodi repudiandae consequuntur voluptatum laborum
numquam blanditiis harum quisquam eius sed odit fugiat iusto fuga praesentium
optio, eaque rerum!

\end{warning}

\begin{deffun}[My title]

Lorem ipsum dolor sit amet consectetur adipisicing elit. Maxime mollitia,
molestiae quas vel sint commodi repudiandae consequuntur voluptatum laborum
numquam blanditiis harum quisquam eius sed odit fugiat iusto fuga praesentium
optio, eaque rerum!

\end{deffun}

\begin{design}[My title]

Lorem ipsum dolor sit amet consectetur adipisicing elit. Maxime mollitia,
molestiae quas vel sint commodi repudiandae consequuntur voluptatum laborum
numquam blanditiis harum quisquam eius sed odit fugiat iusto fuga praesentium
optio, eaque rerum!

\end{design}

\begin{trick}[My title]

Lorem ipsum dolor sit amet consectetur adipisicing elit. Maxime mollitia,
molestiae quas vel sint commodi repudiandae consequuntur voluptatum laborum
numquam blanditiis harum quisquam eius sed odit fugiat iusto fuga praesentium
optio, eaque rerum!

\end{trick}

  \bibliography{book.bib,packages.bib}

\end{document}
